(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var URL_REGEX = /^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/;?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (default, not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = this.parseURL(baseURL);
        if (!baseParts) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = this.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = this.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = URLToolkit;
  else if(typeof define === 'function' && define.amd)
    define([], function() { return URLToolkit; });
  else if(typeof exports === 'object')
    exports["URLToolkit"] = URLToolkit;
  else
    root["URLToolkit"] = URLToolkit;
})(this);
/* jshint ignore:end */

},{}],3:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var workerSources = {};
    resolveSources(skey);

    function resolveSources(key) {
        workerSources[key] = true;

        for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];
            if (!workerSources[depKey]) {
                resolveSources(depKey);
            }
        }
    }

    var src = '(' + bundleFn + ')({'
        + Object.keys(workerSources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};

},{}],4:[function(require,module,exports){
/**
 * HLS config
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
      value: true
});
exports.hlsDefaultConfig = undefined;

var _abrController = require('./controller/abr-controller');

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = require('./controller/buffer-controller');

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = require('./controller/cap-level-controller');

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _fpsController = require('./controller/fps-controller');

var _fpsController2 = _interopRequireDefault(_fpsController);

var _xhrLoader = require('./utils/xhr-loader');

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _audioTrackController = require('./controller/audio-track-controller');

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _audioStreamController = require('./controller/audio-stream-controller');

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _cues = require('./utils/cues');

var _cues2 = _interopRequireDefault(_cues);

var _timelineController = require('./controller/timeline-controller');

var _timelineController2 = _interopRequireDefault(_timelineController);

var _subtitleTrackController = require('./controller/subtitle-track-controller');

var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);

var _subtitleStreamController = require('./controller/subtitle-stream-controller');

var _subtitleStreamController2 = _interopRequireDefault(_subtitleStreamController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//#endif

//#endif

//#if subtitle

//import FetchLoader from './utils/fetch-loader';
//#if altaudio
var hlsDefaultConfig = exports.hlsDefaultConfig = {
      autoStartLoad: true, // used by stream-controller
      startPosition: -1, // used by stream-controller
      defaultAudioCodec: undefined, // used by stream-controller
      debug: false, // used by logger
      capLevelOnFPSDrop: false, // used by fps-controller
      capLevelToPlayerSize: false, // used by cap-level-controller
      initialLiveManifestSize: 1, // used by stream-controller
      maxBufferLength: 30, // used by stream-controller
      maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
      maxBufferHole: 0.5, // used by stream-controller
      maxSeekHole: 2, // used by stream-controller
      lowBufferWatchdogPeriod: 0.5, // used by stream-controller
      highBufferWatchdogPeriod: 3, // used by stream-controller
      nudgeOffset: 0.1, // used by stream-controller
      nudgeMaxRetry: 3, // used by stream-controller
      maxFragLookUpTolerance: 0.2, // used by stream-controller
      liveSyncDurationCount: 3, // used by stream-controller
      liveMaxLatencyDurationCount: Infinity, // used by stream-controller
      liveSyncDuration: undefined, // used by stream-controller
      liveMaxLatencyDuration: undefined, // used by stream-controller
      maxMaxBufferLength: 600, // used by stream-controller
      enableWorker: true, // used by demuxer
      enableSoftwareAES: true, // used by decrypter
      manifestLoadingTimeOut: 10000, // used by playlist-loader
      manifestLoadingMaxRetry: 1, // used by playlist-loader
      manifestLoadingRetryDelay: 1000, // used by playlist-loader
      manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
      startLevel: undefined, // used by level-controller
      levelLoadingTimeOut: 10000, // used by playlist-loader
      levelLoadingMaxRetry: 4, // used by playlist-loader
      levelLoadingRetryDelay: 1000, // used by playlist-loader
      levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
      fragLoadingTimeOut: 20000, // used by fragment-loader
      fragLoadingMaxRetry: 6, // used by fragment-loader
      fragLoadingRetryDelay: 1000, // used by fragment-loader
      fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
      fragLoadingLoopThreshold: 3, // used by stream-controller
      startFragPrefetch: false, // used by stream-controller
      fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
      fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
      appendErrorMaxRetry: 3, // used by buffer-controller
      loader: _xhrLoader2.default,
      //loader: FetchLoader,
      fLoader: undefined,
      pLoader: undefined,
      xhrSetup: undefined,
      fetchSetup: undefined,
      abrController: _abrController2.default,
      bufferController: _bufferController2.default,
      capLevelController: _capLevelController2.default,
      fpsController: _fpsController2.default,
      //#if altaudio
      audioStreamController: _audioStreamController2.default,
      audioTrackController: _audioTrackController2.default,
      //#endif
      //#if subtitle
      subtitleStreamController: _subtitleStreamController2.default,
      subtitleTrackController: _subtitleTrackController2.default,
      timelineController: _timelineController2.default,
      cueHandler: _cues2.default,
      enableCEA708Captions: true, // used by timeline-controller
      enableWebVTT: true, // used by timeline-controller
      captionsTextTrack1Label: 'English', // used by timeline-controller
      captionsTextTrack1LanguageCode: 'en', // used by timeline-controller
      captionsTextTrack2Label: 'Spanish', // used by timeline-controller
      captionsTextTrack2LanguageCode: 'es', // used by timeline-controller
      //#endif
      stretchShortVideoTrack: false, // used by mp4-remuxer
      forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
      abrEwmaFastLive: 3, // used by abr-controller
      abrEwmaSlowLive: 9, // used by abr-controller
      abrEwmaFastVoD: 3, // used by abr-controller
      abrEwmaSlowVoD: 9, // used by abr-controller
      abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
      abrBandWidthFactor: 0.95, // used by abr-controller
      abrBandWidthUpFactor: 0.7, // used by abr-controller
      abrMaxWithRealBitrate: false, // used by abr-controller
      maxStarvationDelay: 4, // used by abr-controller
      maxLoadingDelay: 4, // used by abr-controller
      minAutoBitrate: 0 // used by hls
};

},{"./controller/abr-controller":5,"./controller/audio-stream-controller":6,"./controller/audio-track-controller":7,"./controller/buffer-controller":8,"./controller/cap-level-controller":9,"./controller/fps-controller":10,"./controller/subtitle-stream-controller":14,"./controller/subtitle-track-controller":15,"./controller/timeline-controller":16,"./utils/cues":50,"./utils/xhr-loader":58}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _ewmaBandwidthEstimator = require('../utils/ewma-bandwidth-estimator');

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.onCheck = _this._abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.timer = setInterval(this.onCheck, 100);
        }
        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this._bwEstimator) {
          var hls = this.hls,
              level = data.frag.level,
              isLive = hls.levels[level].details.live,
              config = hls.config,
              ewmaFast = void 0,
              ewmaSlow = void 0;

          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
        this.fragCurrent = frag;
      }
    }
  }, {
    key: '_abandonRulesCheck',
    value: function _abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls,
          v = hls.media,
          frag = this.fragCurrent,
          loader = frag.loader,
          minAutoLevel = hls.minAutoLevel;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
        this.clearTimer();
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(v.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          level = levels[frag.level],
              levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
              expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
              pos = v.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
              fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this._bwEstimator.sample(requestDelay, stats.loaded);
              //abort fragment loading
              loader.abort();
              // stop abandon rules timer
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main' && !isNaN(frag.sn)) {
        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.level;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;

        // compute level average bitrate
        if (this.hls.config.abrMaxWithRealBitrate) {
          var level = this.hls.levels[frag.level];
          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
          level.loaded = { bytes: loadedBytes, duration: loadedDuration };
          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
        }
        // if fragment has been loaded to perform a bitrate test,
        if (data.frag.bitrateTest) {
          var stats = data.stats;
          stats.tparsed = stats.tbuffered = stats.tload;
          this.onFragBuffered(data);
        }
      }
    }
  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(data) {
      var stats = data.stats,
          frag = data.frag;
      // only update stats on first frag buffering
      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
      // and leading to wrong bw estimation
      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
      if (stats.aborted !== true && frag.loadCounter === 1 && frag.type === 'main' && !isNaN(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
        this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
        stats.bwEstimate = this._bwEstimator.getEstimate();
        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
        if (frag.bitrateTest) {
          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
        } else {
          this.bitrateTestDelay = 0;
        }
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    }

    // return next auto level

  }, {
    key: '_findBestLevel',
    value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
        var levelInfo = levels[i],
            levelDetails = levelInfo.details,
            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
            live = levelDetails ? levelDetails.live : false,
            adjustedbw = void 0;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }
        var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
            fetchDuration = bitrate * avgDuration / adjustedbw;

        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
        // if adjusted bw is greater than level bitrate AND
        if (adjustedbw > bitrate && (
        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        !fetchDuration || live || fetchDuration < maxFetchDuration)) {
          // as we are looping from highest to lowest, this will return the best achievable quality level

          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this._bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        return forcedAutoLevel;
      }
      // compute next level using ABR logic
      var nextABRAutoLevel = this._nextABRAutoLevel;
      // if forced auto level has been defined, use it to cap ABR computed quality level
      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }
      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: '_nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = hls.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = hls.minAutoLevel;
      var v = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = v ? v.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;

},{"../errors":33,"../event-handler":34,"../events":35,"../helper/buffer-helper":37,"../utils/ewma-bandwidth-estimator":51,"../utils/logger":53}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS'
};

var AudioStreamController = function (_EventHandler) {
  _inherits(AudioStreamController, _EventHandler);

  function AudioStreamController(hls) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this._state = State.STOPPED;
    _this.ontick = _this.tick.bind(_this);
    _this.initPTS = [];
    _this.waitingFragment = null;
    return _this;
  }

  _createClass(AudioStreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }

    //Signal that video PTS was found

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var demuxerId = data.id,
          cc = data.frag.cc,
          initPTS = data.initPTS;
      if (demuxerId === 'main') {
        //Always update the new INIT PTS
        //Can change due level switch
        this.initPTS[cc] = initPTS;
        _logger.logger.log('InitPTS for cc:' + cc + ' found from video track:' + initPTS);

        //If we are waiting we need to demux/remux the waiting frag
        //With the new initPTS
        if (this.state === State.WAITING_INIT_PTS) {
          _logger.logger.log('sending pending audio frag to demuxer');
          this.state = State.FRAG_LOADING;
          //We have audio frag waiting or video pts
          //Let process it
          this.onFragLoaded(this.waitingFragment);
          //Lets clean the waiting frag
          this.waitingFragment = null;
        }
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.fragLoadError = 0;
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          this.state = State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var pos,
          track,
          trackDetails,
          hls = this.hls,
          config = hls.config;
      //logger.log('audioStream:' + this.state);
      switch (this.state) {
        case State.ERROR:
        //don't do anything in error state to avoid breaking further ...
        case State.PAUSED:
        //don't do anything in paused state either ...
        case State.BUFFER_FLUSHING:
          break;
        case State.STARTING:
          this.state = State.WAITING_TRACK;
          this.loadedmetadata = false;
          break;
        case State.IDLE:
          var tracks = this.tracks;
          // audio tracks not received => exit loop
          if (!tracks) {
            break;
          }
          // if video not attached AND
          // start fragment already requested OR start frag prefetch disable
          // exit loop
          // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
          if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
            break;
          }
          // determine next candidate fragment to be loaded, based on current position and
          //  end of buffer position
          // if we have not yet loaded any fragment, start loading from start position
          if (this.loadedmetadata) {
            pos = this.media.currentTime;
          } else {
            pos = this.nextLoadPosition;
          }
          var media = this.mediaBuffer ? this.mediaBuffer : this.media,
              bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
              bufferLen = bufferInfo.len,
              bufferEnd = bufferInfo.end,
              fragPrevious = this.fragPrevious,
              maxBufLen = config.maxMaxBufferLength,
              audioSwitch = this.audioSwitch,
              trackId = this.trackId;

          // if buffer length is less than maxBufLen try to load a new fragment
          if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
            trackDetails = tracks[trackId].details;
            // if track info not retrieved yet, switch state and wait for track retrieval
            if (typeof trackDetails === 'undefined') {
              this.state = State.WAITING_TRACK;
              break;
            }

            // we just got done loading the final fragment, check if we need to finalize media stream
            if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {
              // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
              // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
              // between different renditions. using half frag duration should help cope with these cases.
              if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) {
                // Finalize the media stream
                this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
                this.state = State.ENDED;
                break;
              }
            }

            // find fragment index, contiguous with end of buffer position
            var fragments = trackDetails.fragments,
                fragLen = fragments.length,
                start = fragments[0].start,
                end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                frag = void 0;

            // When switching audio track, reload audio as close as possible to currentTime
            if (audioSwitch) {
              if (trackDetails.live && !trackDetails.PTSKnown) {
                _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                bufferEnd = 0;
              } else {
                bufferEnd = pos;
                // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                if (trackDetails.PTSKnown && pos < start) {
                  // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                  if (bufferInfo.end > start || bufferInfo.nextStart) {
                    _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                    this.media.currentTime = start + 0.05;
                  } else {
                    return;
                  }
                }
              }
            }
            if (trackDetails.initSegment && !trackDetails.initSegment.data) {
              frag = trackDetails.initSegment;
            }
            // if bufferEnd before start of playlist, load first fragment
            else if (bufferEnd <= start) {
                frag = fragments[0];
                if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                  // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                  // let's force seek to start
                  var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                  _logger.logger.log('no alt audio available @currentTime:' + this.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                  this.media.currentTime = nextBuffered + 0.05;
                  return;
                }
              } else {
                var foundFrag = void 0;
                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                  // offset should be within fragment boundary - config.maxFragLookUpTolerance
                  // this is to cope with situations like
                  // bufferEnd = 9.991
                  // frag[Ø] : [0,10]
                  // frag[1] : [10,20]
                  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                  //              frag start               frag start+duration
                  //                  |-----------------------------|
                  //              <--->                         <--->
                  //  ...--------><-----------------------------><---------....
                  // previous frag         matching fragment         next frag
                  //  return -1             return 0                 return 1
                  //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                    return 1;
                  } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                  else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                      return -1;
                    }
                  return 0;
                };

                if (bufferEnd < end) {
                  if (bufferEnd > end - maxFragLookUpTolerance) {
                    maxFragLookUpTolerance = 0;
                  }
                  // Prefer the next fragment if it's within tolerance
                  if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                    foundFrag = fragNext;
                  } else {
                    foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
                  }
                } else {
                  // reach end of playlist
                  foundFrag = fragments[fragLen - 1];
                }
                if (foundFrag) {
                  frag = foundFrag;
                  start = foundFrag.start;
                  //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                  if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                    if (frag.sn < trackDetails.endSN) {
                      frag = fragments[frag.sn + 1 - trackDetails.startSN];
                      _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                    } else {
                      frag = null;
                    }
                  }
                }
              }
            if (frag) {
              //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
              if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
                this.state = State.KEY_LOADING;
                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
              } else {
                _logger.logger.log('Loading ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                // ensure that we are not reloading the same fragments in loop ...
                if (this.fragLoadIdx !== undefined) {
                  this.fragLoadIdx++;
                } else {
                  this.fragLoadIdx = 0;
                }
                if (frag.loadCounter) {
                  frag.loadCounter++;
                  var maxThreshold = config.fragLoadingLoopThreshold;
                  // if this frag has already been loaded 3 times, and if it has been reloaded recently
                  if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
                    return;
                  }
                } else {
                  frag.loadCounter = 1;
                }
                frag.loadIdx = this.fragLoadIdx;
                this.fragCurrent = frag;
                this.startFragRequested = true;
                if (!isNaN(frag.sn)) {
                  this.nextLoadPosition = frag.start + frag.duration;
                }
                hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                this.state = State.FRAG_LOADING;
              }
            }
          }
          break;
        case State.WAITING_TRACK:
          track = this.tracks[this.trackId];
          // check if playlist is already loaded
          if (track && track.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          media = this.media;
          var isSeeking = media && media.seeking;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || isSeeking) {
            _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.WAITING_INIT_PTS:
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var tracks = this.tracks;
      if (tracks) {
        // reset fragment load counter
        tracks.forEach(function (track) {
          if (track.details) {
            track.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (this.media) {
        this.lastCurrentTime = this.media.currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url;
      this.trackId = data.id;
      this.state = State.IDLE;

      this.fragCurrent = null;
      this.state = State.PAUSED;
      this.waitingFragment = null;
      // destroy useless demuxer when switching audio to main
      if (!altAudio) {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
      }

      //should we switch tracks ?
      if (altAudio) {
        this.audioSwitch = true;
        //main audio track are handled by stream-controller, just do something if switching to alt audio track
        this.state = State.IDLE;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        if (this.fragLoadIdx !== undefined) {
          this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
        }
      }
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var newDetails = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = track.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          // TODO
          //this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live audio playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      track.details = newDetails;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === State.WAITING_TRACK) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            trackId = fragCurrent.level,
            sn = fragCurrent.sn,
            cc = fragCurrent.cc,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
            stats = this.stats = data.stats;
        if (sn === 'initSegment') {
          this.state = State.IDLE;

          stats.tparsed = stats.tbuffered = performance.now();
          details.initSegment.data = data.payload;
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
          this.tick();
        } else {
          this.state = State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.appended = false;
          if (!this.demuxer) {
            this.demuxer = new _demuxer2.default(this.hls, 'audio');
          }
          //Check if we have video initPTS
          // If not we need to wait for it
          var initPTS = this.initPTS[cc];
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          if (details.initSegment || initPTS !== undefined) {
            this.pendingBuffering = true;
            _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
            var accurateTimeOffset = false; //details.PTSKnown || !details.live;
            this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
          } else {
            _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            this.waitingFragment = data;
            this.state = State.WAITING_INIT_PTS;
          }
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // delete any video track found on audio demuxer
        if (tracks.video) {
          delete tracks.video;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = 'mp4a.40.2';
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
            if (this.audioSwitch) {
              this.pendingData = [appendObj];
            } else {
              this.appended = true;
              // arm pending Buffering flag before appending a segment
              this.pendingBuffering = true;
              this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
            }
          }
          //trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        var trackId = this.trackId,
            track = this.tracks[trackId],
            hls = this.hls;

        if (isNaN(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
        _levelHelper2.default.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);

        var audioSwitch = this.audioSwitch,
            media = this.media,
            appendOnBufferFlush = false;
        //Only flush audio from old audio tracks when PTS is known on new audio track
        if (audioSwitch && media) {
          if (media.readyState) {
            var currentTime = media.currentTime;
            _logger.logger.log('switching audio track : currentTime:' + currentTime);
            if (currentTime >= data.startPTS) {
              _logger.logger.log('switching audio track : flushing all audio');
              this.state = State.BUFFER_FLUSHING;
              hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
              appendOnBufferFlush = true;
              //Lets announce that the initial audio track switch flush occur
              this.audioSwitch = false;
              hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            }
          } else {
            //Lets announce that the initial audio track switch flush occur
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
          }
        }

        var pendingData = this.pendingData;
        if (!this.audioSwitch) {
          [data.data1, data.data2].forEach(function (buffer) {
            if (buffer && buffer.length) {
              pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
            }
          });
          if (!appendOnBufferFlush && pendingData.length) {
            pendingData.forEach(function (appendObj) {
              // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
              // in that case it is useless to append following segments
              if (_this2.state === State.PARSING) {
                // arm pending Buffering flag before appending a segment
                _this2.pendingBuffering = true;
                _this2.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
              }
            });
            this.pendingData = [];
            this.appended = true;
          }
        }
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        var state = this.state;
        if (state === State.PARSING || state === State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent,
            stats = this.stats,
            hls = this.hls;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          if (this.audioSwitch && this.appended) {
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
          }
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            var config = this.config;
            if (loadError <= config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? State.ERROR : State.IDLE;
            _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'audio' && (this.state === State.PARSING || this.state === State.PARSED)) {
            var media = this.mediaBuffer,
                currentTime = this.media.currentTime,
                mediaBuffered = media && _bufferHelper2.default.isBuffered(media, currentTime) && _bufferHelper2.default.isBuffered(media, currentTime + 0.5);
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              var _config = this.config;
              if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
                // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                _config.maxMaxBufferLength /= 2;
                _logger.logger.warn('audio:reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
                // increase fragment load Index to avoid frag loop loading error after buffer flush
                this.fragLoadIdx += 2 * _config.fragLoadingLoopThreshold;
              }
              this.state = State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole audio buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush audio buffer');
              this.fragCurrent = null;
              // flush everything
              this.state = State.BUFFER_FLUSHING;
              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      var _this3 = this;

      var pendingData = this.pendingData;
      if (pendingData && pendingData.length) {
        _logger.logger.log('appending pending audio data on Buffer Flushed');
        pendingData.forEach(function (appendObj) {
          _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
        });
        this.appended = true;
        this.pendingData = [];
        this.state = State.PARSED;
      } else {
        // move to IDLE once flush complete. this should trigger new fragment loading
        this.state = State.IDLE;
        // reset reference to frag
        this.fragPrevious = null;
        this.tick();
      }
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('audio stream:' + previousState + '->' + nextState);
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return AudioStreamController;
}(_eventHandler2.default);

exports.default = AudioStreamController;

},{"../demux/demuxer":25,"../errors":33,"../event-handler":34,"../events":35,"../helper/buffer-helper":37,"../helper/level-helper":38,"../utils/binary-search":48,"../utils/logger":53,"../utils/timeRanges":54}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var AudioTrackController = function (_EventHandler) {
  _inherits(AudioTrackController, _EventHandler);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));

    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(AudioTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      this.updateTrack(this.trackId);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset audio tracks on manifest loading
      this.tracks = [];
      this.trackId = -1;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this2 = this;

      var tracks = data.audioTracks || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
      // loop through available audio tracks and autoselect default if needed
      var id = 0;
      tracks.forEach(function (track) {
        if (track.default) {
          _this2.audioTrack = id;
          defaultFound = true;
          return;
        }
        id++;
      });
      if (defaultFound === false && tracks.length) {
        _logger.logger.log('no default audio track defined, use first audio track as default');
        this.audioTrack = 0;
      }
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id < this.tracks.length) {
        _logger.logger.log('audioTrack ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'setAudioTrackInternal',
    value: function setAudioTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            hls = this.hls,
            type = audioTrack.type,
            url = audioTrack.url,
            eventObj = { id: newId, type: type, url: url };
        // keep AUDIO_TRACK_SWITCH for legacy reason
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, eventObj);
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, eventObj);
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (url && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
        }
      }
    }
  }, {
    key: 'updateTrack',
    value: function updateTrack(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('updating audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            url = audioTrack.url;
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (url && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
        }
      }
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.trackId;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
        this.setAudioTrackInternal(audioTrackId);
      }
    }
  }]);

  return AudioTrackController;
}(_eventHandler2.default);

exports.default = AudioTrackController;

},{"../event-handler":34,"../events":35,"../utils/logger":53}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onLevelPtsUpdated',
    value: function onLevelPtsUpdated(data) {
      var type = data.type;
      var audioTrack = this.tracks.audio;

      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
      // event if SB is in updating state.
      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
        // Chrome audio mp3 track
        var audioBuffer = this.sourceBuffer.audio;
        var delta = Math.abs(audioBuffer.timestampOffset - data.start);

        // adjust timestamp offset if time delta is greater than 100ms
        if (delta > 0.1) {
          var updating = audioBuffer.updating;

          try {
            audioBuffer.abort();
          } catch (err) {
            updating = true;
            _logger.logger.warn('can not abort audio buffer: ' + err);
          }

          if (!updating) {
            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
            audioBuffer.timestampOffset = data.start;
          } else {
            this.audioTimestampOffset = data.start;
          }
        }
      }
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var audioExpected = data.audio,
          videoExpected = data.video,
          sourceBufferNb = 0;
      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
      // it will contain the expected nb of source buffers, no need to compute it
      if (data.altAudio && (audioExpected || videoExpected)) {
        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
      }
      this.sourceBufferNb = sourceBufferNb;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        //Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = URL.createObjectURL(ms);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          URL.revokeObjectURL(this.media.src);
          this.media.removeAttribute('src');
          this.media.load();
        }

        this.mediaSource = null;
        this.media = null;
        this.pendingTracks = {};
        this.tracks = {};
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      // if any buffer codecs pending, check if we have enough to create sourceBuffers
      var pendingTracks = this.pendingTracks,
          pendingTracksNb = Object.keys(pendingTracks).length;
      // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)
      if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {
      // update timestampOffset
      if (this.audioTimestampOffset) {
        var audioBuffer = this.sourceBuffer.audio;
        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
        audioBuffer.timestampOffset = this.audioTimestampOffset;
        delete this.audioTimestampOffset;
      }

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }
      this.appending = false;
      var parent = this.parent;
      // count nb of pending segments waiting for appending on this sourcebuffer
      var pending = this.segments.reduce(function (counter, segment) {
        return segment.parent === parent ? counter + 1 : counter;
      }, 0);
      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending });

      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:', event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      if (Object.keys(this.sourceBuffer).length === 0) {
        for (var trackName in tracks) {
          this.pendingTracks[trackName] = tracks[trackName];
        }
        var mediaSource = this.mediaSource;
        if (mediaSource && mediaSource.readyState === 'open') {
          // try to create sourcebuffers if mediasource opened
          this.checkPendingTracks();
        }
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;

      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            this.tracks[trackName] = { codec: codec, container: track.container };
            track.buffer = sb;
          } catch (err) {
            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
          }
        }
      }
      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }
        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:', data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        var sbobj = sb[type];
        if (!sbobj.ended) {
          return;
        }
        if (sbobj.updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
      //Notify the media element that it now has all of the media data
      try {
        mediaSource.endOfStream();
      } catch (e) {
        _logger.logger.warn('exception while calling mediaSource.endOfStream()');
      }
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediatly
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(event) {
      var details = event.details;
      if (details.fragments.length === 0) {
        return;
      }
      this._levelDuration = details.totalduration + details.fragments[0].start;
      this.updateMediaElementDuration();
    }

    // https://github.com/video-dev/hls.js/issues/355

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      var media = this.media,
          mediaSource = this.mediaSource,
          sourceBuffer = this.sourceBuffer,
          levelDuration = this._levelDuration;
      if (levelDuration === null || !media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {
        return;
      }
      for (var type in sourceBuffer) {
        if (sourceBuffer[type].updating) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }
      if (this._msDuration === null) {
        // initialise to the value that the media source is reporting
        this._msDuration = mediaSource.duration;
      }
      var duration = media.duration;
      // levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update mediasource duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level
      if (levelDuration > this._msDuration && levelDuration > duration || duration === Infinity || isNaN(duration)) {
        _logger.logger.log('Updating mediasource duration to ' + levelDuration.toFixed(3));
        this._msDuration = mediaSource.duration = levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        try {
          for (var type in sourceBuffer) {
            appended += sourceBuffer[type].buffered.length;
          }
        } catch (error) {
          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
          // this is harmess at this stage, catch this to avoid reporting an internal exception
          _logger.logger.error('error while accessing sourceBuffer.buffered');
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          sourceBuffer = this.sourceBuffer,
          segments = this.segments;
      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          //logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type,
                sb = sourceBuffer[type];
            if (sb) {
              if (!sb.updating) {
                // reset sourceBuffer ended flag before appending segment
                sb.ended = false;
                //logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                this.parent = segment.parent;
                sb.appendBuffer(segment.data);
                this.appendError = 0;
                this.appended++;
                this.appending = true;
              } else {
                segments.unshift(segment);
              }
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }
              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
                return;
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              event.fatal = false;
              hls.trigger(_events2.default.ERROR, event);
              return;
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb,
          i,
          bufStart,
          bufEnd,
          flushStart,
          flushEnd,
          sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }
            sb = sourceBuffer[type];
            // we are going to flush buffer, mark source buffer as 'not ended'
            sb.ended = false;
            if (!sb.updating) {
              try {
                for (i = 0; i < sb.buffered.length; i++) {
                  bufStart = sb.buffered.start(i);
                  bufEnd = sb.buffered.end(i);
                  // workaround firefox not able to properly flush multiple buffered range.
                  if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                    flushStart = startOffset;
                    flushEnd = endOffset;
                  } else {
                    flushStart = Math.max(bufStart, startOffset);
                    flushEnd = Math.min(bufEnd, endOffset);
                  }
                  /* sometimes sourcebuffer.remove() does not flush
                     the exact expected time range.
                     to avoid rounding issues/infinite loop,
                     only flush buffer range of length greater than 500ms.
                  */
                  if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                    this.flushBufferCounter++;
                    _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                    sb.remove(flushStart, flushEnd);
                    return false;
                  }
                }
              } catch (e) {
                _logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');
              }
            } else {
              //logger.log('abort ' + type + ' append in progress');
              // this will abort any appending in progress
              //sb.abort();
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;

},{"../errors":33,"../event-handler":34,"../events":35,"../utils/logger":53}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = this.restrictedLevels = null;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
          this.timer = clearInterval(this.timer);
        }
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      if (!this.restrictedLevels) {
        this.restrictedLevels = [];
      }
      if (!this.isLevelRestricted(data.droppedLevel)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var hls = this.hls;
      if (hls.config.capLevelToPlayerSize) {
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.levels = data.levels;
        hls.firstLevel = this.getMaxLevel(data.firstLevel);
        clearInterval(this.timer);
        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
        this.detectPlayerSize();
      }
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          var hls = this.hls;
          hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var result = 0,
          i = void 0,
          level = void 0,
          mWidth = this.mediaWidth,
          mHeight = this.mediaHeight,
          lWidth = 0,
          lHeight = 0;

      for (i = 0; i <= capLevelIndex; i++) {
        level = this.levels[i];
        if (this.isLevelRestricted(i)) {
          break;
        }
        result = i;
        lWidth = level.width;
        lHeight = level.height;
        if (mWidth <= lWidth || mHeight <= lHeight) {
          break;
        }
      }
      return result;
    }
  }, {
    key: 'isLevelRestricted',
    value: function isLevelRestricted(level) {
      return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      var media = this.media;
      if (media) {
        width = media.width || media.clientWidth || media.offsetWidth;
        width *= this.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      var media = this.media;
      if (media) {
        height = media.height || media.clientHeight || media.offsetHeight;
        height *= this.contentScaleFactor;
      }
      return height;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;

},{"../event-handler":34,"../events":35}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var config = this.hls.config;
      if (config.capLevelOnFPSDrop) {
        var video = this.video = data.media instanceof HTMLVideoElement ? data.media : null;
        if (typeof video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }
        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod,
              hls = this.hls;
          hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
                hls.autoLevelCapping = currentLevel;
                hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      var video = this.video;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;

},{"../event-handler":34,"../events":35,"../utils/logger":53}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * id3 metadata track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var ID3TrackController = function (_EventHandler) {
  _inherits(ID3TrackController, _EventHandler);

  function ID3TrackController(hls) {
    _classCallCheck(this, ID3TrackController);

    var _this = _possibleConstructorReturn(this, (ID3TrackController.__proto__ || Object.getPrototypeOf(ID3TrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_METADATA));

    _this.id3Track = undefined;
    _this.media = undefined;
    return _this;
  }

  _createClass(ID3TrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Add ID3 metatadata text track.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      this.media = data.media;
      if (!this.media) {
        return;
      }

      this.id3Track = this.media.addTextTrack('metadata', 'id3');
      this.id3Track.mode = 'hidden';
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this.media = undefined;
    }
  }, {
    key: 'onFragParsingMetadata',
    value: function onFragParsingMetadata(data) {
      var fragment = data.frag;
      var samples = data.samples;
      var startTime = fragment.start;
      var endTime = fragment.start + fragment.duration;
      // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
      if (startTime === endTime) {
        endTime += 0.0001;
      }

      // Attempt to recreate Safari functionality by creating
      // WebKitDataCue objects when available and store the decoded
      // ID3 data in the value property of the cue
      var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;

      for (var i = 0; i < samples.length; i++) {
        var frames = this.parseID3Tag(samples[i].data);
        if (frames) {
          for (var j = 0; j < frames.length; j++) {
            var cue = new Cue(startTime, endTime, '');
            cue.value = frames[j];
            this.id3Track.addCue(cue);
          }
        }
      }
    }
  }, {
    key: 'parseID3Tag',
    value: function parseID3Tag(data) {
      if (data.length < 10) {
        return undefined;
      }

      var offset = 0;
      var frames = [];

      while (offset < data.length) {
        /* http://id3.org/id3v2.3.0
        [0]     = 'I'
        [1]     = 'D'
        [2]     = '3'
        [3,4]   = {Version}
        [5]     = {Flags}
        [6-9]   = {ID3 Size}
        */
        var header = String.fromCharCode(data[offset++], data[offset++], data[offset++]);
        if (header === 'ID3') {

          //skip version and flags
          offset += 3;

          var size = 0;
          size = (data[offset++] & 0x7f) << 21;
          size |= (data[offset++] & 0x7f) << 14;
          size |= (data[offset++] & 0x7f) << 7;
          size |= data[offset++] & 0x7f;

          var decodedFrames = this.decodeID3Frames(data.subarray(offset, offset + size));
          frames = frames.concat(decodedFrames);

          offset += size;
        } else if (header === '3DI') {
          //footer is same size as header
          offset += 7;
        }
      }

      return frames;
    }
  }, {
    key: 'decodeID3Frames',
    value: function decodeID3Frames(data) {
      var offset = 0;
      var frames = [];

      while (offset < data.length) {
        /*
        Frame ID       $xx xx xx xx (four characters)
        Size           $xx xx xx xx
        Flags          $xx xx
        */
        var type = String.fromCharCode(data[offset++], data[offset++], data[offset++], data[offset++]);

        var size = 0;
        size = (data[offset++] & 0x7f) << 21;
        size |= (data[offset++] & 0x7f) << 14;
        size |= (data[offset++] & 0x7f) << 7;
        size |= data[offset++] & 0x7f;

        //skip flags
        offset += 2;

        var frame = this.decodeID3Frame({ type: type, size: size, data: data.subarray(offset, offset + size) });
        if (frame) {
          frames.push(frame);
        }
        offset += size;
      }

      return frames;
    }
  }, {
    key: 'decodeID3Frame',
    value: function decodeID3Frame(frame) {
      if (frame.type === 'PRIV') {
        return this.decodePrivFrame(frame);
      } else if (frame.type === 'TXXX') {
        return this.decodeTxxxFrame(frame);
      } else if (frame.type[0] === 'T') {
        return this.decodeTextFrame(frame);
      } else if (frame.type === 'WXXX') {
        return this.decodeWXXXFrame(frame);
      } else if (frame.type[0] === 'W') {
        return this.decodeURLLinkFrame(frame);
      }

      return undefined;
    }
  }, {
    key: 'decodeTxxxFrame',
    value: function decodeTxxxFrame(frame) {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{Value}
      */

      if (frame.size < 2) {
        return undefined;
      }

      if (frame.data[0] !== 3) {
        //only support UTF-8
        return undefined;
      }

      var index = 1;
      var description = this.utf8ArrayToStr(frame.data.subarray(index));

      index += description.length + 1;
      var value = this.utf8ArrayToStr(frame.data.subarray(index));

      return { key: frame.type, info: description, data: value };
    }
  }, {
    key: 'decodeTextFrame',
    value: function decodeTextFrame(frame) {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Value}
      */

      if (frame.size < 2) {
        return undefined;
      }

      if (frame.data[0] !== 3) {
        //only support UTF-8
        return undefined;
      }

      var text = this.utf8ArrayToStr(frame.data.subarray(1));
      return { key: frame.type, data: text };
    }
  }, {
    key: 'decodePrivFrame',
    value: function decodePrivFrame(frame) {
      /*
      Format: <text string>\0<binary data>
      */

      if (frame.size < 2) {
        return undefined;
      }

      var owner = this.utf8ArrayToStr(frame.data);
      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));

      return { key: frame.type, info: owner, data: privateData.buffer };
    }
  }, {
    key: 'decodeWXXXFrame',
    value: function decodeWXXXFrame(frame) {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{URL}
      */
      if (frame.size < 2) {
        return undefined;
      }

      if (frame.data[0] !== 3) {
        //only support UTF-8
        return undefined;
      }

      var index = 1;
      var description = this.utf8ArrayToStr(frame.data.subarray(index));

      index += description.length + 1;
      var value = this.utf8ArrayToStr(frame.data.subarray(index));

      return { key: frame.type, info: description, data: value };
    }
  }, {
    key: 'decodeURLLinkFrame',
    value: function decodeURLLinkFrame(frame) {
      /*
      Format:
      [0-?]   = {URL}
      */
      var url = this.utf8ArrayToStr(frame.data);
      return { key: frame.type, data: url };
    }

    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
    /* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */

  }, {
    key: 'utf8ArrayToStr',
    value: function utf8ArrayToStr(array) {

      var char2 = void 0;
      var char3 = void 0;
      var out = '';
      var i = 0;
      var length = array.length;

      while (i < length) {
        var c = array[i++];
        switch (c >> 4) {
          case 0:
            return out;
          case 1:case 2:case 3:case 4:case 5:case 6:case 7:
            // 0xxxxxxx
            out += String.fromCharCode(c);
            break;
          case 12:case 13:
            // 110x xxxx   10xx xxxx
            char2 = array[i++];
            out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
            break;
          case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
            break;
        }
      }

      return out;
    }
  }]);

  return ID3TrackController;
}(_eventHandler2.default);

exports.default = ID3TrackController;

},{"../event-handler":34,"../events":35}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.ontick = _this.tick.bind(_this);
    _this._manualLevel = -1;
    return _this;
  }

  _createClass(LevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this._manualLevel = -1;
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.canload = true;
      var levels = this._levels;
      // clean up live level details to force reload them, and reset load errors
      if (levels) {
        levels.forEach(function (level) {
          level.loadError = 0;
          var levelDetails = level.details;
          if (levelDetails && levelDetails.live) {
            level.details = undefined;
          }
        });
      }
      // speed up live playlist refresh if timer exists
      if (this.timer) {
        this.tick();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels0 = [],
          levels = [],
          bitrateStart,
          bitrateSet = {},
          videoCodecFound = false,
          audioCodecFound = false,
          hls = this.hls,
          brokenmp4inmp3 = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
          checkSupported = function checkSupported(type, codec) {
        return MediaSource.isTypeSupported(type + '/mp4;codecs=' + codec);
      };

      // regroup redundant level together
      data.levels.forEach(function (level) {
        if (level.videoCodec) {
          videoCodecFound = true;
        }
        // erase audio codec info if browser does not support mp4a.40.34. demuxer will autodetect codec and fallback to mpeg/audio
        if (brokenmp4inmp3 && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
          level.audioCodec = undefined;
        }
        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {
          audioCodecFound = true;
        }
        var redundantLevelId = bitrateSet[level.bitrate];
        if (redundantLevelId === undefined) {
          bitrateSet[level.bitrate] = levels0.length;
          level.url = [level.url];
          level.urlId = 0;
          levels0.push(level);
        } else {
          levels0[redundantLevelId].url.push(level.url);
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels0.forEach(function (level) {
          if (level.videoCodec) {
            levels.push(level);
          }
        });
      } else {
        levels = levels0;
      }
      // only keep level with supported audio/video codecs
      levels = levels.filter(function (level) {
        var audioCodec = level.audioCodec,
            videoCodec = level.videoCodec;
        return (!audioCodec || checkSupported('audio', audioCodec)) && (!videoCodec || checkSupported('video', videoCodec));
      });

      if (levels.length) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }
        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound, altAudio: data.audioTracks.length > 0 });
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });
      }
      return;
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      var hls = this.hls;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        if (this._level !== newLevel) {
          _logger.logger.log('switching to level ' + newLevel);
          this._level = newLevel;
          var levelProperties = levels[newLevel];
          levelProperties.level = newLevel;
          // LEVEL_SWITCH to be deprecated in next major release
          hls.trigger(_events2.default.LEVEL_SWITCH, levelProperties);
          hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);
        }
        var level = levels[newLevel],
            levelDetails = level.details;
        // check if we need to load playlist for this level
        if (!levelDetails || levelDetails.live === true) {
          // level not retrieved yet, or live playlist we need to (re)load it
          var urlId = level.urlId;
          hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        return;
      }

      var details = data.details,
          hls = this.hls,
          levelId = void 0,
          level = void 0,
          levelError = false;
      // try to recover not fatal errors
      switch (details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelId = data.frag.level;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelId = data.context.level;
          levelError = true;
          break;
        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
          levelId = data.level;
          break;
        default:
          break;
      }
      /* try to switch to a redundant stream if any available.
       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
       * otherwise, we cannot recover this network error ...
       */
      if (levelId !== undefined) {
        level = this._levels[levelId];
        if (!level.loadError) {
          level.loadError = 1;
        } else {
          level.loadError++;
        }
        // if any redundant streams available and if we haven't try them all (level.loadError is reseted on successful frag/level load.
        // if level.loadError reaches nbRedundantLevel it means that we tried them all, no hope  => let's switch down
        var nbRedundantLevel = level.url.length;
        if (nbRedundantLevel > 1 && level.loadError < nbRedundantLevel) {
          level.urlId = (level.urlId + 1) % nbRedundantLevel;
          level.details = undefined;
          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);
        } else {
          // we could try to recover if in auto mode and current level not lowest level (0)
          var recoverable = this._manualLevel === -1 && levelId;
          if (recoverable) {
            _logger.logger.warn('level controller,' + details + ': switch-down for next fragment');
            hls.nextAutoLevel = Math.max(0, levelId - 1);
          } else if (level && level.details && level.details.live) {
            _logger.logger.warn('level controller,' + details + ' on live stream, discard');
            if (levelError) {
              // reset this._level so that another call to set level() will retrigger a frag load
              this._level = undefined;
            }
            // other errors are handled by stream controller
          } else if (details === _errors.ErrorDetails.LEVEL_LOAD_ERROR || details === _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT) {
            var media = hls.media,

            // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
            mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
            if (mediaBuffered) {
              var retryDelay = hls.config.levelLoadingRetryDelay;
              _logger.logger.warn('level controller,' + details + ', but media buffered, retry in ' + retryDelay + 'ms');
              this.timer = setTimeout(this.ontick, retryDelay);
              // boolean used to inform stream controller not to switch back to IDLE on non fatal error
              data.levelRetry = true;
            } else {
              _logger.logger.error('cannot recover ' + details + ' error');
              this._level = undefined;
              // stopping live reloading timer if any
              if (this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
              }
              // switch error to fatal
              data.fatal = true;
            }
          }
        }
      }
    }

    // reset level load error counter on successful frag loaded

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragLoaded = data.frag;
      if (fragLoaded && fragLoaded.type === 'main') {
        var level = this._levels[fragLoaded.level];
        if (level) {
          level.loadError = 0;
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var levelId = data.level;
      // only process level loaded events matching with expected level
      if (levelId === this._level) {
        var curLevel = this._levels[levelId];
        // reset level load error counter on successful level loaded
        curLevel.loadError = 0;
        var newDetails = data.details;
        // if current playlist is a live playlist, arm a timer to reload it
        if (newDetails.live) {
          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
              curDetails = curLevel.details;
          if (curDetails && newDetails.endSN === curDetails.endSN) {
            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
            // changed then it MUST wait for a period of one-half the target
            // duration before retrying.
            reloadInterval /= 2;
            _logger.logger.log('same live playlist, reload twice faster');
          }
          // decrement reloadInterval with level loading delay
          reloadInterval -= performance.now() - data.stats.trequest;
          // in any case, don't reload more than every second
          reloadInterval = Math.max(1000, Math.round(reloadInterval));
          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');
          this.timer = setTimeout(this.ontick, reloadInterval);
        } else {
          this.timer = null;
        }
      }
    }
  }, {
    key: 'tick',
    value: function tick() {
      var levelId = this._level;
      if (levelId !== undefined && this.canload) {
        var level = this._levels[levelId];
        if (level && level.url) {
          var urlId = level.urlId;
          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });
        }
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this._level;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels && levels.length > newLevel) {
        if (this._level !== newLevel || levels[newLevel].details === undefined) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this._manualLevel;
    },
    set: function set(newLevel) {
      this._manualLevel = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this._manualLevel !== -1) {
        return this._manualLevel;
      } else {
        return this.hls.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this._manualLevel === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;

},{"../errors":33,"../event-handler":34,"../events":35,"../helper/buffer-helper":37,"../utils/logger":53}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  IDLE: 'IDLE',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_LEVEL: 'WAITING_LEVEL',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var StreamController = function (_EventHandler) {
  _inherits(StreamController, _EventHandler);

  function StreamController(hls) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this._state = State.STOPPED;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(StreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var lastCurrentTime = this.lastCurrentTime,
            hls = this.hls;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.level = -1;
        this.fragLoadError = 0;
        if (!this.startFragRequested) {
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.bitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.loadedmetadata = false;
        }
        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          startPosition = lastCurrentTime;
        }
        this.state = State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        this.forceStartLoad = true;
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
      this.forceStartLoad = false;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case State.ERROR:
          //don't do anything in error state to avoid breaking further ...
          break;
        case State.BUFFER_FLUSHING:
          // in buffer flushing state, reset fragLoadError counter
          this.fragLoadError = 0;
          break;
        case State.IDLE:
          this._doTickIdle();
          break;
        case State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.ERROR:
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if video not attached AND
      // start fragment already requested OR start frag prefetch disable
      // exit loop
      // => if start level loaded and media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
      if (this.levelLastLoaded !== undefined && !media && (this.startFragRequested || !config.startFragPrefetch)) {
        return;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = void 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else {
        pos = this.nextLoadPosition;
      }
      // determine next load level
      var level = hls.nextLoadLevel,
          levelInfo = this.levels[level];

      if (!levelInfo) {
        return;
      }

      var levelBitrate = levelInfo.bitrate,
          maxBufLen = void 0;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }
      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      this.level = hls.nextLoadLevel = level;

      var levelDetails = levelInfo.details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = State.WAITING_LEVEL;
        return;
      }

      // we just got done loading the final fragment, check if we need to finalize media stream
      var fragPrevious = this.fragPrevious;
      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {
        // fragPrevious is last fragment. retrieve level duration using last frag start offset + duration
        // real duration might be lower than initial duration if there are drifts between real frag duration and playlist signaling
        var duration = Math.min(media.duration, fragPrevious.start + fragPrevious.duration);
        // if everything (almost) til the end is buffered, let's signal eos
        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference (audio/video offsets...)
        // tolerate up to one frag duration to cope with these cases.
        // also cope with almost zero last frag duration (max last frag duration with 200ms) refer to https://github.com/video-dev/hls.js/pull/657
        if (duration - Math.max(bufferInfo.end, fragPrevious.start) <= Math.max(0.2, fragPrevious.duration)) {
          // Finalize the media stream
          var data = {};
          if (this.altAudio) {
            data.type = 'video';
          }
          this.hls.trigger(_events2.default.BUFFER_EOS, data);
          this.state = State.ENDED;
          return;
        }
      }

      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
      var fragPrevious = this.fragPrevious,
          level = this.level,
          fragments = levelDetails.fragments,
          fragLen = fragments.length;

      // empty playlist
      if (fragLen === 0) {
        return;
      }

      // find fragment index, contiguous with end of buffer position
      var start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      if (levelDetails.initSegment && !levelDetails.initSegment.data) {
        frag = levelDetails.initSegment;
      } else {
        // in case of live playlist we need to ensure that requested position is not located before playlist start
        if (levelDetails.live) {
          var initialLiveManifestSize = this.config.initialLiveManifestSize;
          if (fragLen < initialLiveManifestSize) {
            _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
            return;
          }

          frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
          // if it explicitely returns null don't load any fragment and exit function now
          if (frag === null) {
            return;
          }
        } else {
          // VoD playlist: if bufferEnd before start of playlist, load first fragment
          if (bufferEnd < start) {
            frag = fragments[0];
          }
        }
      }
      if (!frag) {
        frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
      }
      if (frag) {
        this._loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd);
      }
      return;
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
      var config = this.hls.config,
          media = this.media;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      // don't return null in case media not loaded yet (readystate === 0)
      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          var targetSN = fragPrevious.sn + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            frag = fragments[targetSN - levelDetails.startSN];
            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }
      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
      var config = this.hls.config;
      var frag = void 0;
      var foundFrag = void 0;
      var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
      var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
      var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
        // offset should be within fragment boundary - config.maxFragLookUpTolerance
        // this is to cope with situations like
        // bufferEnd = 9.991
        // frag[Ø] : [0,10]
        // frag[1] : [10,20]
        // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
        //              frag start               frag start+duration
        //                  |-----------------------------|
        //              <--->                         <--->
        //  ...--------><-----------------------------><---------....
        // previous frag         matching fragment         next frag
        //  return -1             return 0                 return 1
        //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
        // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
        var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
        if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
          return 1;
        } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
        else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
            return -1;
          }
        return 0;
      };

      if (bufferEnd < end) {
        if (bufferEnd > end - maxFragLookUpTolerance) {
          maxFragLookUpTolerance = 0;
        }
        // Prefer the next fragment if it's within tolerance
        if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
          foundFrag = fragNext;
        } else {
          foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
        }
      } else {
        // reach end of playlist
        foundFrag = fragments[fragLen - 1];
      }
      if (foundFrag) {
        frag = foundFrag;
        var curSNIdx = frag.sn - levelDetails.startSN;
        var sameLevel = fragPrevious && frag.level === fragPrevious.level;
        var prevFrag = fragments[curSNIdx - 1];
        var nextFrag = fragments[curSNIdx + 1];
        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (sameLevel && frag.sn === fragPrevious.sn) {
          if (frag.sn < levelDetails.endSN) {
            var deltaPTS = fragPrevious.deltaPTS;
            // if there is a significant delta between audio and video, larger than max allowed hole,
            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
            // let's try to load previous fragment again to get last keyframe
            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
              frag = prevFrag;
              _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
              fragPrevious.loadCounter--;
            } else {
              frag = nextFrag;
              _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
            }
          } else {
            frag = null;
          }
        } else if (frag.dropped && !sameLevel) {
          // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
          if (nextFrag && nextFrag.backtracked) {
            _logger.logger.warn('Already backtracked from fragment ' + (curSNIdx + 1) + ', will not backtrack to fragment ' + curSNIdx + '. Loading fragment ' + (curSNIdx + 1));
            frag = nextFrag;
          } else {
            // If a fragment has dropped frames and it's in a different level/sequence, load the previous fragment to try and find the keyframe
            // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
            _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
            frag.dropped = 0;
            if (prevFrag) {
              if (prevFrag.loadCounter) {
                prevFrag.loadCounter--;
              }
              frag = prevFrag;
            } else {
              frag = null;
            }
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadFragmentOrKey',
    value: function _loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd) {
      var hls = this.hls,
          config = hls.config;

      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
      if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
        this.state = State.KEY_LOADING;
        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
      } else {
        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
        // ensure that we are not reloading the same fragments in loop ...
        if (this.fragLoadIdx !== undefined) {
          this.fragLoadIdx++;
        } else {
          this.fragLoadIdx = 0;
        }
        if (frag.loadCounter) {
          frag.loadCounter++;
          var maxThreshold = config.fragLoadingLoopThreshold;
          // if this frag has already been loaded 3 times, and if it has been reloaded recently
          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
            return;
          }
        } else {
          frag.loadCounter = 1;
        }
        frag.loadIdx = this.fragLoadIdx;
        this.fragCurrent = frag;
        this.startFragRequested = true;
        if (!isNaN(frag.sn)) {
          this.nextLoadPosition = frag.start + frag.duration;
        }
        frag.autoLevel = hls.autoLevelEnabled;
        frag.bitrateTest = this.bitrateTest;
        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        // lazy demuxer init, as this could take some time ... do it during frag loading
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(hls, 'main');
        }
        this.state = State.FRAG_LOADING;
        return;
      }
    }
  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position) {
      return _binarySearch2.default.search(this._bufferedFrags, function (frag) {
        if (position < frag.startPTS) {
          return -1;
        } else if (position > frag.endPTS) {
          return 1;
        }
        return 0;
      });
    }
  }, {
    key: 'followingBufferedFrag',
    value: function followingBufferedFrag(frag) {
      if (frag) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferedFrag(frag.endPTS + 0.5);
      }
      return null;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var fragPlayingCurrent,
          currentTime,
          video = this.media;
      if (video && video.readyState && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > video.playbackRate * this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }
        if (_bufferHelper2.default.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getBufferedFrag(currentTime);
        } else if (_bufferHelper2.default.isBuffered(video, currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          var fragPlaying = fragPlayingCurrent;
          if (fragPlaying !== this.fragPlaying) {
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
            var fragPlayingLevel = fragPlaying.level;
            if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
              this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
            }
            this.fragPlaying = fragPlaying;
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }
      this.fragCurrent = null;
      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // flush everything
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }

    /*
       on immediate level switch end, after new fragment has been buffered :
        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
        - resume the playback if needed
    */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (_bufferHelper2.default.isBuffered(media, media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }
  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      /* try to switch ASAP without breaking video playback :
         in order to ensure smooth but quick level switching,
        we need to find the next flushable buffer range
        we should take into account new segment fetch time
      */
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            fragPlayingCurrent = void 0,
            nextBufferedFrag = void 0;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
        fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        //logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (nextBufferedFrag) {
          // we can flush buffer range following this one without stalling playback
          nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
          if (nextBufferedFrag) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            // flush position is the start position of this new buffer
            this.flushMainBuffer(nextBufferedFrag.startPTS, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
  }, {
    key: 'flushMainBuffer',
    value: function flushMainBuffer(startOffset, endOffset) {
      this.state = State.BUFFER_FLUSHING;
      var flushScope = { startOffset: startOffset, endOffset: endOffset };
      // if alternate audio tracks are used, only flush video, otherwise flush everything
      if (this.altAudio) {
        flushScope.type = 'video';
      }
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var levels = this.levels;
      if (levels) {
        // reset fragment load counter
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
              fragment.backtracked = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined,
          config = this.config;
      if (!isNaN(currentTime)) {
        _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
      }
      var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
      var bufferInfo = _bufferHelper2.default.bufferInfo(mediaBuffer, currentTime, this.config.maxBufferHole);
      if (this.state === State.FRAG_LOADING) {
        var fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = config.maxFragLookUpTolerance,
              fragStartOffset = fragCurrent.start - tolerance,
              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (this.state === State.ENDED) {
        // if seeking to unbuffered area, clean up fragPrevious
        if (bufferInfo.len === 0) {
          this.fragPrevious = 0;
        }
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined;
      if (!isNaN(currentTime)) {
        _logger.logger.log('media seeked to ' + currentTime.toFixed(3));
      }
      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      _logger.logger.log('media ended');
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this._bufferedFrags = [];
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }
          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }
      this.levels = data.levels;
      this.startLevelLoaded = false;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad || this.forceStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details,
          newLevelId = data.level,
          curLevel = this.levels[newLevelId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);
      this.levelLastLoaded = newLevelId;

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
          this.lastCurrentTime = this.startPosition;
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === State.WAITING_LEVEL) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var stats = data.stats,
            currentLevel = this.levels[fragCurrent.level],
            details = currentLevel.details;
        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);
        // reset frag bitrate test in any case after frag loaded event
        this.bitrateTest = false;
        this.stats = stats;
        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
        // then this means that we should be able to load a fragment at a higher quality level
        if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = State.IDLE;
          this.startFragRequested = false;
          stats.tparsed = stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else if (fragLoaded.sn === 'initSegment') {
          this.state = State.IDLE;
          stats.tparsed = stats.tbuffered = performance.now();
          details.initSegment.data = data.payload;
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else {
          this.state = State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          var duration = details.totalduration,
              level = fragCurrent.level,
              sn = fragCurrent.sn,
              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
          if (this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec === undefined) {
              audioCodec = this.lastAudioCodec;
            }
            if (audioCodec) {
              if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                audioCodec = 'mp4a.40.2';
              } else {
                audioCodec = 'mp4a.40.5';
              }
            }
          }
          this.pendingBuffering = true;
          this.appended = false;
          _logger.logger.log('Parsing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
          var demuxer = this.demuxer;
          if (!demuxer) {
            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');
          }
          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
          var media = this.media;
          var mediaSeeking = media && media.seeking;
          var accurateTimeOffset = !mediaSeeking && (details.PTSKnown || !details.live);
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, duration, accurateTimeOffset, undefined);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            trackName,
            track;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.altAudio) {
          delete tracks.audio;
        }
        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
            // Exclude mpeg audio
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to ' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.appended = true;
            // arm pending Buffering flag before appending a segment
            this.pendingBuffering = true;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
      this.state === State.PARSING) {
        var level = this.levels[this.level],
            frag = fragCurrent;
        if (isNaN(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
        if (data.type === 'video') {
          frag.dropped = data.dropped;
          if (frag.dropped) {
            if (!frag.backtracked) {
              // Return back to the IDLE state without appending to buffer
              // Causes findFragments to backtrack a segment and find the keyframe
              // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
              frag.backtracked = true;
              this.nextLoadPosition = data.startPTS;
              this.state = State.IDLE;
              this.tick();
              return;
            } else {
              _logger.logger.warn('Already backtracked on this fragment, appending with the gap');
            }
          } else {
            // Only reset the backtracked flag if we've loaded the frag without any dropped frames
            frag.backtracked = false;
          }
        }

        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });

        // has remuxer dropped video frames located before first keyframe ?
        [data.data1, data.data2].forEach(function (buffer) {
          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
          // in that case it is useless to append following segments
          if (buffer && buffer.length && _this2.state === State.PARSING) {
            _this2.appended = true;
            // arm pending Buffering flag before appending a segment
            _this2.pendingBuffering = true;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url,
          trackId = data.id;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      // don't do anything if we switch to alt audio: audio stream controller is handling it.
      // we will just have to change buffer scheduling on audioTrackSwitched
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = State.IDLE;
        }
        var hls = this.hls;
        // switching to main audio, flush all audio and trigger track switched
        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
        this.altAudio = false;
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var trackId = data.id,
          altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        var videoBuffer = this.videoBuffer;
        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        var state = this.state;
        if (state === State.PARSING || state === State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent;
        if (frag) {
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
          var bufferedFrags = this._bufferedFrags.filter(function (frag) {
            return _bufferHelper2.default.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
          });
          // push new range
          bufferedFrags.push(frag);
          // sort frags, as we use BinarySearch for lookup in getBufferedFrag ...
          this._bufferedFrags = bufferedFrags.sort(function (a, b) {
            return a.startPTS - b.startPTS;
          });
          this.fragPrevious = frag;
          var stats = this.stats;
          stats.tbuffered = performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag || this.fragCurrent;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }
      var media = this.media,

      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
      mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            var config = this.config;
            // keep retrying / don't raise fatal network error if current position is buffered or if in automode with current level not 0
            if (loadError <= config.fragLoadingMaxRetry || mediaBuffered || frag.autoLevel && frag.level) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              // if loadedmetadata is not set, it means that we are emergency switch down on first frag
              // in that case, reset startFragRequested flag
              if (!this.loadedmetadata) {
                this.startFragRequested = false;
                this.nextLoadPosition = this.startPosition;
              }
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
          if (!data.fatal) {
            // if buffer is not empty
            if (mediaBuffered) {
              // try to reduce max buffer length : rationale is that we could get
              // frag loop loading error because of buffer eviction
              this._reduceMaxBufferLength(frag.duration);
              this.state = State.IDLE;
            } else {
              // buffer empty. report as fatal if in manual mode or if lowest level.
              // level controller takes care of emergency switch down logic
              if (!frag.autoLevel || frag.level === 0) {
                // switch error to fatal
                data.fatal = true;
                this.state = State.ERROR;
              }
            }
          }
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (this.state !== State.ERROR) {
            if (data.fatal) {
              // if fatal error, stop processing
              this.state = State.ERROR;
              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
            } else {
              // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
              if (!data.levelRetry && this.state === State.WAITING_LEVEL) {
                this.state = State.IDLE;
              }
            }
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'main' && (this.state === State.PARSING || this.state === State.PARSED)) {
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              this._reduceMaxBufferLength(this.config.maxBufferLength);
              this.state = State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
              this.fragCurrent = null;
              // flush everything
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_reduceMaxBufferLength',
    value: function _reduceMaxBufferLength(minLength) {
      var config = this.config;
      if (config.maxMaxBufferLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength /= 2;
        _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
    }
  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;
      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
      if (media && media.readyState) {
        var currentTime = media.currentTime,
            mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media,
            buffered = mediaBuffer.buffered;
        // adjust currentTime to start position on loaded metadata
        if (!this.loadedmetadata && buffered.length) {
          this.loadedmetadata = true;
          // only adjust currentTime if different from startPosition or if startPosition not buffered
          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
          var startPosition = media.seeking ? currentTime : this.startPosition,
              startPositionBuffered = _bufferHelper2.default.isBuffered(mediaBuffer, startPosition);
          // if currentTime not matching with expected startPosition or startPosition not buffered
          if (currentTime !== startPosition || !startPositionBuffered) {
            _logger.logger.log('target start position:' + startPosition);
            // if startPosition not buffered, let's seek to buffered.start(0)
            if (!startPositionBuffered) {
              startPosition = buffered.start(0);
              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
            }
            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
            media.currentTime = startPosition;
          }
        } else if (this.immediateSwitch) {
          this.immediateLevelSwitchEnd();
        } else {
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),
              expectedPlaying = !(media.paused || // not playing when media is paused
          media.ended || // not playing when media is ended
          media.buffered.length === 0),
              // not playing if nothing buffered
          jumpThreshold = 0.5,
              // tolerance needed as some browsers stalls playback before reaching buffered range end
          playheadMoving = currentTime !== this.lastCurrentTime,
              config = this.config;

          if (playheadMoving) {
            // played moving, but was previously stalled => now not stuck anymore
            if (this.stallReported) {
              _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(performance.now() - this.stalled) + 'ms');
              this.stallReported = false;
            }
            this.stalled = undefined;
            this.nudgeRetry = 0;
          } else {
            // playhead not moving
            if (expectedPlaying) {
              // playhead not moving BUT media expected to play
              var tnow = performance.now();
              var hls = this.hls;
              if (!this.stalled) {
                // stall just detected, store current time
                this.stalled = tnow;
                this.stallReported = false;
              } else {
                // playback already stalled, check stalling duration
                // if stalling for more than a given threshold, let's try to recover
                var stalledDuration = tnow - this.stalled;
                var bufferLen = bufferInfo.len;
                var nudgeRetry = this.nudgeRetry || 0;
                // have we reached stall deadline ?
                if (bufferLen <= jumpThreshold && stalledDuration > config.lowBufferWatchdogPeriod * 1000) {
                  // report stalled error once
                  if (!this.stallReported) {
                    this.stallReported = true;
                    _logger.logger.warn('playback stalling in low buffer @' + currentTime);
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                  }
                  // if buffer len is below threshold, try to jump to start of next buffer range if close
                  // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
                  var nextBufferStart = bufferInfo.nextStart,
                      delta = nextBufferStart - currentTime;
                  if (nextBufferStart && delta < config.maxSeekHole && delta > 0) {
                    this.nudgeRetry = ++nudgeRetry;
                    var nudgeOffset = nudgeRetry * config.nudgeOffset;
                    // next buffer is close ! adjust currentTime to nextBufferStart
                    // this will ensure effective video decoding
                    _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + nudgeOffset);
                    media.currentTime = nextBufferStart + nudgeOffset;
                    // reset stalled so to rearm watchdog timer
                    this.stalled = undefined;
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: nextBufferStart + nudgeOffset - currentTime });
                  }
                } else if (bufferLen > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
                  // report stalled error once
                  if (!this.stallReported) {
                    this.stallReported = true;
                    _logger.logger.warn('playback stalling in high buffer @' + currentTime);
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                  }
                  // reset stalled so to rearm watchdog timer
                  this.stalled = undefined;
                  this.nudgeRetry = ++nudgeRetry;
                  if (nudgeRetry < config.nudgeMaxRetry) {
                    var _currentTime = media.currentTime;
                    var targetTime = _currentTime + nudgeRetry * config.nudgeOffset;
                    _logger.logger.log('adjust currentTime from ' + _currentTime + ' to ' + targetTime);
                    // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
                    media.currentTime = targetTime;
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL, fatal: false });
                  } else {
                    _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: true });
                  }
                }
              }
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.startPosition;
      }
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, filter flushed fragments from bufferedFrags
        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
      */
      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
      this._bufferedFrags = this._bufferedFrags.filter(function (frag) {
        return _bufferHelper2.default.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
      });

      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('main stream:' + previousState + '->' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      var media = this.media;
      if (media) {
        var frag = this.getBufferedFrag(media.currentTime);
        if (frag) {
          return frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferedFrag',
    get: function get() {
      var media = this.media;
      if (media) {
        // first get end range of current fragment
        return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var frag = this.nextBufferedFrag;
      if (frag) {
        return frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_eventHandler2.default);

exports.default = StreamController;

},{"../demux/demuxer":25,"../errors":33,"../event-handler":34,"../events":35,"../helper/buffer-helper":37,"../helper/level-helper":38,"../utils/binary-search":48,"../utils/logger":53,"../utils/timeRanges":54}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Subtitle Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var SubtitleStreamController = function (_EventHandler) {
  _inherits(SubtitleStreamController, _EventHandler);

  function SubtitleStreamController(hls) {
    _classCallCheck(this, SubtitleStreamController);

    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.ERROR, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED));

    _this.config = hls.config;
    _this.vttFragSNsProcessed = {};
    _this.vttFragQueues = undefined;
    _this.currentlyProcessing = null;
    _this.currentTrackId = -1;
    return _this;
  }

  _createClass(SubtitleStreamController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Remove all queued items and create a new, empty queue for each track.

  }, {
    key: 'clearVttFragQueues',
    value: function clearVttFragQueues() {
      var _this2 = this;

      this.vttFragQueues = {};
      this.tracks.forEach(function (track) {
        _this2.vttFragQueues[track.id] = [];
      });
    }

    // If no frag is being processed and queue isn't empty, initiate processing of next frag in line.

  }, {
    key: 'nextFrag',
    value: function nextFrag() {
      if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
        var frag = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
      }
    }

    // When fragment has finished processing, add sn to list of completed if successful.

  }, {
    key: 'onSubtitleFragProcessed',
    value: function onSubtitleFragProcessed(data) {
      if (data.success) {
        this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);
      }
      this.currentlyProcessing = null;
      this.nextFrag();
    }

    // If something goes wrong, procede to next frag, if we were processing one.

  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to subtitle fragment
      if (frag && frag.type !== 'subtitle') {
        return;
      }
      if (this.currentlyProcessing) {
        this.currentlyProcessing = null;
        this.nextFrag();
      }
    }

    // Got all new subtitle tracks.

  }, {
    key: 'onSubtitleTracksUpdated',
    value: function onSubtitleTracksUpdated(data) {
      var _this3 = this;

      _logger.logger.log('subtitle tracks updated');
      this.tracks = data.subtitleTracks;
      this.clearVttFragQueues();
      this.vttFragSNsProcessed = {};
      this.tracks.forEach(function (track) {
        _this3.vttFragSNsProcessed[track.id] = [];
      });
    }
  }, {
    key: 'onSubtitleTrackSwitch',
    value: function onSubtitleTrackSwitch(data) {
      this.currentTrackId = data.id;
      this.clearVttFragQueues();
    }

    // Got a new set of subtitle fragments.

  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var processedFragSNs = this.vttFragSNsProcessed[data.id],
          fragQueue = this.vttFragQueues[data.id],
          currentFragSN = !!this.currentlyProcessing ? this.currentlyProcessing.sn : -1;

      var alreadyProcessed = function alreadyProcessed(frag) {
        return processedFragSNs.indexOf(frag.sn) > -1;
      };

      var alreadyInQueue = function alreadyInQueue(frag) {
        return fragQueue.some(function (fragInQueue) {
          return fragInQueue.sn === frag.sn;
        });
      };

      // Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.
      data.details.fragments.forEach(function (frag) {
        if (!(alreadyProcessed(frag) || frag.sn === currentFragSN || alreadyInQueue(frag))) {
          // Frags don't know their subtitle track ID, so let's just add that...
          frag.trackId = data.id;
          fragQueue.push(frag);
        }
      });

      this.nextFrag();
    }
  }]);

  return SubtitleStreamController;
}(_eventHandler2.default);

exports.default = SubtitleStreamController;

},{"../event-handler":34,"../events":35,"../utils/logger":53}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function filterSubtitleTracks(textTrackList) {
  var tracks = [];
  for (var i = 0; i < textTrackList.length; i++) {
    if (textTrackList[i].kind === 'subtitles') {
      tracks.push(textTrackList[i]);
    }
  }
  return tracks;
}

var SubtitleTrackController = function (_EventHandler) {
  _inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    _classCallCheck(this, SubtitleTrackController);

    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = undefined;
    return _this;
  }

  _createClass(SubtitleTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Listen for subtitle track change, then extract the current track ID.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this2 = this;

      this.media = data.media;
      if (!this.media) {
        return;
      }

      this.media.textTracks.addEventListener('change', function () {
        // Media is undefined when switching streams via loadSource()
        if (!_this2.media) {
          return;
        }

        var trackId = -1;
        var tracks = filterSubtitleTracks(_this2.media.textTracks);
        for (var id = 0; id < tracks.length; id++) {
          if (tracks[id].mode === 'showing') {
            trackId = id;
          }
        }
        // Setting current subtitleTrack will invoke code.
        _this2.subtitleTrack = trackId;
      });
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      // TODO: Remove event listeners.
      this.media = undefined;
    }

    // Reset subtitle tracks on manifest loading

  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.tracks = [];
      this.trackId = -1;
    }

    // Fired whenever a new manifest is loaded.

  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      var tracks = data.subtitles || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.trackId = -1;
      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

      // loop through available subtitle tracks and autoselect default if needed
      // TODO: improve selection logic to handle forced, etc
      tracks.forEach(function (track) {
        if (track.default) {
          _this3.subtitleTrack = track.id;
          defaultFound = true;
        }
      });
    }

    // Trigger subtitle track playlist reload.

  }, {
    key: 'onTick',
    value: function onTick() {
      var trackId = this.trackId;
      var subtitleTrack = this.tracks[trackId];
      if (!subtitleTrack) {
        return;
      }

      var details = subtitleTrack.details;
      // check if we need to load playlist for this subtitle Track
      if (details === undefined || details.live === true) {
        // track not retrieved yet, or live playlist we need to (re)load it
        _logger.logger.log('(re)loading playlist for subtitle track ' + trackId);
        this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });
      }
    }
  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var _this4 = this;

      if (data.id < this.tracks.length) {
        _logger.logger.log('subtitle track ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(function () {
            _this4.onTick();
          }, 1000 * data.details.targetduration, this);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: 'setSubtitleTrackInternal',
    value: function setSubtitleTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to subtitle track ' + newId);
        var subtitleTrack = this.tracks[newId];
        this.hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });
        // check if we need to load playlist for this subtitle Track
        var details = subtitleTrack.details;
        if (details === undefined || details.live === true) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for subtitle track ' + newId);
          this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });
        }
      }
    }
  }, {
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        // || this.tracks[subtitleTrackId].details === undefined) {
        this.setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(_eventHandler2.default);

exports.default = SubtitleTrackController;

},{"../event-handler":34,"../events":35,"../utils/logger":53}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = require('../utils/cea-608-parser');

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

var _webvttParser = require('../utils/webvtt-parser');

var _webvttParser2 = _interopRequireDefault(_webvttParser);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

function reuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = undefined;
    _this.cueRanges = [];

    if (_this.config.enableCEA708Captions) {
      var self = _this;
      var sendAddTrackEvent = function sendAddTrackEvent(track, media) {
        var e = null;
        try {
          e = new window.Event('addtrack');
        } catch (err) {
          //for IE11
          e = document.createEvent('Event');
          e.initEvent('addtrack', false, false);
        }
        e.track = track;
        media.dispatchEvent(e);
      };

      var channel1 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack1) {
            //Enable reuse of existing text track.
            var existingTrack1 = self.getExistingTrack('1');
            if (!existingTrack1) {
              var textTrack1 = self.createTextTrack('captions', self.config.captionsTextTrack1Label, self.config.captionsTextTrack1LanguageCode);
              if (textTrack1) {
                textTrack1.textTrack1 = true;
                self.textTrack1 = textTrack1;
              }
            } else {
              self.textTrack1 = existingTrack1;
              clearCurrentCues(self.textTrack1);

              sendAddTrackEvent(self.textTrack1, self.media);
            }
          }
          self.addCues('textTrack1', startTime, endTime, screen);
        }
      };

      var channel2 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack2) {
            //Enable reuse of existing text track.
            var existingTrack2 = self.getExistingTrack('2');
            if (!existingTrack2) {
              var textTrack2 = self.createTextTrack('captions', self.config.captionsTextTrack2Label, self.config.captionsTextTrack1LanguageCode);
              if (textTrack2) {
                textTrack2.textTrack2 = true;
                self.textTrack2 = textTrack2;
              }
            } else {
              self.textTrack2 = existingTrack2;
              clearCurrentCues(self.textTrack2);

              sendAddTrackEvent(self.textTrack2, self.media);
            }
          }
          self.addCues('textTrack2', startTime, endTime, screen);
        }
      };

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'addCues',
    value: function addCues(channel, startTime, endTime, screen) {
      // skip cues which overlap more than 50% with previously parsed time ranges
      var ranges = this.cueRanges;
      var merged = false;
      for (var i = ranges.length; i--;) {
        var cueRange = ranges[i];
        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        ranges.push([startTime, endTime]);
      }
      this.Cues.newCue(this[channel], startTime, endTime, screen);
    }

    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var _this2 = this;

      if (typeof this.initPTS === 'undefined') {
        this.initPTS = data.initPTS;
      }

      // Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.
      // Parse any unparsed fragments upon receiving the initial PTS.
      if (this.unparsedVttFrags.length) {
        this.unparsedVttFrags.forEach(function (frag) {
          _this2.onFragLoaded(frag);
        });
        this.unparsedVttFrags = [];
      }
    }
  }, {
    key: 'getExistingTrack',
    value: function getExistingTrack(channelNumber) {
      var media = this.media;
      if (media) {
        for (var i = 0; i < media.textTracks.length; i++) {
          var textTrack = media.textTracks[i];
          var propName = 'textTrack' + channelNumber;
          if (textTrack[propName] === true) {
            return textTrack;
          }
        }
      }
      return null;
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      var media = this.media;
      if (media) {
        return media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      clearCurrentCues(this.textTrack1);
      clearCurrentCues(this.textTrack2);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastSn = -1; // Detect discontiguity in fragment parsing
      this.prevCC = -1;
      this.vttCCs = { ccOffset: 0, presentationOffset: 0 }; // Detect discontinuity in subtitle manifests

      // clear outdated subtitles
      var media = this.media;
      if (media) {
        var textTracks = media.textTracks;
        if (textTracks) {
          for (var i = 0; i < textTracks.length; i++) {
            clearCurrentCues(textTracks[i]);
          }
        }
      }
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      this.textTracks = [];
      this.unparsedVttFrags = this.unparsedVttFrags || [];
      this.initPTS = undefined;
      this.cueRanges = [];

      if (this.config.enableWebVTT) {
        this.tracks = data.subtitles || [];
        var inUseTracks = this.media ? this.media.textTracks : [];

        this.tracks.forEach(function (track, index) {
          var textTrack = void 0;
          if (index < inUseTracks.length) {
            var inUseTrack = inUseTracks[index];
            // Reuse tracks with the same label, but do not reuse 608/708 tracks
            if (reuseVttTextTrack(inUseTrack, track)) {
              textTrack = inUseTrack;
            }
          }
          if (!textTrack) {
            textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
          }
          textTrack.mode = track.default ? 'showing' : 'hidden';
          _this3.textTracks.push(textTrack);
        });
      }
    }
  }, {
    key: 'onLevelSwitching',
    value: function onLevelSwitching() {
      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag,
          payload = data.payload;
      if (frag.type === 'main') {
        var sn = frag.sn;
        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
        if (sn !== this.lastSn + 1) {
          var cea608Parser = this.cea608Parser;
          if (cea608Parser) {
            cea608Parser.reset();
          }
        }
        this.lastSn = sn;
      }
      // If fragment is subtitle type, parse as WebVTT.
      else if (frag.type === 'subtitle') {
          if (payload.byteLength) {
            // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
            if (typeof this.initPTS === 'undefined') {
              this.unparsedVttFrags.push(data);
              return;
            }
            var vttCCs = this.vttCCs;
            if (!vttCCs[frag.cc]) {
              vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
              this.prevCC = frag.cc;
            }
            var textTracks = this.textTracks,
                hls = this.hls;

            // Parse the WebVTT file contents.
            _webvttParser2.default.parse(payload, this.initPTS, vttCCs, frag.cc, function (cues) {
              var currentTrack = textTracks[frag.trackId];
              // Add cues and trigger event with success true.
              cues.forEach(function (cue) {
                // Sometimes there are cue overlaps on segmented vtts so the same
                // cue can appear more than once in different vtt files.
                // This avoid showing duplicated cues with same timecode and text.
                if (!currentTrack.cues.getCueById(cue.id)) {
                  currentTrack.addCue(cue);
                }
              });
              hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
            }, function (e) {
              // Something went wrong while parsing. Trigger event with success false.
              _logger.logger.log('Failed to parse VTT cue: ' + e);
              hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
            });
          } else {
            // In case there is no payload, finish unsuccessfully.
            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          }
        }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled && this.config.enableCEA708Captions) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) !== 0;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) // || ccType === 1
            {
              actualCCBytes.push(ccbyte1);
              actualCCBytes.push(ccbyte2);
            }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;

},{"../event-handler":34,"../events":35,"../utils/cea-608-parser":49,"../utils/logger":53,"../utils/webvtt-parser":57}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  _createClass(AESCrypto, [{
    key: 'decrypt',
    value: function decrypt(data, key) {
      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    }
  }]);

  return AESCrypto;
}();

exports.default = AESCrypto;

},{}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESDecryptor = function () {
  function AESDecryptor() {
    _classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  _createClass(AESDecryptor, [{
    key: 'uint8ArrayToUint32Array_',
    value: function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }
      return newArray;
    }
  }, {
    key: 'initTable',
    value: function initTable() {
      var sBox = this.sBox;
      var invSBox = this.invSBox;
      var subMix = this.subMix;
      var subMix0 = subMix[0];
      var subMix1 = subMix[1];
      var subMix2 = subMix[2];
      var subMix3 = subMix[3];
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
  }, {
    key: 'expandKey',
    value: function expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      var key = this.uint8ArrayToUint32Array_(keyBuffer);
      var sameKey = true;
      var offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      var keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      var ksRow = void 0;
      var invKsRow = void 0;

      var keySchedule = this.keySchedule = new Uint32Array(ksRows);
      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      var sbox = this.sBox;
      var rcon = this.rcon;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var prev = void 0;
      var t = void 0;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.

  }, {
    key: 'networkToHostOrderSwap',
    value: function networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(inputArrayBuffer, offset, aesIV) {
      var nRounds = this.keySize + 6;
      var invKeySchedule = this.invKeySchedule;
      var invSBOX = this.invSBox;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var initVector = this.uint8ArrayToUint32Array_(aesIV);
      var initVector0 = initVector[0];
      var initVector1 = initVector[1];
      var initVector2 = initVector[2];
      var initVector3 = initVector[3];

      var inputInt32 = new Int32Array(inputArrayBuffer);
      var outputInt32 = new Int32Array(inputInt32.length);

      var t0 = void 0,
          t1 = void 0,
          t2 = void 0,
          t3 = void 0;
      var s0 = void 0,
          s1 = void 0,
          s2 = void 0,
          s3 = void 0;
      var inputWords0 = void 0,
          inputWords1 = void 0,
          inputWords2 = void 0,
          inputWords3 = void 0;

      var ksRow, i;
      var swapWord = this.networkToHostOrderSwap;

      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);

        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];

        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;

          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3;

        // Write
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;

        offset = offset + 4;
      }

      return outputInt32.buffer;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;

      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;

      this.rcon = undefined;
    }
  }]);

  return AESDecryptor;
}();

exports.default = AESDecryptor;

},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aesCrypto = require('./aes-crypto');

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = require('./fast-aes-key');

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = require('./aes-decryptor');

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*globals self: false */

var Decrypter = function () {
  function Decrypter(observer, config) {
    _classCallCheck(this, Decrypter);

    this.observer = observer;
    this.config = config;
    this.logEnabled = true;
    try {
      var browserCrypto = crypto ? crypto : self.crypto;
      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    } catch (e) {}
    this.disableWebCrypto = !this.subtle;
  }

  _createClass(Decrypter, [{
    key: 'isSync',
    value: function isSync() {
      return this.disableWebCrypto && this.config.enableSoftwareAES;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      var _this = this;

      if (this.disableWebCrypto && this.config.enableSoftwareAES) {
        if (this.logEnabled) {
          _logger.logger.log('JS AES decrypt');
          this.logEnabled = false;
        }
        var decryptor = this.decryptor;
        if (!decryptor) {
          this.decryptor = decryptor = new _aesDecryptor2.default();
        }
        decryptor.expandKey(key);
        callback(decryptor.decrypt(data, 0, iv));
      } else {
        if (this.logEnabled) {
          _logger.logger.log('WebCrypto AES decrypt');
          this.logEnabled = false;
        }
        var subtle = this.subtle;
        if (this.key !== key) {
          this.key = key;
          this.fastAesKey = new _fastAesKey2.default(subtle, key);
        }

        this.fastAesKey.expandKey().then(function (aesKey) {
          // decrypt using web crypto
          var crypto = new _aesCrypto2.default(subtle, iv);
          crypto.decrypt(data, aesKey).catch(function (err) {
            _this.onWebCryptoError(err, data, key, iv, callback);
          }).then(function (result) {
            callback(result);
          });
        }).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        });
      }
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.config.enableSoftwareAES) {
        _logger.logger.log('WebCrypto Error, disable WebCrypto API');
        this.disableWebCrypto = true;
        this.logEnabled = true;
        this.decrypt(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var decryptor = this.decryptor;
      if (decryptor) {
        decryptor.destroy();
        this.decryptor = undefined;
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;

},{"../errors":33,"../utils/logger":53,"./aes-crypto":17,"./aes-decryptor":18,"./fast-aes-key":20}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    _classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  _createClass(FastAESKey, [{
    key: 'expandKey',
    value: function expandKey() {
      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    }
  }]);

  return FastAESKey;
}();

exports.default = FastAESKey;

},{}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _logger = require('../utils/logger');

var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, remuxer, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(AACDemuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var track,
          id3 = new _id2.default(data),
          pts = 90 * id3.timeStamp,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          length,
          aacSample;

      track = this._audioTrack;

      // Look for ADTS header
      for (offset = id3.length, length = data.length; offset < length - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0) {
          break;
        }
      }

      if (!track.samplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, track.manifestCodec);
        track.config = config.config;
        track.samplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.samplerate;
      while (offset + 5 < length) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= length) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < length - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      this.remuxer.remux(track, { samples: [] }, { samples: [{ pts: pts, dts: pts, data: id3.payload }], inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and ADTS sync word
      var id3 = new _id2.default(data),
          offset,
          length;
      var id3Tag = id3.getTagData(data, 0);
      if (id3Tag) {
        var timeStamp = id3.getTimeStamp(id3Tag);
      }
      if (id3.hasTimeStamp) {
        // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
        // Layer bits (position 14 and 15) in header should be always 0 for ADTS
        // More info https://wiki.multimedia.cx/index.php?title=ADTS
        for (offset = id3.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
          if (data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0) {
            //logger.log('ADTS sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;

},{"../demux/id3":27,"../utils/logger":53,"./adts":22}],22:[function(require,module,exports){
'use strict';

var _logger = require('../utils/logger');

var _errors = require('../errors');

/**
 *  ADTS parser helper
 */
var ADTS = {
  getAudioConfig: function getAudioConfig(observer, data, offset, audioCodec) {
    var adtsObjectType,
        // :int
    adtsSampleingIndex,
        // :int
    adtsExtensionSampleingIndex,
        // :int
    adtsChanelConfig,
        // :int
    config,
        userAgent = navigator.userAgent.toLowerCase(),
        manifestCodec = audioCodec,
        adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
    // byte 2
    adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
    adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
    if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
      observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
      return;
    }
    adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
    // byte 3
    adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
    _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
    if (/firefox/i.test(userAgent)) {
      if (adtsSampleingIndex >= 6) {
        adtsObjectType = 5;
        config = new Array(4);
        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
        // there is a factor 2 between frame sample rate and output sample rate
        // multiply frequency by 2 (see table below, equivalent to substract 3)
        adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
      } else {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      }
      // Android : always use AAC
    } else if (userAgent.indexOf('android') !== -1) {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    } else {
      /*  for other browsers (Chrome/Vivaldi/Opera ...)
          always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
      */
      adtsObjectType = 5;
      config = new Array(4);
      // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
      if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
        // there is a factor 2 between frame sample rate and output sample rate
        // multiply frequency by 2 (see table below, equivalent to substract 3)
        adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
      } else {
        // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
        // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
        if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
          adtsObjectType = 2;
          config = new Array(2);
        }
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      }
    }
    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
        ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
      Audio Profile / Audio Object Type
      0: Null
      1: AAC Main
      2: AAC LC (Low Complexity)
      3: AAC SSR (Scalable Sample Rate)
      4: AAC LTP (Long Term Prediction)
      5: SBR (Spectral Band Replication)
      6: AAC Scalable
     sampling freq
      0: 96000 Hz
      1: 88200 Hz
      2: 64000 Hz
      3: 48000 Hz
      4: 44100 Hz
      5: 32000 Hz
      6: 24000 Hz
      7: 22050 Hz
      8: 16000 Hz
      9: 12000 Hz
      10: 11025 Hz
      11: 8000 Hz
      12: 7350 Hz
      13: Reserved
      14: Reserved
      15: frequency is written explictly
      Channel Configurations
      These are the channel configurations:
      0: Defined in AOT Specifc Config
      1: 1 channel: front-center
      2: 2 channels: front-left, front-right
    */
    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
    config[0] = adtsObjectType << 3;
    // samplingFrequencyIndex
    config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
    config[1] |= (adtsSampleingIndex & 0x01) << 7;
    // channelConfiguration
    config[1] |= adtsChanelConfig << 3;
    if (adtsObjectType === 5) {
      // adtsExtensionSampleingIndex
      config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
      config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
      // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
      //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
      config[2] |= 2 << 2;
      config[3] = 0;
    }
    return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
  }
};

module.exports = ADTS;

},{"../errors":33,"../utils/logger":53}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('../errors');

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

var _aacdemuxer = require('../demux/aacdemuxer');

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _mp4demuxer = require('../demux/mp4demuxer');

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _tsdemuxer = require('../demux/tsdemuxer');

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp3demuxer = require('../demux/mp3demuxer');

var _mp3demuxer2 = _interopRequireDefault(_mp3demuxer);

var _mp4Remuxer = require('../remux/mp4-remuxer');

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = require('../remux/passthrough-remuxer');

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DemuxerInline = function () {
  function DemuxerInline(observer, typeSupported, config, vendor) {
    _classCallCheck(this, DemuxerInline);

    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        var decrypter = this.decrypter;
        if (decrypter == null) {
          decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);
        }
        var localthis = this;
        // performance.now() not available on WebWorker, at least on Safari Desktop
        var startTime;
        try {
          startTime = performance.now();
        } catch (error) {
          startTime = Date.now();
        }
        decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
          var endTime;
          try {
            endTime = performance.now();
          } catch (error) {
            endTime = Date.now();
          }
          localthis.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
          localthis.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        });
      } else {
        this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var demuxer = this.demuxer;
      if (!demuxer ||
      // in case of continuity change, we might switch from content type (AAC container to TS container for example)
      // so let's check that current demuxer is still valid
      discontinuity && !this.probe(data)) {
        var observer = this.observer;
        var typeSupported = this.typeSupported;
        var config = this.config;
        var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp3demuxer2.default, remux: _mp4Remuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }];

        // probe for content type
        for (var i in muxConfig) {
          var mux = muxConfig[i];
          var probe = mux.demux.probe;
          if (probe(data)) {
            var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
            demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
            this.probe = probe;
            break;
          }
        }
        if (!demuxer) {
          observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      var remuxer = this.remuxer;

      if (discontinuity || trackSwitch) {
        demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
        remuxer.resetInitSegment();
      }
      if (discontinuity) {
        demuxer.resetTimeStamp();
        remuxer.resetTimeStamp(defaultInitPTS);
      }
      if (typeof demuxer.setDecryptData === 'function') {
        demuxer.setDecryptData(decryptdata);
      }
      demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;

},{"../crypt/decrypter":19,"../demux/aacdemuxer":21,"../demux/mp3demuxer":28,"../demux/mp4demuxer":29,"../demux/tsdemuxer":32,"../errors":33,"../events":35,"../remux/mp4-remuxer":45,"../remux/passthrough-remuxer":46}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events4.default();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    //console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config, data.vendor);
        try {
          (0, _logger.enableLogs)(config.debug === true);
        } catch (err) {
          console.warn('demuxerWorker: unable to enable logs');
        }
        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var transferable = [];
    var message = { event: ev, data: data };
    if (data.data1) {
      message.data1 = data.data1.buffer;
      transferable.push(data.data1.buffer);
      delete data.data1;
    }
    if (data.data2) {
      message.data2 = data.data2.buffer;
      transferable.push(data.data2.buffer);
      delete data.data2;
    }
    self.postMessage(message, transferable);
  });
};

exports.default = DemuxerWorker;

},{"../demux/demuxer-inline":23,"../events":35,"../utils/logger":53,"events":1}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _demuxerWorker = require('../demux/demuxer-worker');

var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);

var _logger = require('../utils/logger');

var _errors = require('../errors');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Demuxer = function () {
  function Demuxer(hls, id) {
    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;
    // observer setup
    var observer = this.observer = new _events4.default();
    var config = hls.config;
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };

    var forwardMessage = function (ev, data) {
      data = data || {};
      data.frag = this.frag;
      data.id = this.id;
      hls.trigger(ev, data);
    }.bind(this);

    // forward events to main thread
    observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_DATA, forwardMessage);
    observer.on(_events2.default.FRAG_PARSED, forwardMessage);
    observer.on(_events2.default.ERROR, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
    var vendor = navigator.vendor;
    if (config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      var w = void 0;
      try {
        var work = require('webworkify');
        w = this.w = work(_demuxerWorker2.default);
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
      } catch (err) {
        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
        this.w = undefined;
      }
    } else {
      this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
    }
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var observer = this.observer;
      if (observer) {
        observer.removeAllListeners();
        this.observer = null;
      }
    }
  }, {
    key: 'push',
    value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
      var w = this.w;
      var timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;
      var decryptdata = frag.decryptdata;
      var lastFrag = this.frag;
      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      var trackSwitch = !(lastFrag && frag.level === lastFrag.level);
      var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
      var contiguous = !trackSwitch && nextSN;
      if (discontinuity) {
        _logger.logger.log(this.id + ':discontinuity detected');
      }
      if (trackSwitch) {
        _logger.logger.log(this.id + ':switch detected');
      }
      this.frag = frag;
      if (w) {
        // post fragment payload as transferable objects (no copy)
        w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, [data]);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        }
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      //console.log('onWorkerMessage:' + data.event);
      switch (data.event) {
        case 'init':
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(this.w.objectURL);
          break;
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events2.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          if (data.data2) {
            data.data.data2 = new Uint8Array(data.data2);
          }
        /* falls through */
        default:
          data.data = data.data || {};
          data.data.frag = this.frag;
          data.data.id = this.id;
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;

},{"../demux/demuxer-inline":23,"../demux/demuxer-worker":24,"../errors":33,"../events":35,"../utils/logger":53,"events":1,"webworkify":3}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var data = this.data,
          bytesAvailable = this.bytesAvailable,
          position = data.byteLength - bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }
      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return 1 === this.readBits(1);
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j,
          deltaScale;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          profileIdc,
          profileCompat,
          levelIdc,
          numRefFramesInPicOrderCntCycle,
          picWidthInMbsMinus1,
          picHeightInMapUnitsMinus1,
          frameMbsOnlyFlag,
          scalingListCount,
          i,
          readUByte = this.readUByte.bind(this),
          readBits = this.readBits.bind(this),
          readUEG = this.readUEG.bind(this),
          readBoolean = this.readBoolean.bind(this),
          skipBits = this.skipBits.bind(this),
          skipEG = this.skipEG.bind(this),
          skipUEG = this.skipUEG.bind(this),
          skipScalingList = this.skipScalingList.bind(this);

      readUByte();
      profileIdc = readUByte(); // profile_idc
      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
      skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = readUByte(); //level_idc u(8)
      skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1); // separate_colour_plane_flag
        }
        skipUEG(); // bit_depth_luma_minus8
        skipUEG(); // bit_depth_chroma_minus8
        skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG(); //log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        skipBits(1); // delta_pic_order_always_zero_flag
        skipEG(); // offset_for_non_ref_pic
        skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG(); // offset_for_ref_frame[ i ]
        }
      }
      skipUEG(); // max_num_ref_frames
      skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = readUEG();
      picHeightInMapUnitsMinus1 = readUEG();
      frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1); // mb_adaptive_frame_field_flag
      }
      skipBits(1); // direct_8x8_inference_flag
      if (readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      var pixelRatio = [1, 1];
      if (readBoolean()) {
        // vui_parameters_present_flag
        if (readBoolean()) {
          // aspect_ratio_info_present_flag
          var aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];break;
            case 2:
              pixelRatio = [12, 11];break;
            case 3:
              pixelRatio = [10, 11];break;
            case 4:
              pixelRatio = [16, 11];break;
            case 5:
              pixelRatio = [40, 33];break;
            case 6:
              pixelRatio = [24, 11];break;
            case 7:
              pixelRatio = [20, 11];break;
            case 8:
              pixelRatio = [32, 11];break;
            case 9:
              pixelRatio = [80, 33];break;
            case 10:
              pixelRatio = [18, 11];break;
            case 11:
              pixelRatio = [15, 11];break;
            case 12:
              pixelRatio = [64, 33];break;
            case 13:
              pixelRatio = [160, 99];break;
            case 14:
              pixelRatio = [4, 3];break;
            case 15:
              pixelRatio = [3, 2];break;
            case 16:
              pixelRatio = [2, 1];break;
            case 255:
              {
                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio: pixelRatio
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;

},{"../utils/logger":53}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//import Hex from '../utils/hex';

var ID3 = function () {
  function ID3(data) {
    _classCallCheck(this, ID3);

    this._hasTimeStamp = false;
    this._length = 0;
    var offset = 0,
        byte1,
        byte2,
        byte3,
        byte4,
        tagSize,
        endPos,
        header,
        len;
    do {
      header = this.readUTF(data, offset, 3);
      offset += 3;
      // first check for ID3 header
      if (header === 'ID3') {
        // skip 24 bits
        offset += 3;
        // retrieve tag(s) length
        byte1 = data[offset++] & 0x7f;
        byte2 = data[offset++] & 0x7f;
        byte3 = data[offset++] & 0x7f;
        byte4 = data[offset++] & 0x7f;
        tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;
        endPos = offset + tagSize;
        //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);

        // read ID3 tags
        this._parseID3Frames(data, offset, endPos);
        offset = endPos;
      } else if (header === '3DI') {
        // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer
        offset += 7;
        _logger.logger.log('3DI footer found, end: ' + offset);
      } else {
        offset -= 3;
        len = offset;
        if (len) {
          //logger.log(`ID3 len: ${len}`);
          if (!this.hasTimeStamp) {
            _logger.logger.warn('ID3 tag found, but no timestamp');
          }
          this._length = len;
          this._payload = data.subarray(0, len);
        }
        return;
      }
    } while (true);
  }

  _createClass(ID3, [{
    key: 'getTagData',
    value: function getTagData(data, offset) {
      if (ID3.isID3Header(data, offset)) {
        var tagLength = 10;

        //skip ID3
        //offset += 3;

        //skip version and flags
        //offset += 3;

        var size = this._readSize(data, offset + 6);
        //size  = ((data[offset++] & 0x7f) << 21);
        //size |= ((data[offset++] & 0x7f) << 14);
        //size |= ((data[offset++] & 0x7f) << 7);
        //size |=  (data[offset++] & 0x7f);

        //const frameData = data.subarray(offset, offset + size);

        //offset += size;
        tagLength += size;

        if (ID3.isID3Footer(data, offset)) {
          //offset += 10;
          tagLength += 10;
        }

        return data.subarray(offset, offset + tagLength);
      }

      return undefined;
    }
  }, {
    key: '_readSize',
    value: function _readSize(data, offset) {
      var size = 0;
      size = (data[offset] & 0x7f) << 21;
      size |= (data[offset + 1] & 0x7f) << 14;
      size |= (data[offset + 2] & 0x7f) << 7;
      size |= data[offset + 3] & 0x7f;
      return size;
    }
  }, {
    key: 'getTimeStamp',
    value: function getTimeStamp(tagData) {
      var offset = 0;
      if (ID3.isID3Header(tagData, offset)) {
        var size = this._readSize(tagData, offset + 6);
        //size of timestamp frame is 63 bytes (including frame header)
        if (size >= 63) {
          offset = 10;
          //frame header is 10 bytes
          while (offset + 10 < tagData.length) {
            var frame = this.getFrameInfo(tagData.subarray(offset));
            if (frame.type === 'PRIV' && frame.size === 53) {
              var timestamp = this.decodeTimeStampFrame(frame);
              return timestamp;
            } else {
              offset += frame.size;
            }
          }
        }
      }

      return undefined;
    }
  }, {
    key: 'getFrameInfo',
    value: function getFrameInfo(data) {
      /*
      Frame ID       $xx xx xx xx (four characters)
      Size           $xx xx xx xx
      Flags          $xx xx
      */
      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
      var size = this._readSize(data, 4);

      //skip frame id, size, and flags
      var offset = 10;

      return { type: type, size: size, data: data.subarray(offset, offset + size) };
    }
  }, {
    key: 'readFrameData',
    value: function readFrameData(data) {
      /*
      Frame ID       $xx xx xx xx (four characters)
      Size           $xx xx xx xx
      Flags          $xx xx
      */
      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
      var size = this._readSize(data, 4);

      //skip frame id, size, and flags
      var offset = 10;

      return this.decodeID3Frame({ type: type, size: size, data: data.subarray(offset, offset + size) });
    }
  }, {
    key: 'decodeFrame',
    value: function decodeFrame(frame) {
      if (frame.type === 'PRIV') {
        return this.decodePrivFrame(frame);
      } else if (frame.type[0] === 'T') {
        return this.decodeTextFrame(frame);
      } else if (frame.type[0] === 'W') {
        return this.decodeURLFrame(frame);
      }

      return undefined;
    }
  }, {
    key: 'decodeTimeStampFrame',
    value: function decodeTimeStampFrame(frame) {
      var privFrame = this.decodePrivFrame(frame);
      if (privFrame.data.byteLength === 8 && privFrame.info === 'com.apple.streaming.transportStreamTimestamp') {
        var data = new Uint8Array(privFrame.data);
        // timestamp is 33 bit expressed as a big-endian eight-octet number,
        // with the upper 31 bits set to zero.
        var pts33Bit = data[3] & 0x1;
        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
        timestamp /= 45;

        if (pts33Bit) {
          timestamp += 47721858.84; // 2^32 / 90
        }

        return Math.round(timestamp);
      }

      return undefined;
    }
  }, {
    key: 'decodePrivFrame',
    value: function decodePrivFrame(frame) {
      /*
      Format: <text string>\0<binary data>
      */
      if (frame.size < 2) {
        return undefined;
      }

      var owner = this.utf8ArrayToStr(frame.data);
      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));

      return { key: frame.type, info: owner, data: privateData.buffer };
    }
  }, {
    key: 'decodeTextFrame',
    value: function decodeTextFrame(frame) {
      if (frame.size < 2) {
        return undefined;
      }

      if (frame.data[0] !== 3) {
        //only support UTF-8
        return undefined;
      }

      if (frame.type === 'TXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{Value}
        */
        var index = 1;
        var description = this.utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = this.utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Value}
        */
        var text = this.utf8ArrayToStr(frame.data.subarray(1));
        return { key: frame.type, data: text };
      }
    }
  }, {
    key: 'decodeURLFrame',
    value: function decodeURLFrame(frame) {}
  }, {
    key: 'readUTF',
    value: function readUTF(data, start, len) {

      var result = '',
          offset = start,
          end = start + len;
      do {
        result += String.fromCharCode(data[offset++]);
      } while (offset < end);
      return result;
    }
  }, {
    key: '_parseID3Frames',
    value: function _parseID3Frames(data, offset, endPos) {
      var tagId, tagLen, tagStart, tagFlags, timestamp;
      while (offset + 8 <= endPos) {
        tagId = this.readUTF(data, offset, 4);
        offset += 4;

        tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];

        tagFlags = data[offset++] << 8 + data[offset++];

        tagStart = offset;
        //logger.log("ID3 tag id:" + tagId);
        switch (tagId) {
          case 'PRIV':
            //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));
            // owner should be "com.apple.streaming.transportStreamTimestamp"
            if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {
              offset += 44;
              // smelling even better ! we found the right descriptor
              // skip null character (string end) + 3 first bytes
              offset += 4;

              // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.
              var pts33Bit = data[offset++] & 0x1;
              this._hasTimeStamp = true;

              timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;

              if (pts33Bit) {
                timestamp += 47721858.84; // 2^32 / 90
              }
              timestamp = Math.round(timestamp);
              _logger.logger.trace('ID3 timestamp found: ' + timestamp);
              this._timeStamp = timestamp;
            }
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: 'utf8ArrayToStr',


    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
    /* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */
    value: function utf8ArrayToStr(array) {

      var char2 = void 0;
      var char3 = void 0;
      var out = '';
      var i = 0;
      var length = array.length;

      while (i < length) {
        var c = array[i++];
        switch (c >> 4) {
          case 0:
            return out;
          case 1:case 2:case 3:case 4:case 5:case 6:case 7:
            // 0xxxxxxx
            out += String.fromCharCode(c);
            break;
          case 12:case 13:
            // 110x xxxx   10xx xxxx
            char2 = array[i++];
            out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
            break;
          case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
            break;
        }
      }

      return out;
    }
  }, {
    key: 'hasTimeStamp',
    get: function get() {
      return this._hasTimeStamp;
    }
  }, {
    key: 'timeStamp',
    get: function get() {
      return this._timeStamp;
    }
  }, {
    key: 'length',
    get: function get() {
      return this._length;
    }
  }, {
    key: 'payload',
    get: function get() {
      return this._payload;
    }
  }], [{
    key: 'isID3Header',
    value: function isID3Header(data, offset) {
      /*
      * An ID3v2 tag can be detected with the following pattern:
      *  $49 44 33 yy yy xx zz zz zz zz
      * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
      */
      if (offset + 10 <= data.length) {
        //look for 'ID3' identifier
        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
          //check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            //check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }
  }, {
    key: 'isID3Footer',
    value: function isID3Footer(data, offset) {
      /*
      * The footer is a copy of the header, but with a different identifier
      */
      if (offset + 10 <= data.length) {
        //look for '3DI' identifier
        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
          //check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            //check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }
  }]);

  return ID3;
}();

exports.default = ID3;

},{"../utils/logger":53}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP3 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

var _mpegaudio = require('./mpegaudio');

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP3Demuxer = function () {
  function MP3Demuxer(observer, remuxer, config) {
    _classCallCheck(this, MP3Demuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(MP3Demuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var id3 = new _id2.default(data);
      var pts = 90 * id3.timeStamp;
      var afterID3 = id3.length;
      var offset, length;

      // Look for MPEG header
      for (offset = afterID3, length = data.length; offset < length - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00) {
          break;
        }
      }

      _mpegaudio2.default.parse(this._audioTrack, data, id3.length, pts);

      this.remuxer.remux(this._audioTrack, { samples: [] }, { samples: [{ pts: pts, dts: pts, data: id3.payload }], inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and MPEG sync word
      var id3 = new _id2.default(data),
          offset,
          length;
      if (id3.hasTimeStamp) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        for (offset = id3.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
          if (data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00) {
            //logger.log('MPEG sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return MP3Demuxer;
}();

exports.default = MP3Demuxer;

},{"../demux/id3":27,"./mpegaudio":30}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
//import {logger} from '../utils/logger';


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP4Demuxer = function () {
  function MP4Demuxer(observer, remuxer) {
    _classCallCheck(this, MP4Demuxer);

    this.observer = observer;
    this.remuxer = remuxer;
  }

  _createClass(MP4Demuxer, [{
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      //jshint unused:false
      var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);
      var tracks = {};
      if (initData.audio) {
        tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: initSegment };
      }
      if (initData.video) {
        tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: initSegment };
      }
      this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
    }
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var initData = this.initData;
      var startDTS = MP4Demuxer.startDTS(initData, data);
      this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      if (data.length >= 8) {
        var dataType = MP4Demuxer.bin2str(data.subarray(4, 8));
        return ['moof', 'ftyp', 'styp'].indexOf(dataType) >= 0;
      }
      return false;
    }
  }, {
    key: 'bin2str',
    value: function bin2str(buffer) {
      return String.fromCharCode.apply(null, buffer);
    }

    // Find the data for a box specified by its path

  }, {
    key: 'findBox',
    value: function findBox(data, path) {
      var results = [],
          i,
          size,
          type,
          end,
          subresults;

      if (!path.length) {
        // short-circuit the search for empty paths
        return null;
      }

      for (i = 0; i < data.byteLength;) {
        size = data[i] << 24;
        size |= data[i + 1] << 16;
        size |= data[i + 2] << 8;
        size |= data[i + 3];

        type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));

        end = size > 1 ? i + size : data.byteLength;

        if (type === path[0]) {
          if (path.length === 1) {
            // this is the end of the path and we've found the box we were
            // looking for
            results.push(data.subarray(i + 8, end));
          } else {
            // recursively search for the next box along the path
            subresults = MP4Demuxer.findBox(data.subarray(i + 8, end), path.slice(1));
            if (subresults.length) {
              results = results.concat(subresults);
            }
          }
        }
        i = end;
      }

      // we've finished searching all of data
      return results;
    }

    /**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */

  }, {
    key: 'parseInitSegment',
    value: function parseInitSegment(initSegment) {
      var result = [];
      var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);

      traks.forEach(function (trak) {
        var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
        if (tkhd) {
          var version = tkhd[0];
          var index = version === 0 ? 12 : 20;
          var trackId = tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3];

          trackId = trackId < 0 ? 4294967296 + trackId : trackId;

          var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
          if (mdhd) {
            version = mdhd[0];
            index = version === 0 ? 12 : 20;
            var timescale = mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3];

            var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
            if (hdlr) {
              var hdlrType = MP4Demuxer.bin2str(hdlr.subarray(8, 12));
              var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
              if (type) {
                result[trackId] = { timescale: timescale, type: type };
                result[type] = { timescale: timescale, id: trackId };
              }
            }
          }
        }
      });
      return result;
    }

    /**
     * Determine the base media decode start time, in seconds, for an MP4
     * fragment. If multiple fragments are specified, the earliest time is
     * returned.
     *
     * The base media decode time can be parsed from track fragment
     * metadata:
     * ```
     * moof > traf > tfdt.baseMediaDecodeTime
     * ```
     * It requires the timescale value from the mdhd to interpret.
     *
     * @param timescale {object} a hash of track ids to timescale values.
     * @return {number} the earliest base media decode start time for the
     * fragment, in seconds
     */

  }, {
    key: 'startDTS',
    value: function startDTS(initData, fragment) {
      var trafs, baseTimes, result;

      // we need info from two childrend of each track fragment box
      trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);

      // determine the start times for each track
      baseTimes = [].concat.apply([], trafs.map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          var id, scale, baseTime;

          // get the track id from the tfhd
          id = tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7];
          // assume a 90kHz clock if no timescale was specified
          scale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version, result;

            version = tfdt[0];
            result = tfdt[4] << 24 | tfdt[5] << 16 | tfdt[6] << 8 | tfdt[7];
            if (version === 1) {
              result *= Math.pow(2, 32);
              result += tfdt[8] << 24 | tfdt[9] << 16 | tfdt[10] << 8 | tfdt[11];
            }
            return result;
          })[0];
          baseTime = baseTime || Infinity;

          // convert base time to seconds
          return baseTime / scale;
        });
      }));

      // return the minimum
      result = Math.min.apply(null, baseTimes);
      return isFinite(result) ? result : 0;
    }
  }]);

  return MP4Demuxer;
}();

exports.default = MP4Demuxer;

},{"../events":35}],30:[function(require,module,exports){
'use strict';

var _logger = require('../utils/logger');

var MpegAudio = {

    onFrame: function onFrame(track, data, bitRate, sampleRate, channelCount, frameIndex, pts) {
        var frameDuration = 1152 * 90000 / sampleRate;
        var stamp = pts + frameIndex * frameDuration;

        track.config = [];
        track.channelCount = channelCount;
        track.samplerate = sampleRate;
        track.samples.push({ unit: data, pts: stamp, dts: stamp });
        track.len += data.length;
    },

    onNoise: function onNoise(data) {
        _logger.logger.warn('mpeg audio has noise: ' + data.length + ' bytes');
    },

    parseFrames: function parseFrames(track, data, start, end, frameIndex, pts) {
        var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
        var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];

        if (start + 2 > end) {
            return -1; // we need at least 2 bytes to detect sync pattern
        }
        if (data[start] === 0xFF || (data[start + 1] & 0xE0) === 0xE0) {
            // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
            if (start + 24 > end) {
                return -1;
            }
            var headerB = data[start + 1] >> 3 & 3;
            var headerC = data[start + 1] >> 1 & 3;
            var headerE = data[start + 2] >> 4 & 15;
            var headerF = data[start + 2] >> 2 & 3;
            var headerG = !!(data[start + 2] & 2);
            if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
                var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
                var bitRate = BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
                var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
                var sampleRate = SamplingRateMap[columnInSampleRates * 3 + headerF];
                var padding = headerG ? 1 : 0;
                var channelCount = data[start + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
                var frameLength = headerC === 3 ? (headerB === 3 ? 12 : 6) * bitRate / sampleRate + padding << 2 : (headerB === 3 ? 144 : 72) * bitRate / sampleRate + padding | 0;
                if (start + frameLength > end) {
                    return -1;
                }

                this.onFrame(track, data.subarray(start, start + frameLength), bitRate, sampleRate, channelCount, frameIndex, pts);

                return frameLength;
            }
        }
        // noise or ID3, trying to skip
        var offset = start + 2;
        while (offset < end) {
            if (data[offset - 1] === 0xFF && (data[offset] & 0xE0) === 0xE0) {
                // sync pattern is found
                this.onNoise(data.subarray(start, offset - 1));

                return offset - start - 1;
            }
            offset++;
        }
        return -1;
    },

    parse: function parse(track, data, offset, pts) {
        var length = data.length;
        var frameIndex = 0;
        var parsed;

        while (offset < length && (parsed = this.parseFrames(track, data, offset, length, frameIndex++, pts)) > 0) {
            offset += parsed;
        }
    }
}; /**
    *  MPEG parser helper
    */


module.exports = MpegAudio;

},{"../utils/logger":53}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SampleAesDecrypter = function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    _classCallCheck(this, SampleAesDecrypter);

    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new _decrypter2.default(observer, config);
  }

  _createClass(SampleAesDecrypter, [{
    key: 'decryptBuffer',
    value: function decryptBuffer(encryptedData, callback) {
      this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
    }

    // AAC - encrypt all full 16 bytes blocks starting from offset 16

  }, {
    key: 'decryptAacSample',
    value: function decryptAacSample(samples, sampleIndex, callback, sync) {
      var curUnit = samples[sampleIndex].unit;
      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);

      var localthis = this;
      this.decryptBuffer(encryptedBuffer, function (decryptedData) {
        decryptedData = new Uint8Array(decryptedData);
        curUnit.set(decryptedData, 16);

        if (!sync) {
          localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAacSamples',
    value: function decryptAacSamples(samples, sampleIndex, callback) {
      for (;; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }

        var sync = this.decrypter.isSync();

        this.decryptAacSample(samples, sampleIndex, callback, sync);

        if (!sync) {
          return;
        }
      }
    }

    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32

  }, {
    key: 'getAvcEncryptedData',
    value: function getAvcEncryptedData(decodedData) {
      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      var encryptedData = new Int8Array(encryptedDataLen);
      var outputPos = 0;
      for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return encryptedData;
    }
  }, {
    key: 'getAvcDecryptedUnit',
    value: function getAvcDecryptedUnit(decodedData, decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      var inputPos = 0;
      for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return decodedData;
    }
  }, {
    key: 'decryptAvcSample',
    value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
      var decodedData = this.discardEPB(curUnit.data);
      var encryptedData = this.getAvcEncryptedData(decodedData);
      var localthis = this;

      this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
        curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

        if (!sync) {
          localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAvcSamples',
    value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      for (;; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        var curUnits = samples[sampleIndex].units;
        for (;; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }

          var curUnit = curUnits[unitIndex];
          if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }

          var sync = this.decrypter.isSync();

          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

          if (!sync) {
            return;
          }
        }
      }
    }
  }]);

  return SampleAesDecrypter;
}();

exports.default = SampleAesDecrypter;

},{"../crypt/decrypter":19}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _mpegaudio = require('./mpegaudio');

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _expGolomb = require('./exp-golomb');

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _sampleAes = require('./sample-aes');

var _sampleAes2 = _interopRequireDefault(_sampleAes);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TSDemuxer = function () {
  function TSDemuxer(observer, remuxer, config, typeSupported) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.remuxer = remuxer;
    this.sampleAes = null;
  }

  _createClass(TSDemuxer, [{
    key: 'setDecryptData',
    value: function setDecryptData(decryptdata) {
      if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {
        this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);
      } else {
        this.sampleAes = null;
      }
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0, dropped: 0 };
      this._audioTrack = { container: 'video/mp2t', type: 'audio', id: -1, inputTimeScale: 90000, duration: duration, sequenceNumber: 0, samples: [], len: 0, isAAC: true };
      this._id3Track = { type: 'id3', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0 };
      this._txtTrack = { type: 'text', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0 };
      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcSample = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = duration;
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'append',
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var start,
          len = data.length,
          stt,
          pid,
          atf,
          offset,
          pes,
          unknownPIDs = false;
      this.contiguous = contiguous;
      var pmtParsed = this.pmtParsed,
          avcTrack = this._avcTrack,
          audioTrack = this._audioTrack,
          id3Track = this._id3Track,
          avcId = avcTrack.id,
          audioId = audioTrack.id,
          id3Id = id3Track.id,
          pmtId = this._pmtId,
          avcData = avcTrack.pesData,
          audioData = audioTrack.pesData,
          id3Data = id3Track.pesData,
          parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseMPEGPES = this._parseMPEGPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      // don't parse last TS packet if incomplete
      len -= len % 188;
      // loop through TS packets
      for (start = 0; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData))) {
                  parseAVCPES(pes, false);
                }
                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case audioId:
              if (stt) {
                if (audioData && (pes = parsePES(audioData))) {
                  if (audioTrack.isAAC) {
                    parseAACPES(pes);
                  } else {
                    parseMPEGPES(pes);
                  }
                }
                audioData = { data: [], size: 0 };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + 188));
                audioData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data))) {
                  parseID3PES(pes);
                }
                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }
              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);

              // only update track id if track PID found while parsing PMT
              // this is to avoid resetting the PID to -1 in case
              // track PID transiently disappears from the stream
              // this could happen in case of transient missing audio samples for example
              avcId = parsedPIDs.avc;
              if (avcId > 0) {
                avcTrack.id = avcId;
              }
              audioId = parsedPIDs.audio;
              if (audioId > 0) {
                audioTrack.id = audioId;
                audioTrack.isAAC = parsedPIDs.isAAC;
              }
              id3Id = parsedPIDs.id3;
              if (id3Id > 0) {
                id3Track.id = id3Id;
              }
              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = -188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // try to parse last PES packets
      if (avcData && (pes = parsePES(avcData))) {
        parseAVCPES(pes, true);
        avcTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        avcTrack.pesData = avcData;
      }

      if (audioData && (pes = parsePES(audioData))) {
        if (audioTrack.isAAC) {
          parseAACPES(pes);
        } else {
          parseMPEGPES(pes);
        }
        audioTrack.pesData = null;
      } else {
        if (audioData && audioData.size) {
          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
        }
        // either audioData null or PES truncated, keep it for next frag parsing
        audioTrack.pesData = audioData;
      }

      if (id3Data && (pes = parsePES(id3Data))) {
        parseID3PES(pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }

      if (this.sampleAes == null) {
        this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      } else {
        this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemux',
    value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (audioTrack.samples && audioTrack.isAAC) {
        var localthis = this;
        this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
          localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemuxAvc',
    value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (videoTrack.samples) {
        var localthis = this;
        this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
          localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      //logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {
      var sectionLength,
          tableEnd,
          programInfoLength,
          pid,
          result = { audio: -1, avc: -1, id3: -1, isAAC: true };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          case 0xcf:
            // SAMPLE-AES AAC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            //logger.log('AAC PID:'  + pid);
            if (result.audio === -1) {
              result.audio = pid;
            }
            break;

          // Packetized metadata (ID3)
          case 0x15:
            //logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }
            break;

          case 0xdb:
            // SAMPLE-AES AVC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            //logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }
            break;

          // ISO/IEC 11172-3 (MPEG-1 audio)
          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
          case 0x03:
          case 0x04:
            //logger.log('MPEG PID:'  + pid);
            if (!mpegSupported) {
              _logger.logger.log('MPEG audio found, not supported in this browser for now');
            } else if (result.audio === -1) {
              result.audio = pid;
              result.isAAC = false;
            }
            break;

          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;

          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag,
          pesFlags,
          pesPrefix,
          pesLen,
          pesHdrLen,
          pesData,
          pesPts,
          pesDts,
          payloadStartOffset,
          data = stream.data;
      // safety check
      if (!stream || stream.size === 0) {
        return null;
      }

      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      //retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
        // minus 6 : PES header size
        if (pesLen && pesLen > stream.size - 6) {
          return null;
        }
        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
            if (pesPts - pesDts > 60 * 90000) {
              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
              pesPts = pesDts;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        //reassemble PES packet
        pesData = new Uint8Array(stream.size);
        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
          frag = data[j];
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          // payload size : remove PES header + PES extension
          pesLen -= pesHdrLen + 3;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: 'pushAccesUnit',
    value: function pushAccesUnit(avcSample, avcTrack) {
      if (avcSample.units.length && avcSample.frame) {
        var samples = avcTrack.samples;
        var nbSamples = samples.length;
        // only push AVC sample if starting with a keyframe is not mandatory OR
        //    if keyframe already found in this fragment OR
        //       keyframe found in last fragment (track.sps) AND
        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
          avcSample.id = nbSamples;
          samples.push(avcSample);
        } else {
          // dropped samples, track it
          avcTrack.dropped++;
        }
      }
      if (avcSample.debug.length) {
        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes, last) {
      var _this = this;

      //logger.log('parse new PES');
      var track = this._avcTrack,
          units = this._parseAVCNALu(pes.data),
          debug = false,
          expGolombDecoder,
          avcSample = this.avcSample,
          push,
          i;
      //free pes.data to save up some memory
      pes.data = null;

      units.forEach(function (unit) {
        switch (unit.type) {
          //NDR
          case 1:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'NDR ';
            }
            avcSample.frame = true;
            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
            var data = unit.data;
            if (data.length > 4) {
              var sliceType = new _expGolomb2.default(data).readSliceType();
              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
              //if (sliceType === 2 || sliceType === 7) {
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                avcSample.key = true;
              }
            }
            break;
          //IDR
          case 5:
            push = true;
            // handle PES not starting with AUD
            if (!avcSample) {
              avcSample = _this.avcSample = _this._createAVCSample(true, pes.pts, pes.dts, '');
            }
            if (debug) {
              avcSample.debug += 'IDR ';
            }
            avcSample.key = true;
            avcSample.frame = true;
            break;
          //SEI
          case 6:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }
            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          //SPS
          case 7:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SPS ';
            }
            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.pixelRatio = config.pixelRatio;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }
                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          //PPS
          case 8:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'PPS ';
            }
            if (!track.pps) {
              track.pps = [unit.data];
            }
            break;
          // AUD
          case 9:
            push = false;
            if (avcSample) {
              _this.pushAccesUnit(avcSample, track);
            }
            avcSample = _this.avcSample = _this._createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
            break;
          // Filler Data
          case 12:
            push = false;
            break;
          default:
            push = false;
            if (avcSample) {
              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
            }
            break;
        }
        if (avcSample && push) {
          var _units = avcSample.units;
          _units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && avcSample) {
        this.pushAccesUnit(avcSample, track);
        this.avcSample = null;
      }
    }
  }, {
    key: '_createAVCSample',
    value: function _createAVCSample(key, pts, dts, debug) {
      return { key: key, pts: pts, dts: dts, units: [], debug: debug };
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_getLastNalUnit',
    value: function _getLastNalUnit() {
      var avcSample = this.avcSample,
          lastUnit = void 0;
      // try to fallback to previous sample if current one is empty
      if (!avcSample || avcSample.units.length === 0) {
        var track = this._avcTrack,
            samples = track.samples;
        avcSample = samples[samples.length - 1];
      }
      if (avcSample) {
        var units = avcSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value,
          overflow,
          track = this._avcTrack,
          state = track.naluState || 0,
          lastState = state;
      var units = [],
          unit,
          unitType,
          lastUnitStart = -1,
          lastUnitType;
      //logger.log('PES:' + Hex.hexDump(array));

      if (state === -1) {
        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
        lastUnitStart = 0;
        // NALu type is value read from offset 0
        lastUnitType = array[0] & 0x1f;
        state = 0;
        i = 1;
      }

      while (i < len) {
        value = array[i++];
        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        // here we have state either equal to 2 or 3
        if (!value) {
          state = 3;
        } else if (value === 1) {
          if (lastUnitStart >= 0) {
            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
            //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
            units.push(unit);
          } else {
            // lastUnitStart is undefined => this is the first start code found in this PES packet
            // first check if start code delimiter is overlapping between 2 PES packets,
            // ie it started in last packet (lastState not zero)
            // and ended at the beginning of this PES packet (i <= 4 - lastState)
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                // start delimiter overlapping between PES packets
                // strip start delimiter bytes from the end of last NAL unit
                // check if lastUnit had a state different from zero
                if (lastUnit.state) {
                  // strip last bytes
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
              overflow = i - state - 1;
              if (overflow > 0) {
                //logger.log('first NALU found with overflow:' + overflow);
                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                tmp.set(lastUnit.data, 0);
                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                lastUnit.data = tmp;
              }
            }
          }
          // check if we can read unit type
          if (i < len) {
            unitType = array[i] & 0x1f;
            //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            // not enough byte to read unit type. let's read it on next PES parsing
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        var _lastUnit = this._getLastNalUnit();
        if (_lastUnit) {
          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
          _tmp.set(_lastUnit.data, 0);
          _tmp.set(array, _lastUnit.data.byteLength);
          _lastUnit.data = _tmp;
        }
      }
      track.naluState = state;
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength,
          newData;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._audioTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason, fatal;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        _logger.logger.warn('parsing error:' + reason);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }
      if (!track.samplerate) {
        var audioCodec = this.audioCodec;
        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
        track.config = config.config;
        track.samplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.manifestCodec = config.manifestCodec;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.samplerate;

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        //logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }
      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseMPEGPES',
    value: function _parseMPEGPES(pes) {
      _mpegaudio2.default.parse(this._audioTrack, pes.data, 0, pes.pts);
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {
        return true;
      } else {
        return false;
      }
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;

},{"../errors":33,"../events":35,"../utils/logger":53,"./adts":22,"./exp-golomb":26,"./mpegaudio":30,"./sample-aes":31}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

var ErrorDetails = exports.ErrorDetails = {
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment loop loading error - data: { frag : fragment object}
  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException',
  // Malformed WebVTT contents
  WEBVTT_EXCEPTION: 'webVTTException'
};

},{}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('./utils/logger');

var _errors = require('./errors');

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.unregisterListeners();
    }
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (event === 'hlsEventGeneric') {
            throw new Error('Forbidden event name: ' + event);
          }
          this.hls.on(event, this.onEvent);
        }.bind(this));
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }.bind(this));
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }
        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;

},{"./errors":33,"./events":35,"./utils/logger":53}],35:[function(require,module,exports){
'use strict';

module.exports = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
  LEVEL_SWITCH: 'hlsLevelSwitch',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switch occurs - data: { id : audio track id } // deprecated in favor AUDIO_TRACK_SWITCHING
  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  //triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

},{}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: 'getSilentFrame',
    value: function getSilentFrame(codec, channelCount) {
      switch (codec) {
        case 'mp4a.40.2':
          if (channelCount === 1) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
          } else if (channelCount === 2) {
            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
          } else if (channelCount === 3) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
          } else if (channelCount === 4) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
          } else if (channelCount === 5) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
          } else if (channelCount === 6) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
          }
          break;
        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
        default:
          if (channelCount === 1) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 2) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 3) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          }
          break;
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;

},{}],37:[function(require,module,exports){
"use strict";

/**
 * Buffer Helper utils, providing methods dealing buffer length retrieval
*/

var BufferHelper = {
  isBuffered: function isBuffered(media, position) {
    if (media) {
      var buffered = media.buffered;
      for (var i = 0; i < buffered.length; i++) {
        if (position >= buffered.start(i) && position <= buffered.end(i)) {
          return true;
        }
      }
    }
    return false;
  },

  bufferInfo: function bufferInfo(media, pos, maxHoleDuration) {
    if (media) {
      var vbuffered = media.buffered,
          buffered = [],
          i;
      for (i = 0; i < vbuffered.length; i++) {
        buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
      }
      return this.bufferedInfo(buffered, pos, maxHoleDuration);
    } else {
      return { len: 0, start: pos, end: pos, nextStart: undefined };
    }
  },

  bufferedInfo: function bufferedInfo(buffered, pos, maxHoleDuration) {
    var buffered2 = [],

    // bufferStart and bufferEnd are buffer boundaries around current video position
    bufferLen,
        bufferStart,
        bufferEnd,
        bufferStartNext,
        i;
    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
    buffered.sort(function (a, b) {
      var diff = a.start - b.start;
      if (diff) {
        return diff;
      } else {
        return b.end - a.end;
      }
    });
    // there might be some small holes between buffer time range
    // consider that holes smaller than maxHoleDuration are irrelevant and build another
    // buffer time range representations that discards those holes
    for (i = 0; i < buffered.length; i++) {
      var buf2len = buffered2.length;
      if (buf2len) {
        var buf2end = buffered2[buf2len - 1].end;
        // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
        if (buffered[i].start - buf2end < maxHoleDuration) {
          // merge overlapping time ranges
          // update lastRange.end only if smaller than item.end
          // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
          // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
          if (buffered[i].end > buf2end) {
            buffered2[buf2len - 1].end = buffered[i].end;
          }
        } else {
          // big hole
          buffered2.push(buffered[i]);
        }
      } else {
        // first value
        buffered2.push(buffered[i]);
      }
    }
    for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
      var start = buffered2[i].start,
          end = buffered2[i].end;
      //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
      if (pos + maxHoleDuration >= start && pos < end) {
        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
        bufferStart = start;
        bufferEnd = end;
        bufferLen = bufferEnd - pos;
      } else if (pos + maxHoleDuration < start) {
        bufferStartNext = start;
        break;
      }
    }
    return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
  }
};

module.exports = BufferHelper;

},{}],38:[function(require,module,exports){
'use strict';

var _logger = require('../utils/logger');

var LevelHelper = {

  mergeDetails: function mergeDetails(oldDetails, newDetails) {
    var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
        end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
        delta = newDetails.startSN - oldDetails.startSN,
        oldfragments = oldDetails.fragments,
        newfragments = newDetails.fragments,
        ccOffset = 0,
        PTSFrag;

    // check if old/new playlists have fragments in common
    if (end < start) {
      newDetails.PTSKnown = false;
      return;
    }
    // loop through overlapping SN and update startPTS , cc, and duration if any found
    for (var i = start; i <= end; i++) {
      var oldFrag = oldfragments[delta + i],
          newFrag = newfragments[i];
      if (newFrag && oldFrag) {
        ccOffset = oldFrag.cc - newFrag.cc;
        if (!isNaN(oldFrag.startPTS)) {
          newFrag.start = newFrag.startPTS = oldFrag.startPTS;
          newFrag.endPTS = oldFrag.endPTS;
          newFrag.duration = oldFrag.duration;
          PTSFrag = newFrag;
        }
      }
    }

    if (ccOffset) {
      _logger.logger.log('discontinuity sliding from playlist, take drift into account');
      for (i = 0; i < newfragments.length; i++) {
        newfragments[i].cc += ccOffset;
      }
    }

    // if at least one fragment contains PTS info, recompute PTS information for all fragments
    if (PTSFrag) {
      LevelHelper.updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
    } else {
      // ensure that delta is within oldfragments range
      // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
      // in that case we also need to adjust start offset of all fragments
      if (delta >= 0 && delta < oldfragments.length) {
        // adjust start by sliding offset
        var sliding = oldfragments[delta].start;
        for (i = 0; i < newfragments.length; i++) {
          newfragments[i].start += sliding;
        }
      }
    }
    // if we are here, it means we have fragments overlapping between
    // old and new level. reliable PTS info is thus relying on old level
    newDetails.PTSKnown = oldDetails.PTSKnown;
    return;
  },

  updateFragPTSDTS: function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
    // update frag PTS/DTS
    if (!isNaN(frag.startPTS)) {
      // delta PTS between audio and video
      var deltaPTS = Math.abs(frag.startPTS - startPTS);
      if (isNaN(frag.deltaPTS)) {
        frag.deltaPTS = deltaPTS;
      } else {
        frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
      }
      startPTS = Math.min(startPTS, frag.startPTS);
      endPTS = Math.max(endPTS, frag.endPTS);
      startDTS = Math.min(startDTS, frag.startDTS);
      endDTS = Math.max(endDTS, frag.endDTS);
    }

    var drift = startPTS - frag.start;
    frag.start = frag.startPTS = startPTS;
    frag.endPTS = endPTS;
    frag.startDTS = startDTS;
    frag.endDTS = endDTS;
    frag.duration = endPTS - startPTS;

    var sn = frag.sn;
    // exit if sn out of range
    if (!details || sn < details.startSN || sn > details.endSN) {
      return 0;
    }
    var fragIdx, fragments, i;
    fragIdx = sn - details.startSN;
    fragments = details.fragments;
    frag = fragments[fragIdx];
    // adjust fragment PTS/duration from seqnum-1 to frag 0
    for (i = fragIdx; i > 0; i--) {
      LevelHelper.updatePTS(fragments, i, i - 1);
    }

    // adjust fragment PTS/duration from seqnum to last frag
    for (i = fragIdx; i < fragments.length - 1; i++) {
      LevelHelper.updatePTS(fragments, i, i + 1);
    }
    details.PTSKnown = true;
    //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

    return drift;
  },

  updatePTS: function updatePTS(fragments, fromIdx, toIdx) {
    var fragFrom = fragments[fromIdx],
        fragTo = fragments[toIdx],
        fragToPTS = fragTo.startPTS;
    // if we know startPTS[toIdx]
    if (!isNaN(fragToPTS)) {
      // update fragment duration.
      // it helps to fix drifts between playlist reported duration and fragment real duration
      if (toIdx > fromIdx) {
        fragFrom.duration = fragToPTS - fragFrom.start;
        if (fragFrom.duration < 0) {
          _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
        }
      } else {
        fragTo.duration = fragFrom.start - fragToPTS;
        if (fragTo.duration < 0) {
          _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
        }
      }
    } else {
      // we dont know startPTS[toIdx]
      if (toIdx > fromIdx) {
        fragTo.start = fragFrom.start + fragFrom.duration;
      } else {
        fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
      }
    }
  }
}; /**
    * Level Helper class, providing methods dealing with playlist sliding and drift
   */

module.exports = LevelHelper;

},{"../utils/logger":53}],39:[function(require,module,exports){
/**
 * HLS interface
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = require('url-toolkit');

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('./errors');

var _playlistLoader = require('./loader/playlist-loader');

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = require('./loader/fragment-loader');

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _keyLoader = require('./loader/key-loader');

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _streamController = require('./controller/stream-controller');

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = require('./controller/level-controller');

var _levelController2 = _interopRequireDefault(_levelController);

var _id3TrackController = require('./controller/id3-track-controller');

var _id3TrackController2 = _interopRequireDefault(_id3TrackController);

var _logger = require('./utils/logger');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

var _config = require('./config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Hls = function () {
  _createClass(Hls, null, [{
    key: 'isSupported',
    value: function isSupported() {
      window.MediaSource = window.MediaSource || window.WebKitMediaSource;
      window.SourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;

      var isTypeSupported = window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
      var hasSupportedSourceBuffer = window.SourceBuffer && window.SourceBuffer.prototype && typeof window.SourceBuffer.prototype.appendBuffer === 'function' && typeof window.SourceBuffer.prototype.remove === 'function';
      var isSafari = navigator.vendor && navigator.vendor.indexOf('Apple') > -1;

      // safari does not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
      return isTypeSupported && (hasSupportedSourceBuffer || isSafari);
    }
  }, {
    key: 'version',
    get: function get() {
      // replaced with browserify-versionify transform
      return '__VERSION__';
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }
  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }
  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }
  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        return _config.hlsDefaultConfig;
      }
      return Hls.defaultConfig;
    },
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
  }]);

  function Hls() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Hls);

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) {
        continue;
      }
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    this.config = config;
    this._autoLevelCapping = -1;
    // observer setup
    var observer = this.observer = new _events4.default();
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };
    this.on = observer.on.bind(observer);
    this.off = observer.off.bind(observer);
    this.trigger = observer.trigger.bind(observer);

    // core controllers and network loaders
    var abrController = this.abrController = new config.abrController(this);
    var bufferController = new config.bufferController(this);
    var capLevelController = new config.capLevelController(this);
    var fpsController = new config.fpsController(this);
    var playListLoader = new _playlistLoader2.default(this);
    var fragmentLoader = new _fragmentLoader2.default(this);
    var keyLoader = new _keyLoader2.default(this);
    var id3TrackController = new _id3TrackController2.default(this);

    // network controllers
    var levelController = this.levelController = new _levelController2.default(this);
    var streamController = this.streamController = new _streamController2.default(this);
    var networkControllers = [levelController, streamController];

    // optional audio stream controller
    var Controller = config.audioStreamController;
    if (Controller) {
      networkControllers.push(new Controller(this));
    }
    this.networkControllers = networkControllers;

    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController];

    // optional audio track and subtitle controller
    Controller = config.audioTrackController;
    if (Controller) {
      var audioTrackController = new Controller(this);
      this.audioTrackController = audioTrackController;
      coreComponents.push(audioTrackController);
    }

    Controller = config.subtitleTrackController;
    if (Controller) {
      var subtitleTrackController = new Controller(this);
      this.subtitleTrackController = subtitleTrackController;
      coreComponents.push(subtitleTrackController);
    }

    // optional subtitle controller
    [config.subtitleStreamController, config.timelineController].forEach(function (Controller) {
      if (Controller) {
        coreComponents.push(new Controller(_this));
      }
    });
    this.coreComponents = coreComponents;
  }

  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.coreComponents.concat(this.networkControllers).forEach(function (component) {
        component.destroy();
      });
      this.url = null;
      this.observer.removeAllListeners();
      this._autoLevelCapping = -1;
    }
  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }
  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }
  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      url = _urlToolkit2.default.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      _logger.logger.log('startLoad(' + startPosition + ')');
      this.networkControllers.forEach(function (controller) {
        controller.startLoad(startPosition);
      });
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.networkControllers.forEach(function (controller) {
        controller.stopLoad();
      });
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }
  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /** Return all quality levels **/

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /** Return current playback quality level **/

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /* set quality level immediately (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /** Return next playback quality level (quality level of next fragment) **/

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /* set quality level for next fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /** Return the quality level of current/last loaded fragment **/

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /** Return the quality level of next loaded fragment **/

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /** set quality level of next loaded fragment **/
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /** Return first level (index of first level referenced in manifest)
    **/

  }, {
    key: 'firstLevel',
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }

    /** set first level (index of first level referenced in manifest)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /** Return start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /** set  start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      var hls = this;
      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, hls.minAutoLevel);
      }
      hls.levelController.startLevel = newLevel;
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this._autoLevelCapping = newLevel;
    }

    /* check if we are in automatic level selection mode */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /* return manual level */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /* return min level selectable in auto mode according to config.minAutoBitrate */

  }, {
    key: 'minAutoLevel',
    get: function get() {
      var hls = this,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate,
          len = levels ? levels.length : 0;
      for (var i = 0; i < len; i++) {
        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
        if (levelNextBitrate > minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }

    /* return max level selectable in auto mode according to autoLevelCapping */

  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var hls = this;
      var levels = hls.levels;
      var autoLevelCapping = hls.autoLevelCapping;
      var maxAutoLevel = void 0;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }
      return maxAutoLevel;
    }

    // return next auto level

  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this;
      // ensure next auto level is between  min and max auto level
      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
    }

    // this setter is used to force next auto level
    // this is useful to force a switch down in auto mode : in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
    // forced value is valid for one fragment. upon succesful frag loading at forced level, this value will be resetted to -1 by ABR controller
    ,
    set: function set(nextLevel) {
      var hls = this;
      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'audioTracks',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      var audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: 'subtitleTracks',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }

    /** select an subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }
  }]);

  return Hls;
}();

exports.default = Hls;

},{"./config":4,"./controller/id3-track-controller":11,"./controller/level-controller":12,"./controller/stream-controller":13,"./errors":33,"./events":35,"./loader/fragment-loader":41,"./loader/key-loader":42,"./loader/playlist-loader":43,"./utils/logger":53,"events":1,"url-toolkit":2}],40:[function(require,module,exports){
'use strict';

// This is mostly for support of the es6 module export
// syntax with the babel compiler, it looks like it doesnt support
// function exports like we are used to in node/commonjs
module.exports = require('./hls.js').default;

},{"./hls.js":39}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      var loaders = this.loaders;
      for (var loaderName in loaders) {
        var loader = loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          config = this.hls.config;

      frag.loaded = 0;
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type:' + type);
        loader.abort();
      }
      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;
      if (!isNaN(start) && !isNaN(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }
      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;

},{"../errors":33,"../event-handler":34,"../events":35,"../utils/logger":53}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous key loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;

},{"../errors":33,"../event-handler":34,"../events":35,"../utils/logger":53}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Playlist Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _urlToolkit = require('url-toolkit');

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _attrList = require('../utils/attr-list');

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
var LEVEL_PLAYLIST_REGEX_FAST = /#EXTINF:(\d*(?:\.\d+)?)(?:,(.*))?|(?!#)(\S.+)|#EXT-X-BYTERANGE: *(.+)|#EXT-X-PROGRAM-DATE-TIME:(.+)|#.*/g;
var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var LevelKey = function () {
  function LevelKey() {
    _classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) {
        this._uri = _urlToolkit2.default.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
      }
      return this._uri;
    }
  }]);

  return LevelKey;
}();

var Fragment = function () {
  function Fragment() {
    _classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
    this.tagList = [];
  }

  _createClass(Fragment, [{
    key: 'createInitializationVector',


    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = new LevelKey();
        decryptdata.method = levelkey.method;
        decryptdata.baseuri = levelkey.baseuri;
        decryptdata.reluri = levelkey.reluri;
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'cloneObj',
    value: function cloneObj(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }, {
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) {
        this._url = _urlToolkit2.default.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
      }
      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'programDateTime',
    get: function get() {
      if (!this._programDateTime && this.rawProgramDateTime) {
        this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));
      }
      return this._programDateTime;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange) {
        var byteRange = this._byteRange = [];
        if (this.rawByteRange) {
          var params = this.rawByteRange.split('@', 2);
          if (params.length === 1) {
            var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
            byteRange[0] = lastByteRangeEndOffset ? lastByteRangeEndOffset : 0;
          } else {
            byteRange[0] = parseInt(params[1]);
          }
          byteRange[1] = parseInt(params[0]) + byteRange[0];
        }
      }
      return this._byteRange;
    }
  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) {
        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
      }
      return this._decryptdata;
    }
  }]);

  return Fragment;
}();

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: 'manifest' });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: 'level', level: data.level, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: 'audioTrack', id: data.id });
    }
  }, {
    key: 'onSubtitleTrackLoading',
    value: function onSubtitleTrackLoading(data) {
      this.load(data.url, { type: 'subtitleTrack', id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var loader = this.loaders[context.type];
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          _logger.logger.trace('playlist request ongoing');
          return;
        } else {
          _logger.logger.warn('abort previous loader for type:' + context.type);
          loader.abort();
        }
      }
      var config = this.hls.config,
          retry = void 0,
          timeout = void 0,
          retryDelay = void 0,
          maxRetryDelay = void 0;
      if (context.type === 'manifest') {
        retry = config.manifestLoadingMaxRetry;
        timeout = config.manifestLoadingTimeOut;
        retryDelay = config.manifestLoadingRetryDelay;
        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
      } else {
        retry = config.levelLoadingMaxRetry;
        timeout = config.levelLoadingTimeOut;
        retryDelay = config.levelLoadingRetryDelay;
        maxRetryDelay = config.levelLoadingMaxRetryTimeout;
        _logger.logger.log('loading playlist for ' + context.type + ' ' + (context.level || context.id));
      }
      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
      context.url = url;
      context.responseType = '';

      var loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
      loader.load(context, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;
      MASTER_PLAYLIST_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = this.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        var codecs = attrs.CODECS;
        if (codecs) {
          codecs = codecs.split(/[ ,]+/);
          for (var i = 0; i < codecs.length; i++) {
            var codec = codecs[i];
            if (codec.indexOf('avc1') !== -1) {
              level.videoCodec = this.avc1toavcoti(codec);
            } else {
              level.audioCodec = codec;
            }
          }
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var result = void 0,
          medias = [],
          id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) != null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = this.resolve(attrs.URI, baseurl);
          }
          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }
          media.id = id++;
          medias.push(media);
        }
      }
      return medias;
    }
  }, {
    key: 'avc1toavcoti',
    value: function avc1toavcoti(codec) {
      var result,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type) {
      var currentSN = 0,
          totalduration = 0,
          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
          levelkey = new LevelKey(),
          cc = 0,
          prevFrag = null,
          frag = new Fragment(),
          result,
          i;

      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        var duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var title = (' ' + result[2]).slice(1);
          frag.title = title ? title : null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (!isNaN(frag.duration)) {
            var sn = currentSN++;
            frag.type = type;
            frag.start = totalduration;
            frag.levelkey = levelkey;
            frag.sn = sn;
            frag.level = id;
            frag.cc = cc;
            frag.baseurl = baseurl;
            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
            frag.relurl = (' ' + result[3]).slice(1);

            level.fragments.push(frag);
            prevFrag = frag;
            totalduration += frag.duration;

            frag = new Fragment();
          }
        } else if (result[4]) {
          // X-BYTERANGE
          frag.rawByteRange = (' ' + result[4]).slice(1);
          if (prevFrag) {
            var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
            if (lastByteRangeEndOffset) {
              frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
            }
          }
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.rawProgramDateTime = (' ' + result[5]).slice(1);
          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          for (i = 1; i < result.length; i++) {
            if (result[i] !== undefined) {
              break;
            }
          }

          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var value1 = (' ' + result[i + 1]).slice(1);
          var value2 = (' ' + result[i + 2]).slice(1);

          switch (result[i]) {
            case '#':
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
              break;
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'TARGETDURATION':
              level.targetduration = parseFloat(value1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case 'DIS':
              cc++;
              frag.tagList.push(['DIS']);
              break;
            case 'DISCONTINUITY-SEQ':
              cc = parseInt(value1);
              break;
            case 'KEY':
              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
              var decryptparams = value1;
              var keyAttrs = new _attrList2.default(decryptparams);
              var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                  decrypturi = keyAttrs.URI,
                  decryptiv = keyAttrs.hexadecimalInteger('IV');
              if (decryptmethod) {
                levelkey = new LevelKey();
                if (decrypturi && ['AES-128', 'SAMPLE-AES'].indexOf(decryptmethod) >= 0) {
                  levelkey.method = decryptmethod;
                  // URI to get the key
                  levelkey.baseuri = baseurl;
                  levelkey.reluri = decrypturi;
                  levelkey.key = null;
                  // Initialization Vector (IV)
                  levelkey.iv = decryptiv;
                }
              }
              break;
            case 'START':
              var startParams = value1;
              var startAttrs = new _attrList2.default(startParams);
              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
              //TIME-OFFSET can be 0
              if (!isNaN(startTimeOffset)) {
                level.startTimeOffset = startTimeOffset;
              }
              break;
            case 'MAP':
              var mapAttrs = new _attrList2.default(value1);
              frag.relurl = mapAttrs.URI;
              frag.rawByteRange = mapAttrs.BYTERANGE;
              frag.baseurl = baseurl;
              frag.level = id;
              frag.type = type;
              frag.sn = 'initSegment';
              level.initSegment = frag;
              frag = new Fragment();
              break;
            default:
              _logger.logger.warn('line parsed but not handled: ' + result);
              break;
          }
        }
      }
      frag = prevFrag;
      //logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.relurl) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      return level;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var string = response.data,
          url = response.url,
          type = context.type,
          id = context.id,
          level = context.level,
          hls = this.hls;

      this.loaders[type] = undefined;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      stats.tload = performance.now();
      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
      if (string.indexOf('#EXTM3U') === 0) {
        if (string.indexOf('#EXTINF:') > 0) {
          var isLevel = type !== 'audioTrack' && type !== 'subtitleTrack',
              levelId = !isNaN(level) ? level : !isNaN(id) ? id : 0,
              levelDetails = this.parseLevelPlaylist(string, url, levelId, type === 'audioTrack' ? 'audio' : type === 'subtitleTrack' ? 'subtitle' : 'main');
          levelDetails.tload = stats.tload;
          if (type === 'manifest') {
            // first request, stream manifest (no master playlist), fire manifest loaded event with level details
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], audioTracks: [], url: url, stats: stats });
          }
          stats.tparsed = performance.now();
          if (levelDetails.targetduration) {
            if (isLevel) {
              hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });
            } else {
              if (type === 'audioTrack') {
                hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
              } else if (type === 'subtitleTrack') {
                hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
              }
            }
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'invalid targetduration' });
          }
        } else {
          var levels = this.parseMasterPlaylist(string, url);
          // multi level playlist, parse level info
          if (levels.length) {
            var audioTracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');
            var subtitles = this.parseMasterPlaylistMedia(string, url, 'SUBTITLES');
            if (audioTracks.length) {
              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
              var embeddedAudioFound = false;
              audioTracks.forEach(function (audioTrack) {
                if (!audioTrack.url) {
                  embeddedAudioFound = true;
                }
              });
              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                audioTracks.unshift({ type: 'main', name: 'main' });
              }
            }
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audioTracks, subtitles: subtitles, url: url, stats: stats });
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest' });
          }
        }
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context });
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;

},{"../errors":33,"../event-handler":34,"../events":35,"../utils/attr-list":47,"../utils/logger":53,"url-toolkit":2}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

//import Hex from '../utils/hex';

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        '.mp3': [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }
      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
     * @param tracks... (optional) {array} the tracks associated with this movie
     */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }
      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      var bytes = new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags,
          i;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i,
          data,
          len;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);
        sps = sps.concat(Array.prototype.slice.call(data)); // SPS
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);
        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height,
          hSpacing = track.pixelRatio[0],
          vSpacing = track.pixelRatio[1];
      //console.log('avcc:' + Hex.hexDump(avcc));
      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
      hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
      vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, //es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, //codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'mp3',
    value: function mp3(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        if (!track.isAAC && track.codec === 'mp3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height,
          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id,
          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i,
          sample,
          duration,
          size,
          flags,
          cts;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }
      var movie = MP4.moov(tracks),
          result;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;

},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aac = require('../helper/aac');

var _aac2 = _interopRequireDefault(_aac);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _mp4Generator = require('../remux/mp4-generator');

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;

var MP4Remuxer = function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    var userAgent = navigator.userAgent;
    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
    this.ISGenerated = false;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp(defaultTimeStamp) {
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      if (this.ISGenerated) {
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
        // calculated in remuxAudio.
        //logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (audioTrack.samples.length) {
          // if initSegment was generated without video samples, regenerate it again
          if (!audioTrack.timescale) {
            _logger.logger.warn('regenerate InitSegment as audio detected');
            this.generateIS(audioTrack, videoTrack, timeOffset);
          }
          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous, accurateTimeOffset);
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }
            // if initSegment was generated without video samples, regenerate it again
            if (!videoTrack.timescale) {
              _logger.logger.warn('regenerate InitSegment as video detected');
              this.generateIS(audioTrack, videoTrack, timeOffset);
            }
            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);
          }
        } else {
          var videoData = void 0;
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);
          }
          if (videoData && audioTrack.codec) {
            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);
          }
        }
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }
      //notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED);
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          typeSupported = this.typeSupported,
          container = 'audio/mp4',
          tracks = {},
          data = { tracks: tracks },
          computePTSDTS = this._initPTS === undefined,
          initPTS,
          initDTS;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        // let's use audio sampling rate as MP4 time scale.
        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
        // using audio sampling rate here helps having an integer MP4 frame duration
        // this avoids potential rounding issue and AV sync issue
        audioTrack.timescale = audioTrack.samplerate;
        _logger.logger.log('audio sampling rate : ' + audioTrack.samplerate);
        if (!audioTrack.isAAC) {
          if (typeSupported.mpeg) {
            // Chrome and Safari
            container = 'audio/mpeg';
            audioTrack.codec = '';
          } else if (typeSupported.mp3) {
            // Firefox
            audioTrack.codec = 'mp3';
          }
        }
        tracks.audio = {
          container: container,
          codec: audioTrack.codec,
          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS = DTS
          initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        // let's use input time scale as MP4 video timescale
        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
        var inputTimeScale = videoTrack.inputTimeScale;
        videoTrack.timescale = inputTimeScale;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
      var offset = 8,
          timeScale = track.timescale,
          mp4SampleDuration,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          nextDTS,
          lastPTS,
          lastDTS,
          inputSamples = track.samples,
          outputSamples = [],
          nbSamples = inputSamples.length,
          ptsNormalize = this._PTSNormalize,
          initDTS = this._initDTS;

      // for (let i = 0; i < track.samples.length; i++) {
      //   let avcSample = track.samples[i];
      //   let units = avcSample.units;
      //   let unitsString = '';
      //   for (let j = 0; j < units.length ; j++) {
      //     unitsString += units[j].type + ',';
      //     if (units[j].data.length < 500) {
      //       unitsString += Hex.hexDump(units[j].data);
      //     }
      //   }
      //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
      // }

      // sort video samples by DTS then PTS then demux id order
      inputSamples.sort(function (a, b) {
        var deltadts = a.dts - b.dts;
        var deltapts = a.pts - b.pts;
        return deltadts ? deltadts : deltapts ? deltapts : a.id - b.id;
      });

      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
      }, 0);
      if (PTSDTSshift < 0) {
        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
        for (var i = 0; i < inputSamples.length; i++) {
          inputSamples[i].dts += PTSDTSshift;
        }
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      var nextAvcDts = void 0;
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      if (contiguous) {
        // if parsed fragment is contiguous with last one, let's use last DTS value as reference
        nextAvcDts = this.nextAvcDts;
      } else {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * timeScale;
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
      firstPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }
          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS + initDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS + initDTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
        }
      }
      nextDTS = firstDTS;

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
      lastPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);
      lastPTS = Math.max(lastPTS, lastDTS);

      var isSafari = this.isSafari;
      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
      }

      var nbNalu = 0,
          naluLen = 0;
      for (var _i = 0; _i < nbSamples; _i++) {
        // compute total/avc sample length and nb of NAL units
        var _sample = inputSamples[_i],
            units = _sample.units,
            nbUnits = units.length,
            sampleLen = 0;
        for (var j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }
        naluLen += sampleLen;
        nbNalu += nbUnits;
        _sample.length = sampleLen;

        // normalize PTS/DTS
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + _i * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(ptsNormalize(_sample.dts - initDTS, nextAvcDts), firstDTS);
        }
        // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)
        // and we ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(ptsNormalize(_sample.pts - initDTS, nextAvcDts), _sample.dts);
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      var mdatSize = naluLen + 4 * nbNalu + 8;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
        return;
      }
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i2 = 0; _i2 < nbSamples; _i2++) {
        var avcSample = inputSamples[_i2],
            avcSampleUnits = avcSample.units,
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
          var unit = avcSampleUnits[_j],
              unitData = unit.data,
              unitDataLen = unit.data.byteLength;
          view.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i2 < nbSamples - 1) {
            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than the minimum of maxBufferHole and
              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  maxSeekHole = config.maxSeekHole,
                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * timeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }
                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
        }

        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);
      track.samples = [];

      var data = {
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / timeScale,
        endPTS: (lastPTS + mp4SampleDuration) / timeScale,
        startDTS: firstDTS / timeScale,
        endDTS: this.nextAvcDts / timeScale,
        type: 'video',
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.timescale,
          scaleFactor = inputTimeScale / mp4timeScale,
          mp4SampleDuration = track.isAAC ? 1024 : 1152,
          inputSampleDuration = mp4SampleDuration * scaleFactor,
          ptsNormalize = this._PTSNormalize,
          initDTS = this._initDTS,
          rawMPEG = !track.isAAC && this.typeSupported.mpeg;

      var view,
          offset = rawMPEG ? 0 : 8,
          audioSample,
          mp4Sample,
          unit,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          lastDTS,
          pts,
          dts,
          ptsnorm,
          dtsnorm,
          outputSamples = [],
          inputSamples = [],
          fillFrame,
          newStamp,
          nextAudioPts;

      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });
      inputSamples = track.samples;

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
      //  - less than 20 audio frames distance
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame

      nextAudioPts = this.nextAudioPts;
      contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initDTS) < 20 * inputSampleDuration);

      if (!contiguous) {
        // if fragments are not contiguous, let's use timeOffset to compute next Audio PTS
        nextAudioPts = timeOffset * inputTimeScale;
      }
      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.

      // only inject/drop audio frames in case time offset is accurate
      if (accurateTimeOffset && track.isAAC) {
        for (var i = 0, nextPtsNorm = nextAudioPts; i < inputSamples.length;) {
          // First, let's see how far off this frame is from where we expect it to be
          var sample = inputSamples[i],
              ptsNorm = ptsNormalize(sample.pts - initDTS, nextAudioPts),
              delta = ptsNorm - nextPtsNorm;

          var duration = Math.abs(1000 * delta / inputTimeScale);

          // If we're overlapping by more than a duration, drop this sample
          if (delta <= -inputSampleDuration) {
            _logger.logger.warn('Dropping 1 audio frame @ ' + (nextPtsNorm / inputTimeScale).toFixed(3) + 's due to ' + duration + ' ms overlap.');
            inputSamples.splice(i, 1);
            track.len -= sample.unit.length;
            // Don't touch nextPtsNorm or i
          }

          // Insert missing frames if:
          // 1: We're more than one frame away
          // 2: Not more than MAX_SILENT_FRAME_DURATION away
          // 3: currentTime (aka nextPtsNorm) is not 0
          else if (delta >= inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPtsNorm) {
              var missing = Math.round(delta / inputSampleDuration);
              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + (nextPtsNorm / inputTimeScale).toFixed(3) + 's due to ' + Math.round(1000 * delta / inputTimeScale) + ' ms gap.');
              for (var j = 0; j < missing; j++) {
                newStamp = nextPtsNorm + initDTS;
                newStamp = Math.max(newStamp, initDTS);
                fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                  fillFrame = sample.unit.subarray();
                }
                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                track.len += fillFrame.length;
                nextPtsNorm += inputSampleDuration;
                i += 1;
              }

              // Adjust sample to next expected pts
              sample.pts = sample.dts = nextPtsNorm + initDTS;
              nextPtsNorm += inputSampleDuration;
              i += 1;
            }
            // Otherwise, just adjust pts
            else {
                if (Math.abs(delta) > 0.1 * inputSampleDuration) {
                  // logger.log(`Invalid frame delta ${Math.round(ptsNorm - nextPtsNorm + inputSampleDuration)} at PTS ${Math.round(ptsNorm / 90)} (should be ${Math.round(inputSampleDuration)}).`);
                }
                nextPtsNorm += inputSampleDuration;
                if (i === 0) {
                  sample.pts = sample.dts = initDTS + nextAudioPts;
                } else {
                  sample.pts = sample.dts = inputSamples[i - 1].pts + inputSampleDuration;
                }
                i += 1;
              }
        }
      }

      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
        audioSample = inputSamples[_j2];
        unit = audioSample.unit;
        pts = audioSample.pts - initDTS;
        dts = audioSample.dts - initDTS;
        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastDTS !== undefined) {
          ptsnorm = ptsNormalize(pts, lastDTS);
          dtsnorm = ptsNormalize(dts, lastDTS);
          mp4Sample.duration = Math.round((dtsnorm - lastDTS) / scaleFactor);
        } else {
          ptsnorm = ptsNormalize(pts, nextAudioPts);
          dtsnorm = ptsNormalize(dts, nextAudioPts);
          var _delta = Math.round(1000 * (ptsnorm - nextAudioPts) / inputTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous && track.isAAC) {
            // log delta
            if (_delta) {
              if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {
                numMissingFrames = Math.round((ptsnorm - nextAudioPts) / inputSampleDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.subarray();
                  }
                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (ptsnorm / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              ptsnorm = dtsnorm = nextAudioPts;
            }
          }
          // remember first PTS of our audioSamples, ensure value is positive
          firstPTS = Math.max(0, ptsnorm);
          firstDTS = Math.max(0, dtsnorm);
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */

            var mdatSize = rawMPEG ? track.len : track.len + 8;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
              return;
            }
            if (!rawMPEG) {
              view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(_mp4Generator2.default.types.mdat, 4);
            }
          } else {
            // no audio samples
            return;
          }
          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
            newStamp = ptsnorm - (numMissingFrames - _i3) * inputSampleDuration;
            fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.subarray();
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            outputSamples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        var unitLen = unit.byteLength;
        offset += unitLen;
        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unitLen,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        outputSamples.push(mp4Sample);
        lastDTS = dtsnorm;
      }
      var lastSampleDuration = 0;
      var nbSamples = outputSamples.length;
      //set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = outputSamples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next audio sample PTS should be equal to last sample PTS + duration
        this.nextAudioPts = ptsnorm + scaleFactor * lastSampleDuration;
        //logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = outputSamples;
        if (rawMPEG) {
          moof = new Uint8Array();
        } else {
          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / scaleFactor, track);
        }
        track.samples = [];
        var audioData = {
          data1: moof,
          data2: mdat,
          startPTS: firstPTS / inputTimeScale,
          endPTS: this.nextAudioPts / inputTimeScale,
          startDTS: firstDTS / inputTimeScale,
          endDTS: (dtsnorm + scaleFactor * lastSampleDuration) / inputTimeScale,
          type: 'audio',
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
          scaleFactor = inputTimeScale / mp4timeScale,
          nextAudioPts = this.nextAudioPts,


      // sync with video's timestamp
      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
          endDTS = videoData.endDTS * inputTimeScale + this._initDTS,

      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = scaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

      _logger.logger.warn('remux empty Audio');
      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track, timeOffset) {
      var length = track.samples.length,
          sample;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      var initDTS = this._initDTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
          sample.dts = (sample.dts - initDTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track, timeOffset) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset;
      if (reference === undefined) {
        return value;
      }
      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }
      return value;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;

},{"../errors":33,"../events":35,"../helper/aac":36,"../remux/mp4-generator":44,"../utils/logger":53}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {}
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
      var observer = this.observer;
      var streamType = '';
      if (audioTrack) {
        streamType += 'audio';
      }
      if (videoTrack) {
        streamType += 'video';
      }
      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: streamType,
        nb: 1,
        dropped: 0
      });
      //notify end of parsing
      observer.trigger(_events2.default.FRAG_PARSED);
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;

},{"../events":35}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }
    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var match,
          attrs = {};
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;

},{}],48:[function(require,module,exports){
"use strict";

var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
    search: function search(list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;

        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];

            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            } else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            } else {
                return currentElement;
            }
        }

        return null;
    }
};

module.exports = BinarySearch;

},{}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */

var specialCea608CharsCodes = {
    0x2a: 0xe1, // lowercase a, acute accent
    0x5c: 0xe9, // lowercase e, acute accent
    0x5e: 0xed, // lowercase i, acute accent
    0x5f: 0xf3, // lowercase o, acute accent
    0x60: 0xfa, // lowercase u, acute accent
    0x7b: 0xe7, // lowercase c with cedilla
    0x7c: 0xf7, // division symbol
    0x7d: 0xd1, // uppercase N tilde
    0x7e: 0xf1, // lowercase n tilde
    0x7f: 0x2588, // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae, // Registered symbol (R)
    0x81: 0xb0, // degree sign
    0x82: 0xbd, // 1/2 symbol
    0x83: 0xbf, // Inverted (open) question mark
    0x84: 0x2122, // Trademark symbol (TM)
    0x85: 0xa2, // Cents symbol
    0x86: 0xa3, // Pounds sterling
    0x87: 0x266a, // Music 8'th note
    0x88: 0xe0, // lowercase a, grave accent
    0x89: 0x20, // transparent space (regular)
    0x8a: 0xe8, // lowercase e, grave accent
    0x8b: 0xe2, // lowercase a, circumflex accent
    0x8c: 0xea, // lowercase e, circumflex accent
    0x8d: 0xee, // lowercase i, circumflex accent
    0x8e: 0xf4, // lowercase o, circumflex accent
    0x8f: 0xfb, // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1, // capital letter A with acute
    0x91: 0xc9, // capital letter E with acute
    0x92: 0xd3, // capital letter O with acute
    0x93: 0xda, // capital letter U with acute
    0x94: 0xdc, // capital letter U with diaresis
    0x95: 0xfc, // lowercase letter U with diaeresis
    0x96: 0x2018, // opening single quote
    0x97: 0xa1, // inverted exclamation mark
    0x98: 0x2a, // asterisk
    0x99: 0x2019, // closing single quote
    0x9a: 0x2501, // box drawings heavy horizontal
    0x9b: 0xa9, // copyright sign
    0x9c: 0x2120, // Service mark
    0x9d: 0x2022, // (round) bullet
    0x9e: 0x201c, // Left double quotation mark
    0x9f: 0x201d, // Right double quotation mark
    0xa0: 0xc0, // uppercase A, grave accent
    0xa1: 0xc2, // uppercase A, circumflex
    0xa2: 0xc7, // uppercase C with cedilla
    0xa3: 0xc8, // uppercase E, grave accent
    0xa4: 0xca, // uppercase E, circumflex
    0xa5: 0xcb, // capital letter E with diaresis
    0xa6: 0xeb, // lowercase letter e with diaresis
    0xa7: 0xce, // uppercase I, circumflex
    0xa8: 0xcf, // uppercase I, with diaresis
    0xa9: 0xef, // lowercase i, with diaresis
    0xaa: 0xd4, // uppercase O, circumflex
    0xab: 0xd9, // uppercase U, grave accent
    0xac: 0xf9, // lowercase u, grave accent
    0xad: 0xdb, // uppercase U, circumflex
    0xae: 0xab, // left-pointing double angle quotation mark
    0xaf: 0xbb, // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3, // Uppercase A, tilde
    0xb1: 0xe3, // Lowercase a, tilde
    0xb2: 0xcd, // Uppercase I, acute accent
    0xb3: 0xcc, // Uppercase I, grave accent
    0xb4: 0xec, // Lowercase i, grave accent
    0xb5: 0xd2, // Uppercase O, grave accent
    0xb6: 0xf2, // Lowercase o, grave accent
    0xb7: 0xd5, // Uppercase O, tilde
    0xb8: 0xf5, // Lowercase o, tilde
    0xb9: 0x7b, // Open curly brace
    0xba: 0x7d, // Closing curly brace
    0xbb: 0x5c, // Backslash
    0xbc: 0x5e, // Caret
    0xbd: 0x5f, // Underscore
    0xbe: 0x7c, // Pipe (vertical line)
    0xbf: 0x223c, // Tilde operator
    0xc0: 0xc4, // Uppercase A, umlaut
    0xc1: 0xe4, // Lowercase A, umlaut
    0xc2: 0xd6, // Uppercase O, umlaut
    0xc3: 0xf6, // Lowercase o, umlaut
    0xc4: 0xdf, // Esszett (sharp S)
    0xc5: 0xa5, // Yen symbol
    0xc6: 0xa4, // Generic currency sign
    0xc7: 0x2503, // Box drawings heavy vertical
    0xc8: 0xc5, // Uppercase A, ring
    0xc9: 0xe5, // Lowercase A, ring
    0xca: 0xd8, // Uppercase O, stroke
    0xcb: 0xf8, // Lowercase o, strok
    0xcc: 0x250f, // Box drawings heavy down and right
    0xcd: 0x2513, // Box drawings heavy down and left
    0xce: 0x2517, // Box drawings heavy up and right
    0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0, // Only write errors
    setTime: function setTime(newTime) {
        this.time = newTime;
    },
    log: function log(severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            console.log(this.time + ' [' + severity + '] ' + msg);
        }
    }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};

var PenState = function () {
    function PenState(foreground, underline, italics, background, flash) {
        _classCallCheck(this, PenState);

        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }

    _createClass(PenState, [{
        key: 'reset',
        value: function reset() {
            this.foreground = 'white';
            this.underline = false;
            this.italics = false;
            this.background = 'black';
            this.flash = false;
        }
    }, {
        key: 'setStyles',
        value: function setStyles(styles) {
            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
            for (var i = 0; i < attribs.length; i++) {
                var style = attribs[i];
                if (styles.hasOwnProperty(style)) {
                    this[style] = styles[style];
                }
            }
        }
    }, {
        key: 'isDefault',
        value: function isDefault() {
            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
        }
    }, {
        key: 'copy',
        value: function copy(newPenState) {
            this.foreground = newPenState.foreground;
            this.underline = newPenState.underline;
            this.italics = newPenState.italics;
            this.background = newPenState.background;
            this.flash = newPenState.flash;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
        }
    }]);

    return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        _classCallCheck(this, StyledUnicodeChar);

        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }

    _createClass(StyledUnicodeChar, [{
        key: 'reset',
        value: function reset() {
            this.uchar = ' ';
            this.penState.reset();
        }
    }, {
        key: 'setChar',
        value: function setChar(uchar, newPenState) {
            this.uchar = uchar;
            this.penState.copy(newPenState);
        }
    }, {
        key: 'setPenState',
        value: function setPenState(newPenState) {
            this.penState.copy(newPenState);
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.uchar === other.uchar && this.penState.equals(other.penState);
        }
    }, {
        key: 'copy',
        value: function copy(newChar) {
            this.uchar = newChar.uchar;
            this.penState.copy(newChar.penState);
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return this.uchar === ' ' && this.penState.isDefault();
        }
    }]);

    return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
    function Row() {
        _classCallCheck(this, Row);

        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }

    _createClass(Row, [{
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].equals(other.chars[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_COLS; i++) {
                this.chars[i].copy(other.chars[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }

        /**
         *  Set the cursor to a valid column.
         */

    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            if (this.pos !== absPos) {
                this.pos = absPos;
            }
            if (this.pos < 0) {
                logger.log('ERROR', 'Negative cursor position ' + this.pos);
                this.pos = 0;
            } else if (this.pos > NR_COLS) {
                logger.log('ERROR', 'Too large cursor position ' + this.pos);
                this.pos = NR_COLS;
            }
        }

        /**
         * Move the cursor relative to current position.
         */

    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var newPos = this.pos + relPos;
            if (relPos > 1) {
                for (var i = this.pos + 1; i < newPos + 1; i++) {
                    this.chars[i].setPenState(this.currPenState);
                }
            }
            this.setCursor(newPos);
        }

        /**
         * Backspace, move one step back and clear character.
         */

    }, {
        key: 'backSpace',
        value: function backSpace() {
            this.moveCursor(-1);
            this.chars[this.pos].setChar(' ', this.currPenState);
        }
    }, {
        key: 'insertChar',
        value: function insertChar(byte) {
            if (byte >= 0x90) {
                //Extended char
                this.backSpace();
            }
            var char = getCharForByte(byte);
            if (this.pos >= NR_COLS) {
                logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
                return;
            }
            this.chars[this.pos].setChar(char, this.currPenState);
            this.moveCursor(1);
        }
    }, {
        key: 'clearFromPos',
        value: function clearFromPos(startPos) {
            var i;
            for (i = startPos; i < NR_COLS; i++) {
                this.chars[i].reset();
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.clearFromPos(0);
            this.pos = 0;
            this.currPenState.reset();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            this.clearFromPos(this.pos);
        }
    }, {
        key: 'getTextString',
        value: function getTextString() {
            var chars = [];
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                var char = this.chars[i].uchar;
                if (char !== ' ') {
                    empty = false;
                }
                chars.push(char);
            }
            if (empty) {
                return '';
            } else {
                return chars.join('');
            }
        }
    }, {
        key: 'setPenStyles',
        value: function setPenStyles(styles) {
            this.currPenState.setStyles(styles);
            var currChar = this.chars[this.pos];
            currChar.setPenState(this.currPenState);
        }
    }]);

    return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
    function CaptionScreen() {
        _classCallCheck(this, CaptionScreen);

        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
        }
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }

    _createClass(CaptionScreen, [{
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }
            this.currRow = NR_ROWS - 1;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].equals(other.rows[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].copy(other.rows[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }
    }, {
        key: 'backSpace',
        value: function backSpace() {
            var row = this.rows[this.currRow];
            row.backSpace();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            var row = this.rows[this.currRow];
            row.clearToEndOfRow();
        }

        /**
         * Insert a character (without styling) in the current row.
         */

    }, {
        key: 'insertChar',
        value: function insertChar(char) {
            var row = this.rows[this.currRow];
            row.insertChar(char);
        }
    }, {
        key: 'setPen',
        value: function setPen(styles) {
            var row = this.rows[this.currRow];
            row.setPenStyles(styles);
        }
    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var row = this.rows[this.currRow];
            row.moveCursor(relPos);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            logger.log('INFO', 'setCursor: ' + absPos);
            var row = this.rows[this.currRow];
            row.setCursor(absPos);
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
            var newRow = pacData.row - 1;
            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                newRow = this.nrRollUpRows - 1;
            }

            //Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
            if (this.nrRollUpRows && this.currRow !== newRow) {
                //clear all rows first
                for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].clear();
                }

                //Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
                //topRowIndex - the start of rows to copy (inclusive index)
                var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                //We only copy if the last position was already shown.
                //We use the cueStartTime value to check this.
                var lastOutputScreen = this.lastOutputScreen;
                if (lastOutputScreen) {
                    var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                    if (prevLineTime && prevLineTime < logger.time) {
                        for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                        }
                    }
                }
            }

            this.currRow = newRow;
            var row = this.rows[this.currRow];
            if (pacData.indent !== null) {
                var indent = pacData.indent;
                var prevPos = Math.max(indent - 1, 0);
                row.setCursor(pacData.indent);
                pacData.color = row.chars[prevPos].penState.foreground;
            }
            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
            this.setPen(styles);
        }

        /**
         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
         */

    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {

            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
            this.backSpace();
            this.setPen(bkgData);
            this.insertChar(0x20); //Space
        }
    }, {
        key: 'setRollUpRows',
        value: function setRollUpRows(nrRows) {
            this.nrRollUpRows = nrRows;
        }
    }, {
        key: 'rollUp',
        value: function rollUp() {
            if (this.nrRollUpRows === null) {
                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
                return; //Not properly setup
            }
            logger.log('TEXT', this.getDisplayText());
            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
            var topRow = this.rows.splice(topRowIndex, 1)[0];
            topRow.clear();
            this.rows.splice(this.currRow, 0, topRow);
            logger.log('INFO', 'Rolling up');
            //logger.log('TEXT', this.get_display_text())
        }

        /**
         * Get all non-empty rows with as unicode text.
         */

    }, {
        key: 'getDisplayText',
        value: function getDisplayText(asOneRow) {
            asOneRow = asOneRow || false;
            var displayText = [];
            var text = '';
            var rowNr = -1;
            for (var i = 0; i < NR_ROWS; i++) {
                var rowText = this.rows[i].getTextString();
                if (rowText) {
                    rowNr = i + 1;
                    if (asOneRow) {
                        displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                    } else {
                        displayText.push(rowText.trim());
                    }
                }
            }
            if (displayText.length > 0) {
                if (asOneRow) {
                    text = '[' + displayText.join(' | ') + ']';
                } else {
                    text = displayText.join('\n');
                }
            }
            return text;
        }
    }, {
        key: 'getTextAndFormat',
        value: function getTextAndFormat() {
            return this.rows;
        }
    }]);

    return CaptionScreen;
}();

//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
    function Cea608Channel(channelNumber, outputFilter) {
        _classCallCheck(this, Cea608Channel);

        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }

    _createClass(Cea608Channel, [{
        key: 'reset',
        value: function reset() {
            this.mode = null;
            this.displayedMemory.reset();
            this.nonDisplayedMemory.reset();
            this.lastOutputScreen.reset();
            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
            this.writeScreen = this.displayedMemory;
            this.mode = null;
            this.cueStartTime = null;
            this.lastCueEndTime = null;
        }
    }, {
        key: 'getHandler',
        value: function getHandler() {
            return this.outputFilter;
        }
    }, {
        key: 'setHandler',
        value: function setHandler(newHandler) {
            this.outputFilter = newHandler;
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            this.writeScreen.setPAC(pacData);
        }
    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {
            this.writeScreen.setBkgData(bkgData);
        }
    }, {
        key: 'setMode',
        value: function setMode(newMode) {
            if (newMode === this.mode) {
                return;
            }
            this.mode = newMode;
            logger.log('INFO', 'MODE=' + newMode);
            if (this.mode === 'MODE_POP-ON') {
                this.writeScreen = this.nonDisplayedMemory;
            } else {
                this.writeScreen = this.displayedMemory;
                this.writeScreen.reset();
            }
            if (this.mode !== 'MODE_ROLL-UP') {
                this.displayedMemory.nrRollUpRows = null;
                this.nonDisplayedMemory.nrRollUpRows = null;
            }
            this.mode = newMode;
        }
    }, {
        key: 'insertChars',
        value: function insertChars(chars) {
            for (var i = 0; i < chars.length; i++) {
                this.writeScreen.insertChar(chars[i]);
            }
            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccRCL',
        value: function ccRCL() {
            // Resume Caption Loading (switch mode to Pop On)
            logger.log('INFO', 'RCL - Resume Caption Loading');
            this.setMode('MODE_POP-ON');
        }
    }, {
        key: 'ccBS',
        value: function ccBS() {
            // BackSpace
            logger.log('INFO', 'BS - BackSpace');
            if (this.mode === 'MODE_TEXT') {
                return;
            }
            this.writeScreen.backSpace();
            if (this.writeScreen === this.displayedMemory) {
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccAOF',
        value: function ccAOF() {
            // Reserved (formerly Alarm Off)
            return;
        }
    }, {
        key: 'ccAON',
        value: function ccAON() {
            // Reserved (formerly Alarm On)
            return;
        }
    }, {
        key: 'ccDER',
        value: function ccDER() {
            // Delete to End of Row
            logger.log('INFO', 'DER- Delete to End of Row');
            this.writeScreen.clearToEndOfRow();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccRU',
        value: function ccRU(nrRows) {
            //Roll-Up Captions-2,3,or 4 Rows
            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
            this.writeScreen = this.displayedMemory;
            this.setMode('MODE_ROLL-UP');
            this.writeScreen.setRollUpRows(nrRows);
        }
    }, {
        key: 'ccFON',
        value: function ccFON() {
            //Flash On
            logger.log('INFO', 'FON - Flash On');
            this.writeScreen.setPen({ flash: true });
        }
    }, {
        key: 'ccRDC',
        value: function ccRDC() {
            // Resume Direct Captioning (switch mode to PaintOn)
            logger.log('INFO', 'RDC - Resume Direct Captioning');
            this.setMode('MODE_PAINT-ON');
        }
    }, {
        key: 'ccTR',
        value: function ccTR() {
            // Text Restart in text mode (not supported, however)
            logger.log('INFO', 'TR');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccRTD',
        value: function ccRTD() {
            // Resume Text Display in Text mode (not supported, however)
            logger.log('INFO', 'RTD');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccEDM',
        value: function ccEDM() {
            // Erase Displayed Memory
            logger.log('INFO', 'EDM - Erase Displayed Memory');
            this.displayedMemory.reset();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccCR',
        value: function ccCR() {
            // Carriage Return
            logger.log('CR - Carriage Return');
            this.writeScreen.rollUp();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccENM',
        value: function ccENM() {
            //Erase Non-Displayed Memory
            logger.log('INFO', 'ENM - Erase Non-displayed Memory');
            this.nonDisplayedMemory.reset();
        }
    }, {
        key: 'ccEOC',
        value: function ccEOC() {
            //End of Caption (Flip Memories)
            logger.log('INFO', 'EOC - End Of Caption');
            if (this.mode === 'MODE_POP-ON') {
                var tmp = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory;
                this.nonDisplayedMemory = tmp;
                this.writeScreen = this.nonDisplayedMemory;
                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate();
        }
    }, {
        key: 'ccTO',
        value: function ccTO(nrCols) {
            // Tab Offset 1,2, or 3 columns
            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
            this.writeScreen.moveCursor(nrCols);
        }
    }, {
        key: 'ccMIDROW',
        value: function ccMIDROW(secondByte) {
            // Parse MIDROW command
            var styles = { flash: false };
            styles.underline = secondByte % 2 === 1;
            styles.italics = secondByte >= 0x2e;
            if (!styles.italics) {
                var colorIndex = Math.floor(secondByte / 2) - 0x10;
                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
                styles.foreground = colors[colorIndex];
            } else {
                styles.foreground = 'white';
            }
            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
            this.writeScreen.setPen(styles);
        }
    }, {
        key: 'outputDataUpdate',
        value: function outputDataUpdate() {
            var t = logger.time;
            if (t === null) {
                return;
            }
            if (this.outputFilter) {
                if (this.outputFilter.updateData) {
                    this.outputFilter.updateData(t, this.displayedMemory);
                }
                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                    // Start of a new cue
                    this.cueStartTime = t;
                } else {
                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                        if (this.outputFilter.newCue) {
                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        }
                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                    }
                }
                this.lastOutputScreen.copy(this.displayedMemory);
            }
        }
    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            if (this.outputFilter) {
                if (!this.displayedMemory.isEmpty()) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                    }
                    this.cueStartTime = t;
                }
            }
        }
    }]);

    return Cea608Channel;
}();

var Cea608Parser = function () {
    function Cea608Parser(field, out1, out2) {
        _classCallCheck(this, Cea608Parser);

        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }

    _createClass(Cea608Parser, [{
        key: 'getHandler',
        value: function getHandler(index) {
            return this.channels[index].getHandler();
        }
    }, {
        key: 'setHandler',
        value: function setHandler(index, newHandler) {
            this.channels[index].setHandler(newHandler);
        }

        /**
         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
         */

    }, {
        key: 'addData',
        value: function addData(t, byteList) {
            var cmdFound,
                a,
                b,
                charsFound = false;

            this.lastTime = t;
            logger.setTime(t);

            for (var i = 0; i < byteList.length; i += 2) {
                a = byteList[i] & 0x7f;
                b = byteList[i + 1] & 0x7f;
                if (a === 0 && b === 0) {
                    this.dataCounters.padding += 2;
                    continue;
                } else {
                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
                }
                cmdFound = this.parseCmd(a, b);
                if (!cmdFound) {
                    cmdFound = this.parseMidrow(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parsePAC(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parseBackgroundAttributes(a, b);
                }
                if (!cmdFound) {
                    charsFound = this.parseChars(a, b);
                    if (charsFound) {
                        if (this.currChNr && this.currChNr >= 0) {
                            var channel = this.channels[this.currChNr - 1];
                            channel.insertChars(charsFound);
                        } else {
                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                        }
                    }
                }
                if (cmdFound) {
                    this.dataCounters.cmd += 2;
                } else if (charsFound) {
                    this.dataCounters.char += 2;
                } else {
                    this.dataCounters.other += 2;
                    logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                }
            }
        }

        /**
         * Parse Command.
         * @returns {Boolean} Tells if a command was found
         */

    }, {
        key: 'parseCmd',
        value: function parseCmd(a, b) {
            var chNr = null;

            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
            if (!(cond1 || cond2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null; // Repeated commands are dropped (once)
                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
                return true;
            }

            if (a === 0x14 || a === 0x17) {
                chNr = 1;
            } else {
                chNr = 2; // (a === 0x1C || a=== 0x1f)
            }

            var channel = this.channels[chNr - 1];

            if (a === 0x14 || a === 0x1C) {
                if (b === 0x20) {
                    channel.ccRCL();
                } else if (b === 0x21) {
                    channel.ccBS();
                } else if (b === 0x22) {
                    channel.ccAOF();
                } else if (b === 0x23) {
                    channel.ccAON();
                } else if (b === 0x24) {
                    channel.ccDER();
                } else if (b === 0x25) {
                    channel.ccRU(2);
                } else if (b === 0x26) {
                    channel.ccRU(3);
                } else if (b === 0x27) {
                    channel.ccRU(4);
                } else if (b === 0x28) {
                    channel.ccFON();
                } else if (b === 0x29) {
                    channel.ccRDC();
                } else if (b === 0x2A) {
                    channel.ccTR();
                } else if (b === 0x2B) {
                    channel.ccRTD();
                } else if (b === 0x2C) {
                    channel.ccEDM();
                } else if (b === 0x2D) {
                    channel.ccCR();
                } else if (b === 0x2E) {
                    channel.ccENM();
                } else if (b === 0x2F) {
                    channel.ccEOC();
                }
            } else {
                //a == 0x17 || a == 0x1F
                channel.ccTO(b - 0x20);
            }
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Parse midrow styling command
         * @returns {Boolean}
         */

    }, {
        key: 'parseMidrow',
        value: function parseMidrow(a, b) {
            var chNr = null;

            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
                if (a === 0x11) {
                    chNr = 1;
                } else {
                    chNr = 2;
                }
                if (chNr !== this.currChNr) {
                    logger.log('ERROR', 'Mismatch channel in midrow parsing');
                    return false;
                }
                var channel = this.channels[chNr - 1];
                channel.ccMIDROW(b);
                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
                return true;
            }
            return false;
        }
        /**
         * Parse Preable Access Codes (Table 53).
         * @returns {Boolean} Tells if PAC found
         */

    }, {
        key: 'parsePAC',
        value: function parsePAC(a, b) {

            var chNr = null;
            var row = null;

            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
            if (!(case1 || case2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null;
                return true; // Repeated commands are dropped (once)
            }

            chNr = a <= 0x17 ? 1 : 2;

            if (0x40 <= b && b <= 0x5F) {
                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
            } else {
                // 0x60 <= b <= 0x7F
                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
            }
            var pacData = this.interpretPAC(row, b);
            var channel = this.channels[chNr - 1];
            channel.setPAC(pacData);
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Interpret the second byte of the pac, and return the information.
         * @returns {Object} pacData with style parameters.
         */

    }, {
        key: 'interpretPAC',
        value: function interpretPAC(row, byte) {
            var pacIndex = byte;
            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

            if (byte > 0x5F) {
                pacIndex = byte - 0x60;
            } else {
                pacIndex = byte - 0x40;
            }
            pacData.underline = (pacIndex & 1) === 1;
            if (pacIndex <= 0xd) {
                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
            } else if (pacIndex <= 0xf) {
                pacData.italics = true;
                pacData.color = 'white';
            } else {
                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
            }
            return pacData; // Note that row has zero offset. The spec uses 1.
        }

        /**
         * Parse characters.
         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
         */

    }, {
        key: 'parseChars',
        value: function parseChars(a, b) {

            var channelNr = null,
                charCodes = null,
                charCode1 = null;

            if (a >= 0x19) {
                channelNr = 2;
                charCode1 = a - 8;
            } else {
                channelNr = 1;
                charCode1 = a;
            }
            if (0x11 <= charCode1 && charCode1 <= 0x13) {
                // Special character
                var oneCode = b;
                if (charCode1 === 0x11) {
                    oneCode = b + 0x50;
                } else if (charCode1 === 0x12) {
                    oneCode = b + 0x70;
                } else {
                    oneCode = b + 0x90;
                }
                logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
                charCodes = [oneCode];
            } else if (0x20 <= a && a <= 0x7f) {
                charCodes = b === 0 ? [a] : [a, b];
            }
            if (charCodes) {
                var hexCodes = numArrayToHexArray(charCodes);
                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
                this.lastCmdA = null;
                this.lastCmdB = null;
            }
            return charCodes;
        }

        /**
        * Parse extended background attributes as well as new foreground color black.
        * @returns{Boolean} Tells if background attributes are found
        */

    }, {
        key: 'parseBackgroundAttributes',
        value: function parseBackgroundAttributes(a, b) {
            var bkgData, index, chNr, channel;

            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
            if (!(case1 || case2)) {
                return false;
            }
            bkgData = {};
            if (a === 0x10 || a === 0x18) {
                index = Math.floor((b - 0x20) / 2);
                bkgData.background = backgroundColors[index];
                if (b % 2 === 1) {
                    bkgData.background = bkgData.background + '_semi';
                }
            } else if (b === 0x2d) {
                bkgData.background = 'transparent';
            } else {
                bkgData.foreground = 'black';
                if (b === 0x2f) {
                    bkgData.underline = true;
                }
            }
            chNr = a < 0x18 ? 1 : 2;
            channel = this.channels[chNr - 1];
            channel.setBkgData(bkgData);
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true;
        }

        /**
         * Reset state of parser and its channels.
         */

    }, {
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].reset();
                }
            }
            this.lastCmdA = null;
            this.lastCmdB = null;
        }

        /**
         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
         */

    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].cueSplitAtTime(t);
                }
            }
        }
    }]);

    return Cea608Parser;
}();

exports.default = Cea608Parser;

},{}],50:[function(require,module,exports){
'use strict';

var _vttparser = require('./vttparser');

var Cues = {

  newCue: function newCue(track, startTime, endTime, captionScreen) {
    var row;
    var cue;
    var indenting;
    var indent;
    var text;
    var VTTCue = window.VTTCue || window.TextTrackCue;

    for (var r = 0; r < captionScreen.rows.length; r++) {
      row = captionScreen.rows[r];
      indenting = true;
      indent = 0;
      text = '';

      if (!row.isEmpty()) {
        for (var c = 0; c < row.chars.length; c++) {
          if (row.chars[c].uchar.match(/\s/) && indenting) {
            indent++;
          } else {
            text += row.chars[c].uchar;
            indenting = false;
          }
        }
        //To be used for cleaning-up orphaned roll-up captions
        row.cueStartTime = startTime;

        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
        if (startTime === endTime) {
          endTime += 0.0001;
        }

        cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));

        if (indent >= 16) {
          indent--;
        } else {
          indent++;
        }

        // VTTCue.line get's flakey when using controls, so let's now include line 13&14
        // also, drop line 1 since it's to close to the top
        if (navigator.userAgent.match(/Firefox\//)) {
          cue.line = r + 1;
        } else {
          cue.line = r > 7 ? r - 2 : r + 1;
        }
        cue.align = 'left';
        // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
        cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
        track.addCue(cue);
      }
    }
  }

};

module.exports = Cues;

},{"./vttparser":56}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = require('../utils/ewma');

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      //console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'canEstimate',
    value: function canEstimate() {
      var fast = this.fast_;
      return fast && fast.getTotalWeight() >= this.minWeight_;
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (this.canEstimate()) {
        //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;

},{"../utils/ewma":52}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {

  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;

},{}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

/*globals self: false */

//let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

function consolePrintFn(type) {
  var func = self.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }
      func.apply(self.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    //'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

},{}],54:[function(require,module,exports){
'use strict';

/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }
    return log;
  }
};

module.exports = TimeRanges;

},{}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.default = function () {
  if (typeof window !== 'undefined' && window.VTTCue) {
    return window.VTTCue;
  }

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') {
        return;
      }
      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
}();

},{}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fixLineBreaks = undefined;

var _vttcue = require('./vttcue');

var _vttcue2 = _interopRequireDefault(_vttcue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }
      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
}; /*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue2.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
// Chrome and Safari don't yet support this change, but FF does
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) {
            settings.set('snapToLines', false);
          }
          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }
          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }
          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            console.log('parse region', v);
            //parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();

        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              self.state = 'ID';
            }
            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }
            self.cue = new _vttcue2.default(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /*falls through*/
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) {
                self.oncue(self.cue);
              }
              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) {
              self.cue.text += '\n';
            }
            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = 'ID';
            }
            continue;
        }
      }
    } catch (e) {

      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      throw e;
    }
    if (self.onflush) {
      self.onflush();
    }
    return this;
  }
};

exports.fixLineBreaks = fixLineBreaks;
exports.default = VTTParser;

},{"./vttcue":55}],57:[function(require,module,exports){
'use strict';

var _vttparser = require('./vttparser');

var _vttparser2 = _interopRequireDefault(_vttparser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// String.prototype.startsWith is not supported in IE11
var startsWith = function startsWith(inputString, searchString, position) {
    return inputString.substr(position || 0, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
    var ts = parseInt(timeString.substr(-3));
    var secs = parseInt(timeString.substr(-6, 2));
    var mins = parseInt(timeString.substr(-9, 2));
    var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

    if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) {
        return -1;
    }

    ts += 1000 * secs;
    ts += 60 * 1000 * mins;
    ts += 60 * 60 * 1000 * hours;

    return ts;
};

// From https://github.com/darkskyapp/string-hash
var hash = function hash(text) {
    var hash = 5381;
    var i = text.length;
    while (i) {
        hash = hash * 33 ^ text.charCodeAt(--i);
    }
    return (hash >>> 0).toString();
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
    var currCC = vttCCs[cc];
    var prevCC = vttCCs[currCC.prevCC];

    // This is the first discontinuity or cues have been processed since the last discontinuity
    // Offset = current discontinuity time
    if (!prevCC || !prevCC.new && currCC.new) {
        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
        currCC.new = false;
        return;
    }

    // There have been discontinuities since cues were last parsed.
    // Offset = time elapsed
    while (prevCC && prevCC.new) {
        vttCCs.ccOffset += currCC.start - prevCC.start;
        currCC.new = false;
        currCC = prevCC;
        prevCC = vttCCs[currCC.prevCC];
    }

    vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
    parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
        // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
        var re = /\r\n|\n\r|\n|\r/g;
        var vttLines = String.fromCharCode.apply(null, new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');
        var cueTime = '00:00.000';
        var mpegTs = 0;
        var localTime = 0;
        var presentationTime = 0;
        var cues = [];
        var parsingError = void 0;
        var inHeader = true;
        // let VTTCue = VTTCue || window.TextTrackCue;

        // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
        var parser = new _vttparser2.default();

        parser.oncue = function (cue) {
            // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
            var currCC = vttCCs[cc];
            var cueOffset = vttCCs.ccOffset;

            // Update offsets for new discontinuities
            if (currCC && currCC.new) {
                if (localTime) {
                    // When local time is provided, offset = discontinuity start time - local time
                    cueOffset = vttCCs.ccOffset = currCC.start;
                } else {
                    calculateOffset(vttCCs, cc, presentationTime);
                }
            }

            if (presentationTime && !localTime) {
                // If we have MPEGTS but no LOCAL time, offset = presentation time + discontinuity offset
                cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset;
            }

            cue.startTime += cueOffset - localTime;
            cue.endTime += cueOffset - localTime;

            // Create a unique hash id for a cue based on start/end times and text.
            // This helps timeline-controller to avoid showing repeated captions.
            cue.id = hash(cue.startTime) + hash(cue.endTime) + hash(cue.text);

            // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
            cue.text = decodeURIComponent(escape(cue.text));
            if (cue.endTime > 0) {
                cues.push(cue);
            }
        };

        parser.onparsingerror = function (e) {
            parsingError = e;
        };

        parser.onflush = function () {
            if (parsingError && errorCallBack) {
                errorCallBack(parsingError);
                return;
            }
            callBack(cues);
        };

        // Go through contents line by line.
        vttLines.forEach(function (line) {
            if (inHeader) {
                // Look for X-TIMESTAMP-MAP in header.
                if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
                    // Once found, no more are allowed anyway, so stop searching.
                    inHeader = false;
                    // Extract LOCAL and MPEGTS.
                    line.substr(16).split(',').forEach(function (timestamp) {
                        if (startsWith(timestamp, 'LOCAL:')) {
                            cueTime = timestamp.substr(6);
                        } else if (startsWith(timestamp, 'MPEGTS:')) {
                            mpegTs = parseInt(timestamp.substr(7));
                        }
                    });
                    try {
                        // Calculate subtitle offset in milliseconds.
                        // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.
                        syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS;
                        // Adjust MPEGTS by sync PTS.
                        mpegTs -= syncPTS;
                        // Convert cue time to seconds
                        localTime = cueString2millis(cueTime) / 1000;
                        // Convert MPEGTS to seconds from 90kHz.
                        presentationTime = mpegTs / 90000;

                        if (localTime === -1) {
                            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                        }
                    } catch (e) {
                        parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                    }
                    // Return without parsing X-TIMESTAMP-MAP line.
                    return;
                } else if (line === '') {
                    inHeader = false;
                }
            }
            // Parse line by default.
            parser.parse(line + '\n');
        });

        parser.flush();
    }
};

module.exports = WebVTTParser;

},{"./vttparser":56}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr,
          context = this.context;

      if (typeof XDomainRequest !== 'undefined') {
        xhr = this.loader = new XDomainRequest();
      } else {
        xhr = this.loader = new XMLHttpRequest();
      }
      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      var xhrSetup = this.xhrSetup;

      try {
        if (xhrSetup) {
          try {
            xhrSetup(xhr, context.url);
          } catch (e) {
            // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
            // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
            xhr.open('GET', context.url, true);
            xhrSetup(xhr, context.url);
          }
        }
        if (!xhr.readyState) {
          xhr.open('GET', context.url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        this.callbacks.onError({ code: xhr.status, text: e.message }, context);
        return;
      }

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }
      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context.responseType;

      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'readystatechange',
    value: function readystatechange(event) {
      var xhr = event.currentTarget,
          readyState = xhr.readyState,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // >= HEADERS_RECEIVED
      if (readyState >= 2) {
        // clear xhr timeout and rearm it if readyState less than 4
        window.clearTimeout(this.requestTimeout);
        if (stats.tfirst === 0) {
          stats.tfirst = Math.max(performance.now(), stats.trequest);
        }
        if (readyState === 4) {
          var status = xhr.status;
          // http status between 200 to 299 are all successful
          if (status >= 200 && status < 300) {
            stats.tload = Math.max(stats.tfirst, performance.now());
            var data = void 0,
                len = void 0;
            if (context.responseType === 'arraybuffer') {
              data = xhr.response;
              len = data.byteLength;
            } else {
              data = xhr.responseText;
              len = data.length;
            }
            stats.loaded = stats.total = len;
            var response = { url: xhr.responseURL, data: data };
            this.callbacks.onSuccess(response, stats, context);
          } else {
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
              _logger.logger.error(status + ' while loading ' + context.url);
              this.callbacks.onError({ code: status, text: xhr.statusText }, context);
            } else {
              // retry
              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
              // aborts and resets internal state
              this.destroy();
              // schedule retry
              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
              // set exponential backoff
              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
              stats.retry++;
            }
          }
        } else {
          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var stats = this.stats;
      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // last args is to provide on progress data
        onProgress(stats, this.context, null);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;

},{"../utils/logger":53}]},{},[40])(40)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanMiLCJub2RlX21vZHVsZXMvd2Vid29ya2lmeS9pbmRleC5qcyIsInNyY1xcY29uZmlnLmpzIiwic3JjXFxjb250cm9sbGVyXFxhYnItY29udHJvbGxlci5qcyIsInNyY1xcY29udHJvbGxlclxcYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXGF1ZGlvLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXGJ1ZmZlci1jb250cm9sbGVyLmpzIiwic3JjXFxjb250cm9sbGVyXFxjYXAtbGV2ZWwtY29udHJvbGxlci5qcyIsInNyY1xcY29udHJvbGxlclxcZnBzLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXGlkMy10cmFjay1jb250cm9sbGVyLmpzIiwic3JjXFxjb250cm9sbGVyXFxsZXZlbC1jb250cm9sbGVyLmpzIiwic3JjXFxjb250cm9sbGVyXFxzdHJlYW0tY29udHJvbGxlci5qcyIsInNyY1xcY29udHJvbGxlclxcc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXHN1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXHRpbWVsaW5lLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNyeXB0XFxhZXMtY3J5cHRvLmpzIiwic3JjXFxjcnlwdFxcYWVzLWRlY3J5cHRvci5qcyIsInNyY1xcY3J5cHRcXGRlY3J5cHRlci5qcyIsInNyY1xcY3J5cHRcXGZhc3QtYWVzLWtleS5qcyIsInNyY1xcZGVtdXhcXGFhY2RlbXV4ZXIuanMiLCJzcmNcXGRlbXV4XFxhZHRzLmpzIiwic3JjXFxkZW11eFxcZGVtdXhlci1pbmxpbmUuanMiLCJzcmNcXGRlbXV4XFxkZW11eGVyLXdvcmtlci5qcyIsInNyY1xcZGVtdXhcXGRlbXV4ZXIuanMiLCJzcmNcXGRlbXV4XFxleHAtZ29sb21iLmpzIiwic3JjXFxkZW11eFxcaWQzLmpzIiwic3JjXFxkZW11eFxcbXAzZGVtdXhlci5qcyIsInNyY1xcZGVtdXhcXG1wNGRlbXV4ZXIuanMiLCJzcmNcXGRlbXV4XFxtcGVnYXVkaW8uanMiLCJzcmNcXGRlbXV4XFxzYW1wbGUtYWVzLmpzIiwic3JjXFxkZW11eFxcdHNkZW11eGVyLmpzIiwic3JjXFxlcnJvcnMuanMiLCJzcmNcXGV2ZW50LWhhbmRsZXIuanMiLCJzcmNcXGV2ZW50cy5qcyIsInNyY1xcaGVscGVyXFxhYWMuanMiLCJzcmNcXGhlbHBlclxcYnVmZmVyLWhlbHBlci5qcyIsInNyY1xcaGVscGVyXFxsZXZlbC1oZWxwZXIuanMiLCJzcmNcXGhscy5qcyIsInNyY1xcaW5kZXguanMiLCJzcmNcXGxvYWRlclxcZnJhZ21lbnQtbG9hZGVyLmpzIiwic3JjXFxsb2FkZXJcXGtleS1sb2FkZXIuanMiLCJzcmNcXGxvYWRlclxccGxheWxpc3QtbG9hZGVyLmpzIiwic3JjXFxyZW11eFxcbXA0LWdlbmVyYXRvci5qcyIsInNyY1xccmVtdXhcXG1wNC1yZW11eGVyLmpzIiwic3JjXFxyZW11eFxccGFzc3Rocm91Z2gtcmVtdXhlci5qcyIsInNyY1xcdXRpbHNcXGF0dHItbGlzdC5qcyIsInNyY1xcdXRpbHNcXGJpbmFyeS1zZWFyY2guanMiLCJzcmNcXHV0aWxzXFxjZWEtNjA4LXBhcnNlci5qcyIsInNyY1xcdXRpbHNcXGN1ZXMuanMiLCJzcmNcXHV0aWxzXFxld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IuanMiLCJzcmNcXHV0aWxzXFxld21hLmpzIiwic3JjXFx1dGlsc1xcbG9nZ2VyLmpzIiwic3JjXFx1dGlsc1xcdGltZVJhbmdlcy5qcyIsInNyY1xcdXRpbHNcXHZ0dGN1ZS5qcyIsInNyY1xcdXRpbHNcXHZ0dHBhcnNlci5qcyIsInNyY1xcdXRpbHNcXHdlYnZ0dC1wYXJzZXIuanMiLCJzcmNcXHV0aWxzXFx4aHItbG9hZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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anMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE4MDhcclxuXHJcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuKGZ1bmN0aW9uKHJvb3QpIHsgXHJcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcblxyXG4gIHZhciBVUkxfUkVHRVggPSAvXigoPzpbXlxcLzs/I10rOik/KShcXC9cXC9bXlxcL1xcOz8jXSopPyguKj8pPz8oOy4qPyk/KFxcPy4qPyk/KCMuKj8pPyQvO1xyXG4gIHZhciBGSVJTVF9TRUdNRU5UX1JFR0VYID0gL14oW15cXC87PyNdKikoLiopJC87XHJcbiAgdmFyIFNMQVNIX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC4oPz1cXC8pL2c7XHJcbiAgdmFyIFNMQVNIX0RPVF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKS4qPyg/PVxcLykvZztcclxuXHJcbiAgdmFyIFVSTFRvb2xraXQgPSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgLy8gSWYgb3B0cy5hbHdheXNOb3JtYWxpemUgaXMgdHJ1ZSB0aGVuIHRoZSBwYXRoIHdpbGwgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgZXZlbiB3aGVuIGl0IHN0YXJ0cyB3aXRoIC8gb3IgLy9cclxuICAgIC8vIEUuZ1xyXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IGZhbHNlIChkZWZhdWx0LCBzcGVjIGNvbXBsaWFudClcclxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2YvLi4vZ1xyXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKGRlZmF1bHQsIG5vdCBzcGVjIGNvbXBsaWFudClcclxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2dcclxuICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XHJcbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxyXG4gICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XHJcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xyXG4gICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XHJcbiAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxyXG4gICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcclxuICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXHJcbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSB0aGlzLnBhcnNlVVJMKGJhc2VVUkwpO1xyXG4gICAgICAgIGlmICghYmFzZVBhcnRzKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGgpO1xyXG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSB0aGlzLnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcclxuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgcmVsYXRpdmUgVVJMLicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnNjaGVtZSkge1xyXG4gICAgICAgIC8vIDJiKSBJZiB0aGUgZW1iZWRkZWQgVVJMIHN0YXJ0cyB3aXRoIGEgc2NoZW1lIG5hbWUsIGl0IGlzXHJcbiAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cclxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVsYXRpdmVVUkw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbGF0aXZlUGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpO1xyXG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKHJlbGF0aXZlUGFydHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBiYXNlUGFydHMgPSB0aGlzLnBhcnNlVVJMKGJhc2VVUkwpO1xyXG4gICAgICBpZiAoIWJhc2VQYXJ0cykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghYmFzZVBhcnRzLm5ldExvYyAmJiBiYXNlUGFydHMucGF0aCAmJiBiYXNlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XHJcbiAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXHJcbiAgICAgICAgLy8gVGhpcyBjYXVzZXMgJ2V4YW1wbGUuY29tL2EnIHRvIGJlIGhhbmRsZWQgYXMgJy8vZXhhbXBsZS5jb20vYScgaW5zdGVhZCBvZiAnL2V4YW1wbGUuY29tL2EnXHJcbiAgICAgICAgdmFyIHBhdGhQYXJ0cyA9IEZJUlNUX1NFR01FTlRfUkVHRVguZXhlYyhiYXNlUGFydHMucGF0aCk7XHJcbiAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcclxuICAgICAgICBiYXNlUGFydHMucGF0aCA9IHBhdGhQYXJ0c1syXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcclxuICAgICAgICBiYXNlUGFydHMucGF0aCA9ICcvJztcclxuICAgICAgfVxyXG4gICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcclxuICAgICAgICAvLyAyYykgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBzY2hlbWUgb2ZcclxuICAgICAgICAvLyB0aGUgYmFzZSBVUkwuXHJcbiAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxyXG4gICAgICAgIG5ldExvYzogcmVsYXRpdmVQYXJ0cy5uZXRMb2MsXHJcbiAgICAgICAgcGF0aDogbnVsbCxcclxuICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxyXG4gICAgICAgIHF1ZXJ5OiByZWxhdGl2ZVBhcnRzLnF1ZXJ5LFxyXG4gICAgICAgIGZyYWdtZW50OiByZWxhdGl2ZVBhcnRzLmZyYWdtZW50XHJcbiAgICAgIH07XHJcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5uZXRMb2MpIHtcclxuICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xyXG4gICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XHJcbiAgICAgICAgLy8gKGlmIGFueSkgb2YgdGhlIGJhc2UgVVJMLlxyXG4gICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcclxuICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXHJcbiAgICAgICAgLy8gcGF0aCBpcyBub3QgcmVsYXRpdmUgYW5kIHdlIHNraXAgdG8gU3RlcCA3LlxyXG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xyXG4gICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcclxuICAgICAgICAgICAgLy8gNSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIGVtcHR5IChhbmQgbm90IHByZWNlZGVkIGJ5IGFcclxuICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcclxuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XHJcbiAgICAgICAgICAgIC8vIDVhKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHBhcmFtcz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXHJcbiAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2VcclxuICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxyXG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xyXG4gICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cclxuICAgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxxdWVyeT4gb2YgdGhlIGJhc2VcclxuICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxyXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5xdWVyeSA9IGJhc2VQYXJ0cy5xdWVyeTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcclxuICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xyXG4gICAgICAgICAgICAvLyBzbGFzaCBpcyBwcmVzZW50KSBpcyByZW1vdmVkIGFuZCB0aGUgZW1iZWRkZWQgVVJMJ3MgcGF0aCBpc1xyXG4gICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXHJcbiAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xyXG4gICAgICAgICAgICB2YXIgbmV3UGF0aCA9IGJhc2VVUkxQYXRoLnN1YnN0cmluZygwLCBiYXNlVVJMUGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZVBhcnRzLnBhdGg7XHJcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChuZXdQYXRoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xyXG4gICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IG9wdHMuYWx3YXlzTm9ybWFsaXplID8gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCkgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XHJcbiAgICB9LFxyXG4gICAgcGFyc2VVUkw6IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xyXG4gICAgICBpZiAoIXBhcnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzY2hlbWU6IHBhcnRzWzFdIHx8ICcnLFxyXG4gICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXHJcbiAgICAgICAgcGF0aDogcGFydHNbM10gfHwgJycsXHJcbiAgICAgICAgcGFyYW1zOiBwYXJ0c1s0XSB8fCAnJyxcclxuICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXHJcbiAgICAgICAgZnJhZ21lbnQ6IHBhcnRzWzZdIHx8ICcnXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgbm9ybWFsaXplUGF0aDogZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXHJcbiAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcclxuICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxyXG4gICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cclxuICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcclxuICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxyXG4gICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XHJcbiAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXHJcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cclxuICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcclxuICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXHJcbiAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cclxuICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxyXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxyXG4gICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXHJcbiAgICAgIHdoaWxlIChwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGgpIHt9IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xyXG4gICAgfSxcclxuICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbihwYXJ0cykge1xyXG4gICAgICByZXR1cm4gcGFydHMuc2NoZW1lICsgcGFydHMubmV0TG9jICsgcGFydHMucGF0aCArIHBhcnRzLnBhcmFtcyArIHBhcnRzLnF1ZXJ5ICsgcGFydHMuZnJhZ21lbnQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuICBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XHJcbiAgZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVVJMVG9vbGtpdDsgfSk7XHJcbiAgZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcbiAgICBleHBvcnRzW1wiVVJMVG9vbGtpdFwiXSA9IFVSTFRvb2xraXQ7XHJcbiAgZWxzZVxyXG4gICAgcm9vdFtcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xyXG59KSh0aGlzKTtcclxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuIiwidmFyIGJ1bmRsZUZuID0gYXJndW1lbnRzWzNdO1xudmFyIHNvdXJjZXMgPSBhcmd1bWVudHNbNF07XG52YXIgY2FjaGUgPSBhcmd1bWVudHNbNV07XG5cbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgd2tleTtcbiAgICB2YXIgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgIHZhciBleHAgPSBjYWNoZVtrZXldLmV4cG9ydHM7XG4gICAgICAgIC8vIFVzaW5nIGJhYmVsIGFzIGEgdHJhbnNwaWxlciB0byB1c2UgZXNtb2R1bGUsIHRoZSBleHBvcnQgd2lsbCBhbHdheXNcbiAgICAgICAgLy8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGRlZmF1bHQgZXhwb3J0IGFzIGEgcHJvcGVydHkgb2YgaXQuIFRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgZXhpc3RpbmcgYXBpIGFuZCBiYWJlbCBlc21vZHVsZSBleHBvcnRzIGFyZSBib3RoIHN1cHBvcnRlZCB3ZVxuICAgICAgICAvLyBjaGVjayBmb3IgYm90aFxuICAgICAgICBpZiAoZXhwID09PSBmbiB8fCBleHAgJiYgZXhwLmRlZmF1bHQgPT09IGZuKSB7XG4gICAgICAgICAgICB3a2V5ID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXdrZXkpIHtcbiAgICAgICAgd2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgd2NhY2hlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgICAgIHdjYWNoZVtrZXldID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXNbd2tleV0gPSBbXG4gICAgICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnLCdtb2R1bGUnLCdleHBvcnRzJ10sICcoJyArIGZuICsgJykoc2VsZiknKSxcbiAgICAgICAgICAgIHdjYWNoZVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YXIgc2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuXG4gICAgdmFyIHNjYWNoZSA9IHt9OyBzY2FjaGVbd2tleV0gPSB3a2V5O1xuICAgIHNvdXJjZXNbc2tleV0gPSBbXG4gICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZSddLCAoXG4gICAgICAgICAgICAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlXG4gICAgICAgICAgICAvLyBleHBvcnRzXG4gICAgICAgICAgICAndmFyIGYgPSByZXF1aXJlKCcgKyBzdHJpbmdpZnkod2tleSkgKyAnKTsnICtcbiAgICAgICAgICAgICcoZi5kZWZhdWx0ID8gZi5kZWZhdWx0IDogZikoc2VsZik7J1xuICAgICAgICApKSxcbiAgICAgICAgc2NhY2hlXG4gICAgXTtcblxuICAgIHZhciB3b3JrZXJTb3VyY2VzID0ge307XG4gICAgcmVzb2x2ZVNvdXJjZXMoc2tleSk7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlU291cmNlcyhrZXkpIHtcbiAgICAgICAgd29ya2VyU291cmNlc1trZXldID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBkZXBQYXRoIGluIHNvdXJjZXNba2V5XVsxXSkge1xuICAgICAgICAgICAgdmFyIGRlcEtleSA9IHNvdXJjZXNba2V5XVsxXVtkZXBQYXRoXTtcbiAgICAgICAgICAgIGlmICghd29ya2VyU291cmNlc1tkZXBLZXldKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVNvdXJjZXMoZGVwS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcmMgPSAnKCcgKyBidW5kbGVGbiArICcpKHsnXG4gICAgICAgICsgT2JqZWN0LmtleXMod29ya2VyU291cmNlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoa2V5KSArICc6WydcbiAgICAgICAgICAgICAgICArIHNvdXJjZXNba2V5XVswXVxuICAgICAgICAgICAgICAgICsgJywnICsgc3RyaW5naWZ5KHNvdXJjZXNba2V5XVsxXSkgKyAnXSdcbiAgICAgICAgICAgIDtcbiAgICAgICAgfSkuam9pbignLCcpXG4gICAgICAgICsgJ30se30sWycgKyBzdHJpbmdpZnkoc2tleSkgKyAnXSknXG4gICAgO1xuXG4gICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcblxuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iOyB9XG4gICAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVXJsKTtcbiAgICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsO1xuICAgIHJldHVybiB3b3JrZXI7XG59O1xuIiwiLyoqXHJcbiAqIEhMUyBjb25maWdcclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBBYnJDb250cm9sbGVyIGZyb20gICAgJy4vY29udHJvbGxlci9hYnItY29udHJvbGxlcic7XHJcbmltcG9ydCBCdWZmZXJDb250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgQ2FwTGV2ZWxDb250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgRlBTQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgWGhyTG9hZGVyIGZyb20gJy4vdXRpbHMveGhyLWxvYWRlcic7XHJcbi8vaW1wb3J0IEZldGNoTG9hZGVyIGZyb20gJy4vdXRpbHMvZmV0Y2gtbG9hZGVyJztcclxuLy8jaWYgYWx0YXVkaW9cclxuaW1wb3J0IEF1ZGlvVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyJztcclxuaW1wb3J0IEF1ZGlvU3RyZWFtQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyJztcclxuLy8jZW5kaWZcclxuXHJcbi8vI2lmIHN1YnRpdGxlXHJcbmltcG9ydCBDdWVzIGZyb20gJy4vdXRpbHMvY3Vlcyc7XHJcbmltcG9ydCBUaW1lbGluZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXInO1xyXG4vLyNlbmRpZlxyXG5cclxuZXhwb3J0IHZhciBobHNEZWZhdWx0Q29uZmlnID0ge1xyXG4gICAgICBhdXRvU3RhcnRMb2FkOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxyXG4gICAgICBzdGFydFBvc2l0aW9uOiAtMSwgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxyXG4gICAgICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLCAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxyXG4gICAgICBkZWJ1ZzogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBsb2dnZXJcclxuICAgICAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLCAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcclxuICAgICAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGZhbHNlLCAgICAgICAgICAgIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcclxuICAgICAgaW5pdGlhbExpdmVNYW5pZmVzdFNpemU6IDEsICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbWF4QnVmZmVyTGVuZ3RoOiAzMCwgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbWF4QnVmZmVyU2l6ZTogNjAgKiAxMDAwICogMTAwMCwgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbWF4QnVmZmVySG9sZTogMC41LCAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbWF4U2Vla0hvbGU6IDIsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbG93QnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDAuNSwgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiAzLCAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbnVkZ2VPZmZzZXQ6IDAuMSwgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbnVkZ2VNYXhSZXRyeSA6IDMsICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogMC4yLCAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OjMsICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSwgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbGl2ZVN5bmNEdXJhdGlvbjogdW5kZWZpbmVkLCAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbjogdW5kZWZpbmVkLCAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgZW5hYmxlV29ya2VyOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgZGVtdXhlclxyXG4gICAgICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSwgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBkZWNyeXB0ZXJcclxuICAgICAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsICAgICAgICAgIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXHJcbiAgICAgIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLCAgICAgICAgICAgICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gICAgICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLCAgICAgICAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcclxuICAgICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXHJcbiAgICAgIHN0YXJ0TGV2ZWw6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGxldmVsLWNvbnRyb2xsZXJcclxuICAgICAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsICAgICAgICAgICAgIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXHJcbiAgICAgIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LCAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gICAgICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLCAgICAgICAgICAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcclxuICAgICAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgICAgIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXHJcbiAgICAgIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxyXG4gICAgICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LCAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcclxuICAgICAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxMDAwLCAgICAgICAgICAgIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXHJcbiAgICAgIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgICAgICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxyXG4gICAgICBmcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ6IDMsICAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxyXG4gICAgICBzdGFydEZyYWdQcmVmZXRjaDogZmFsc2UsICAgICAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxyXG4gICAgICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCwgICAgICAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxyXG4gICAgICBmcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZDogMC4yLCAgICAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxyXG4gICAgICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLCAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxyXG4gICAgICBsb2FkZXI6IFhockxvYWRlcixcclxuICAgICAgLy9sb2FkZXI6IEZldGNoTG9hZGVyLFxyXG4gICAgICBmTG9hZGVyOiB1bmRlZmluZWQsXHJcbiAgICAgIHBMb2FkZXI6IHVuZGVmaW5lZCxcclxuICAgICAgeGhyU2V0dXA6IHVuZGVmaW5lZCxcclxuICAgICAgZmV0Y2hTZXR1cDogdW5kZWZpbmVkLFxyXG4gICAgICBhYnJDb250cm9sbGVyOiBBYnJDb250cm9sbGVyLFxyXG4gICAgICBidWZmZXJDb250cm9sbGVyOiBCdWZmZXJDb250cm9sbGVyLFxyXG4gICAgICBjYXBMZXZlbENvbnRyb2xsZXI6IENhcExldmVsQ29udHJvbGxlcixcclxuICAgICAgZnBzQ29udHJvbGxlcjogRlBTQ29udHJvbGxlcixcclxuLy8jaWYgYWx0YXVkaW9cclxuICAgICAgYXVkaW9TdHJlYW1Db250cm9sbGVyOiBBdWRpb1N0cmVhbUNvbnRyb2xsZXIsXHJcbiAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyIDogQXVkaW9UcmFja0NvbnRyb2xsZXIsXHJcbi8vI2VuZGlmXHJcbi8vI2lmIHN1YnRpdGxlXHJcbiAgICAgIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLFxyXG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsXHJcbiAgICAgIHRpbWVsaW5lQ29udHJvbGxlcjogVGltZWxpbmVDb250cm9sbGVyLFxyXG4gICAgICBjdWVIYW5kbGVyOiBDdWVzLFxyXG4gICAgICBlbmFibGVDRUE3MDhDYXB0aW9uczogdHJ1ZSwgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcclxuICAgICAgZW5hYmxlV2ViVlRUOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXHJcbiAgICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiAnRW5nbGlzaCcsICAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxyXG4gICAgICBjYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGU6ICdlbicsICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXHJcbiAgICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhYmVsOiAnU3BhbmlzaCcsICAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxyXG4gICAgICBjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6ICdlcycsICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcclxuLy8jZW5kaWZcclxuICAgICAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogZmFsc2UsICAgICAgICAgICAgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxyXG4gICAgICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiB0cnVlLCAgICAgICAvLyB1c2VkIGJ5IHRzLWRlbXV4ZXJcclxuICAgICAgYWJyRXdtYUZhc3RMaXZlOiAzLCAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gICAgICBhYnJFd21hU2xvd0xpdmU6IDksICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXHJcbiAgICAgIGFickV3bWFGYXN0Vm9EOiAzLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICAgICAgYWJyRXdtYVNsb3dWb0Q6IDksICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gICAgICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsIC8vIDUwMCBrYnBzICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXHJcbiAgICAgIGFickJhbmRXaWR0aEZhY3RvciA6IDAuOTUsICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICAgICAgYWJyQmFuZFdpZHRoVXBGYWN0b3IgOiAwLjcsICAgICAgICAgICAgICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gICAgICBhYnJNYXhXaXRoUmVhbEJpdHJhdGUgOiBmYWxzZSwgICAgICAgICAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXHJcbiAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA6IDQsICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICAgICAgbWF4TG9hZGluZ0RlbGF5IDogNCwgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gICAgICBtaW5BdXRvQml0cmF0ZTogMCAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGhsc1xyXG4gICAgfTtcclxuIiwiLypcclxuICogc2ltcGxlIEFCUiBDb250cm9sbGVyXHJcbiAqICAtIGNvbXB1dGUgbmV4dCBsZXZlbCBiYXNlZCBvbiBsYXN0IGZyYWdtZW50IGJ3IGhldXJpc3RpY3NcclxuICogIC0gaW1wbGVtZW50IGFuIGFiYW5kb24gcnVsZXMgdHJpZ2dlcmVkIGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBhbmQgaWYgY29tcHV0ZWQgYncgc2hvd3MgdGhhdCB3ZSByaXNrIGJ1ZmZlciBzdGFsbGluZ1xyXG4gKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcclxuaW1wb3J0IHtFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgRXdtYUJhbmRXaWR0aEVzdGltYXRvciBmcm9tICcuLi91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3InO1xyXG5cclxuY2xhc3MgQWJyQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLCBFdmVudC5GUkFHX0xPQURJTkcsXHJcbiAgICAgICAgICAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxyXG4gICAgICAgICAgICAgICBFdmVudC5GUkFHX0JVRkZFUkVELFxyXG4gICAgICAgICAgICAgICBFdmVudC5FUlJPUik7XHJcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAwO1xyXG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xyXG4gICAgdGhpcy5obHMgPSBobHM7XHJcbiAgICB0aGlzLm9uQ2hlY2sgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XHJcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssIDEwMCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gbGF6eSBpbml0IG9mIGJ3IEVzdGltYXRvciwgcmF0aW9uYWxlIGlzIHRoYXQgd2UgdXNlIGRpZmZlcmVudCBwYXJhbXMgZm9yIExpdmUvVm9EXHJcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3Igc3RyZWFtIG1hbmlmZXN0IC8gcGxheWxpc3QgdHlwZSB0byBpbnN0YW50aWF0ZSBpdC5cclxuICAgICAgaWYgKCF0aGlzLl9id0VzdGltYXRvcikge1xyXG4gICAgICAgIGxldCBobHMgPSB0aGlzLmhscyxcclxuICAgICAgICAgICAgbGV2ZWwgPSBkYXRhLmZyYWcubGV2ZWwsXHJcbiAgICAgICAgICAgIGlzTGl2ZSA9IGhscy5sZXZlbHNbbGV2ZWxdLmRldGFpbHMubGl2ZSxcclxuICAgICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcclxuICAgICAgICAgICAgZXdtYUZhc3QsIGV3bWFTbG93O1xyXG5cclxuICAgICAgICBpZiAoaXNMaXZlKSB7XHJcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdExpdmU7XHJcbiAgICAgICAgICBld21hU2xvdyA9IGNvbmZpZy5hYnJFd21hU2xvd0xpdmU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0Vm9EO1xyXG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dWb0Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2J3RXN0aW1hdG9yID0gbmV3IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IoaGxzLGV3bWFTbG93LGV3bWFGYXN0LGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9hYmFuZG9uUnVsZXNDaGVjaygpIHtcclxuICAgIC8qXHJcbiAgICAgIG1vbml0b3IgZnJhZ21lbnQgcmV0cmlldmFsIHRpbWUuLi5cclxuICAgICAgd2UgY29tcHV0ZSBleHBlY3RlZCB0aW1lIG9mIGFycml2YWwgb2YgdGhlIGNvbXBsZXRlIGZyYWdtZW50LlxyXG4gICAgICB3ZSBjb21wYXJlIGl0IHRvIGV4cGVjdGVkIHRpbWUgb2YgYnVmZmVyIHN0YXJ2YXRpb25cclxuICAgICovXHJcbiAgICBsZXQgaGxzID0gdGhpcy5obHMsIHYgPSBobHMubWVkaWEsZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsIGxvYWRlciA9IGZyYWcubG9hZGVyLCBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xyXG5cclxuICAgIC8vIGlmIGxvYWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgb3IgbG9hZGluZyBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cclxuICAgIGlmKCFsb2FkZXIgfHwgKCBsb2FkZXIuc3RhdHMgJiYgbG9hZGVyLnN0YXRzLmFib3J0ZWQpKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCdmcmFnIGxvYWRlciBkZXN0cm95IG9yIGFib3J0ZWQsIGRpc2FybSBhYmFuZG9uUnVsZXMnKTtcclxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBzdGF0cyA9IGxvYWRlci5zdGF0cztcclxuICAgIC8qIG9ubHkgbW9uaXRvciBmcmFnIHJldHJpZXZhbCB0aW1lIGlmXHJcbiAgICAodmlkZW8gbm90IHBhdXNlZCBPUiBmaXJzdCBmcmFnbWVudCBiZWluZyBsb2FkZWQocmVhZHkgc3RhdGUgPT09IEhBVkVfTk9USElORyA9IDApKSBBTkQgYXV0b3N3aXRjaGluZyBlbmFibGVkIEFORCBub3QgbG93ZXN0IGxldmVsICg9PiBtZWFucyB0aGF0IHdlIGhhdmUgc2V2ZXJhbCBsZXZlbHMpICovXHJcbiAgICBpZiAodiAmJiAoKCF2LnBhdXNlZCAmJiAodi5wbGF5YmFja1JhdGUgIT09IDApKSB8fCAhdi5yZWFkeVN0YXRlKSAmJiBmcmFnLmF1dG9MZXZlbCAmJiBmcmFnLmxldmVsKSB7XHJcbiAgICAgIGxldCByZXF1ZXN0RGVsYXkgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXRzLnRyZXF1ZXN0LFxyXG4gICAgICAgICAgcGxheWJhY2tSYXRlID0gTWF0aC5hYnModi5wbGF5YmFja1JhdGUpO1xyXG4gICAgICAvLyBtb25pdG9yIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MgYWZ0ZXIgaGFsZiBvZiBleHBlY3RlZCBmcmFnbWVudCBkdXJhdGlvbix0byBzdGFiaWxpemUgYml0cmF0ZVxyXG4gICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XHJcbiAgICAgICAgbGV0IGxldmVscyA9IGhscy5sZXZlbHMsXHJcbiAgICAgICAgICAgIGxvYWRSYXRlID0gTWF0aC5tYXgoMSwgc3RhdHMuYncgPyBzdGF0cy5idyAvIDggOiBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gcmVxdWVzdERlbGF5KSwgLy8gYnl0ZS9zOyBhdCBsZWFzdCAxIGJ5dGUvcyB0byBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvXHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZXhwZWN0ZWQgZnJhZ21lbnQgbGVuZ3RoIHVzaW5nIGZyYWcgZHVyYXRpb24gYW5kIGxldmVsIGJpdHJhdGUuIGFsc28gZW5zdXJlIHRoYXQgZXhwZWN0ZWQgbGVuIGlzIGd0ZSB0aGFuIGFscmVhZHkgbG9hZGVkIHNpemVcclxuICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF0sXHJcbiAgICAgICAgICAgIGxldmVsQml0cmF0ZSA9IGxldmVsLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWwucmVhbEJpdHJhdGUsbGV2ZWwuYml0cmF0ZSkgOiBsZXZlbC5iaXRyYXRlLFxyXG4gICAgICAgICAgICBleHBlY3RlZExlbiA9IHN0YXRzLnRvdGFsID8gc3RhdHMudG90YWwgOiBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAqIGxldmVsQml0cmF0ZSAvIDgpKSxcclxuICAgICAgICAgICAgcG9zID0gdi5jdXJyZW50VGltZSxcclxuICAgICAgICAgICAgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlLFxyXG4gICAgICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odixwb3MsaGxzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xyXG4gICAgICAgIC8vIGNvbnNpZGVyIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbmx5IGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBBTkRcclxuICAgICAgICAvLyB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nIGN1cnJlbnQgZnJhZ21lbnQgaXMgYmlnZ2VyIHRoYW4gYnVmZmVyIHN0YXJ2YXRpb24gZGVsYXlcclxuICAgICAgICAvLyBpZSBpZiB3ZSByaXNrIGJ1ZmZlciBzdGFydmF0aW9uIGlmIGJ3IGRvZXMgbm90IGluY3JlYXNlIHF1aWNrbHlcclxuICAgICAgICBpZiAoKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA8ICgyICogZnJhZy5kdXJhdGlvbiAvIHBsYXliYWNrUmF0ZSkpICYmIChmcmFnTG9hZGVkRGVsYXkgPiBidWZmZXJTdGFydmF0aW9uRGVsYXkpKSB7XHJcbiAgICAgICAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LCBuZXh0TG9hZExldmVsO1xyXG4gICAgICAgICAgLy8gbGV0cyBpdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBiaWdnZXN0IG9uZSB0aGF0IGNvdWxkIGF2b2lkIHJlYnVmZmVyaW5nXHJcbiAgICAgICAgICAvLyB3ZSBzdGFydCBmcm9tIGN1cnJlbnQgbGV2ZWwgLSAxIGFuZCB3ZSBzdGVwIGRvd24gLCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hpbmcgbGV2ZWxcclxuICAgICAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxIDsgbmV4dExvYWRMZXZlbCA+IG1pbkF1dG9MZXZlbCA7IG5leHRMb2FkTGV2ZWwtLSkge1xyXG4gICAgICAgICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXHJcbiAgICAgICAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXHJcbiAgICAgICAgICAgIC8vIDggPSBiaXRzIHBlciBieXRlIChicHMvQnBzKVxyXG4gICAgICAgICAgICBsZXQgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSxsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSkgOiBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZTtcclxuICAgICAgICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gZnJhZy5kdXJhdGlvbiAqIGxldmVsTmV4dEJpdHJhdGUgLyAoOCAqIDAuOCAqIGxvYWRSYXRlKTtcclxuICAgICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xyXG4gICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbG93ZXIgbGV2ZWwgdGhhdCBiZSByZWJ1ZmZlcmluZyBmcmVlIHdpdGggY3VycmVudCBlc3RpbWF0ZWQgYncgIVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBvbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBuZXcgZnJhZ21lbnQgYXQgbG93ZXN0IGxldmVsIGluc3RlYWRcclxuICAgICAgICAgIC8vIG9mIGZpbmlzaGluZyBsb2FkaW5nIGN1cnJlbnQgb25lIC4uLlxyXG4gICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGZyYWdMb2FkZWREZWxheSkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgbG9hZGluZyB0b28gc2xvdywgYWJvcnQgZnJhZ21lbnQgbG9hZGluZyBhbmQgc3dpdGNoIHRvIGxldmVsICR7bmV4dExvYWRMZXZlbH06ZnJhZ0xvYWRlZERlbGF5WyR7bmV4dExvYWRMZXZlbH1dPGZyYWdMb2FkZWREZWxheVske2ZyYWcubGV2ZWwtMX1dO2J1ZmZlclN0YXJ2YXRpb25EZWxheToke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDEpfTwke2ZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDEpfToke2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDEpfWApO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSBuZXh0IGxvYWQgbGV2ZWwgaW4gYXV0byBtb2RlXHJcbiAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGJ3IGVzdGltYXRlIGZvciB0aGlzIGZyYWdtZW50IGJlZm9yZSBjYW5jZWxsaW5nIGxvYWQgKHRoaXMgd2lsbCBoZWxwIHJlZHVjaW5nIHRoZSBidylcclxuICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKHJlcXVlc3REZWxheSxzdGF0cy5sb2FkZWQpO1xyXG4gICAgICAgICAgICAvL2Fib3J0IGZyYWdtZW50IGxvYWRpbmdcclxuICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgIC8vIHN0b3AgYWJhbmRvbiBydWxlcyB0aW1lclxyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcclxuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7ZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nICYmICFpc05hTihmcmFnLnNuKSkge1xyXG4gICAgICAvLyBzdG9wIG1vbml0b3JpbmcgYncgb25jZSBmcmFnIGxvYWRlZFxyXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcclxuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXHJcbiAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IGZyYWcubGV2ZWw7XHJcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXHJcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcclxuXHJcbiAgICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXHJcbiAgICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XHJcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XHJcbiAgICAgICAgbGV0IGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgZGF0YS5zdGF0cy5sb2FkZWQ7XHJcbiAgICAgICAgbGV0IGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZGF0YS5mcmFnLmR1cmF0aW9uO1xyXG4gICAgICAgIGxldmVsLmxvYWRlZCA9IHsgYnl0ZXMgOiBsb2FkZWRCeXRlcywgZHVyYXRpb24gOiBsb2FkZWREdXJhdGlvbiB9O1xyXG4gICAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4KmxvYWRlZEJ5dGVzL2xvYWRlZER1cmF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCxcclxuICAgICAgaWYgKGRhdGEuZnJhZy5iaXRyYXRlVGVzdCkge1xyXG4gICAgICAgIGxldCBzdGF0cyA9IGRhdGEuc3RhdHM7XHJcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHN0YXRzLnRsb2FkO1xyXG4gICAgICAgIHRoaXMub25GcmFnQnVmZmVyZWQoZGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRnJhZ0J1ZmZlcmVkKGRhdGEpIHtcclxuICAgIHZhciBzdGF0cyA9IGRhdGEuc3RhdHMsIGZyYWcgPSBkYXRhLmZyYWc7XHJcbiAgICAvLyBvbmx5IHVwZGF0ZSBzdGF0cyBvbiBmaXJzdCBmcmFnIGJ1ZmZlcmluZ1xyXG4gICAgLy8gaWYgc2FtZSBmcmFnIGlzIGxvYWRlZCBtdWx0aXBsZSB0aW1lcywgaXQgbWlnaHQgYmUgaW4gYnJvd3NlciBjYWNoZSwgYW5kIGxvYWRlZCBxdWlja2x5XHJcbiAgICAvLyBhbmQgbGVhZGluZyB0byB3cm9uZyBidyBlc3RpbWF0aW9uXHJcbiAgICAvLyBvbiBiaXRyYXRlIHRlc3QsIGFsc28gb25seSB1cGRhdGUgc3RhdHMgb25jZSAoaWYgdGxvYWQgPSB0YnVmZmVyZWQgPT0gb24gRlJBR19MT0FERUQpXHJcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCAhPT0gdHJ1ZSAmJiBmcmFnLmxvYWRDb3VudGVyID09PSAxICYmIGZyYWcudHlwZSA9PT0gJ21haW4nICYmICFpc05hTihmcmFnLnNuKSAmJiAoKCFmcmFnLmJpdHJhdGVUZXN0IHx8IHN0YXRzLnRsb2FkID09PSBzdGF0cy50YnVmZmVyZWQpKSkge1xyXG4gICAgICAvLyB1c2UgdHBhcnNlZC10cmVxdWVzdCBpbnN0ZWFkIG9mIHRidWZmZXJlZC10cmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZzsgcmF0aW9uYWxlIGlzIHRoYXQgIGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWRcclxuICAgICAgLy8gaW4gY2FzZSB3ZSB1c2UgY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoIHdoaWxlIG1lZGlhIGlzIG5vdCBhdHRhY2hlZCB5ZXQsIGZyYWdtZW50IG1pZ2h0IGJlIHBhcnNlZCB3aGlsZSBtZWRpYSBub3QgYXR0YWNoZWQgeWV0LCBidXQgaXQgd2lsbCBvbmx5IGJlIGJ1ZmZlcmVkIG9uIG1lZGlhIGF0dGFjaGVkXHJcbiAgICAgIC8vIGFzIGEgY29uc2VxdWVuY2UgaXQgY291bGQgaGFwcGVuIHJlYWxseSBsYXRlIGluIHRoZSBwcm9jZXNzLiBtZWFuaW5nIHRoYXQgYXBwZW5kaW5nIGR1cmF0aW9uIG1pZ2h0IGFwcGVhcnMgaHVnZSAuLi4gbGVhZGluZyB0byB1bmRlcmVzdGltYXRlZCB0aHJvdWdocHV0IGVzdGltYXRpb25cclxuICAgICAgbGV0IGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zID0gc3RhdHMudHBhcnNlZCAtIHN0YXRzLnRyZXF1ZXN0O1xyXG4gICAgICBsb2dnZXIubG9nKGBsYXRlbmN5L2xvYWRpbmcvcGFyc2luZy9hcHBlbmQva2Jwczoke01hdGgucm91bmQoc3RhdHMudGZpcnN0LXN0YXRzLnRyZXF1ZXN0KX0vJHtNYXRoLnJvdW5kKHN0YXRzLnRsb2FkLXN0YXRzLnRmaXJzdCl9LyR7TWF0aC5yb3VuZChzdGF0cy50cGFyc2VkLXN0YXRzLnRsb2FkKX0vJHtNYXRoLnJvdW5kKHN0YXRzLnRidWZmZXJlZC1zdGF0cy50cGFyc2VkKX0vJHtNYXRoLnJvdW5kKDgqc3RhdHMubG9hZGVkLyhzdGF0cy50YnVmZmVyZWQtc3RhdHMudHJlcXVlc3QpKX1gKTtcclxuICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zLHN0YXRzLmxvYWRlZCk7XHJcbiAgICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLl9id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xyXG4gICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCwgKGhscy5zdGFydExldmVsID0gLTEpLCBzdG9yZSBiaXRyYXRlIHRlc3QgZGVsYXkgZHVyYXRpb25cclxuICAgICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcclxuICAgICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcy8xMDAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRXJyb3IoZGF0YSkge1xyXG4gICAgLy8gc3RvcCB0aW1lciBpbiBjYXNlIG9mIGZyYWcgbG9hZGluZyBlcnJvclxyXG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxyXG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiBjbGVhclRpbWVyKCkge1xyXG4gICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICB9XHJcbiB9XHJcblxyXG4gIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcclxuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcclxuICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuX25leHRBdXRvTGV2ZWw7XHJcbiAgICBjb25zdCBid0VzdGltYXRvciA9IHRoaXMuX2J3RXN0aW1hdG9yO1xyXG4gICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcclxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICghYndFc3RpbWF0b3IgfHwgIWJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkpKSB7XHJcbiAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XHJcbiAgICB9XHJcbiAgICAvLyBjb21wdXRlIG5leHQgbGV2ZWwgdXNpbmcgQUJSIGxvZ2ljXHJcbiAgICBsZXQgbmV4dEFCUkF1dG9MZXZlbCA9IHRoaXMuX25leHRBQlJBdXRvTGV2ZWw7XHJcbiAgICAvLyBpZiBmb3JjZWQgYXV0byBsZXZlbCBoYXMgYmVlbiBkZWZpbmVkLCB1c2UgaXQgdG8gY2FwIEFCUiBjb21wdXRlZCBxdWFsaXR5IGxldmVsXHJcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSkge1xyXG4gICAgICBuZXh0QUJSQXV0b0xldmVsID0gTWF0aC5taW4oZm9yY2VkQXV0b0xldmVsLG5leHRBQlJBdXRvTGV2ZWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XHJcbiAgfVxyXG4gIGdldCBfbmV4dEFCUkF1dG9MZXZlbCgpIHtcclxuICAgIHZhciBobHMgPSB0aGlzLmhscywgbWF4QXV0b0xldmVsID0gaGxzLm1heEF1dG9MZXZlbCwgbGV2ZWxzID0gaGxzLmxldmVscywgY29uZmlnID0gaGxzLmNvbmZpZywgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcclxuICAgIGNvbnN0IHYgPSBobHMubWVkaWEsXHJcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwsXHJcbiAgICAgICAgICBjdXJyZW50RnJhZ0R1cmF0aW9uID0gdGhpcy5mcmFnQ3VycmVudCA/IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwLFxyXG4gICAgICAgICAgcG9zID0gKHYgPyB2LmN1cnJlbnRUaW1lIDogMCksXHJcbiAgICAgICAgICAvLyBwbGF5YmFja1JhdGUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBwbGF5YmFjayByYXRlOyBpZiB2LnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXHJcbiAgICAgICAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nIGJhY2sgYXQgdGhlIG5vcm1hbCByYXRlLlxyXG4gICAgICAgICAgcGxheWJhY2tSYXRlID0gKCh2ICYmICh2LnBsYXliYWNrUmF0ZSAhPT0gMCkpID8gTWF0aC5hYnModi5wbGF5YmFja1JhdGUpIDogMS4wKSxcclxuICAgICAgICAgIGF2Z2J3ID0gdGhpcy5fYndFc3RpbWF0b3IgPyB0aGlzLl9id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpIDogY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUsXHJcbiAgICAgICAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgdGhlIHdhbGwtY2xvY2sgdGltZSBsZWZ0IHVudGlsIHRoZSBwbGF5YmFjayBidWZmZXIgaXMgZXhoYXVzdGVkLlxyXG4gICAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHYsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7XHJcblxyXG4gICAgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcclxuICAgIGxldCBiZXN0TGV2ZWwgPSB0aGlzLl9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCxjdXJyZW50RnJhZ0R1cmF0aW9uLGF2Z2J3LG1pbkF1dG9MZXZlbCxtYXhBdXRvTGV2ZWwsYnVmZmVyU3RhcnZhdGlvbkRlbGF5LGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yLGxldmVscyk7XHJcbiAgICBpZiAoYmVzdExldmVsID49IDApIHtcclxuICAgICAgcmV0dXJuIGJlc3RMZXZlbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxvZ2dlci50cmFjZSgncmVidWZmZXJpbmcgZXhwZWN0ZWQgdG8gaGFwcGVuLCBsZXRzIHRyeSB0byBmaW5kIGEgcXVhbGl0eSBsZXZlbCBtaW5pbWl6aW5nIHRoZSByZWJ1ZmZlcmluZycpO1xyXG4gICAgICAvLyBub3QgcG9zc2libGUgdG8gZ2V0IHJpZCBvZiByZWJ1ZmZlcmluZyAuLi4gbGV0J3MgdHJ5IHRvIGZpbmQgbGV2ZWwgdGhhdCB3aWxsIGd1YXJhbnRlZSBsZXNzIHRoYW4gbWF4U3RhcnZhdGlvbkRlbGF5IG9mIHJlYnVmZmVyaW5nXHJcbiAgICAgIC8vIGlmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBsb2dpYyB3aWxsIHJldHVybiAwXHJcbiAgICAgIGxldCBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbixjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXksXHJcbiAgICAgICAgICBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsXHJcbiAgICAgICAgICBid1VwRmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xyXG4gICAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID09PSAwKSB7XHJcbiAgICAgICAgLy8gaW4gY2FzZSBidWZmZXIgaXMgZW1wdHksIGxldCdzIGNoZWNrIGlmIHByZXZpb3VzIGZyYWdtZW50IHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdFxyXG4gICAgICAgIGxldCBiaXRyYXRlVGVzdERlbGF5ID0gdGhpcy5iaXRyYXRlVGVzdERlbGF5O1xyXG4gICAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XHJcbiAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxyXG4gICAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XHJcbiAgICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXHJcbiAgICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXHJcbiAgICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cclxuICAgICAgICAgIGNvbnN0IG1heExvYWRpbmdEZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLGNvbmZpZy5tYXhMb2FkaW5nRGVsYXkpIDogY29uZmlnLm1heExvYWRpbmdEZWxheTtcclxuICAgICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA9IG1heExvYWRpbmdEZWxheSAtIGJpdHJhdGVUZXN0RGVsYXk7XHJcbiAgICAgICAgICBsb2dnZXIudHJhY2UoYGJpdHJhdGUgdGVzdCB0b29rICR7TWF0aC5yb3VuZCgxMDAwKmJpdHJhdGVUZXN0RGVsYXkpfW1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gJHtNYXRoLnJvdW5kKDEwMDAqbWF4U3RhcnZhdGlvbkRlbGF5KX0gbXNgKTtcclxuICAgICAgICAgIC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxyXG4gICAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsY3VycmVudEZyYWdEdXJhdGlvbixhdmdidyxtaW5BdXRvTGV2ZWwsbWF4QXV0b0xldmVsLGJ1ZmZlclN0YXJ2YXRpb25EZWxheSttYXhTdGFydmF0aW9uRGVsYXksYndGYWN0b3IsYndVcEZhY3RvcixsZXZlbHMpO1xyXG4gICAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLDApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2ZpbmRCZXN0TGV2ZWwoY3VycmVudExldmVsLGN1cnJlbnRGcmFnRHVyYXRpb24sY3VycmVudEJ3LG1pbkF1dG9MZXZlbCxtYXhBdXRvTGV2ZWwsbWF4RmV0Y2hEdXJhdGlvbixid0ZhY3Rvcixid1VwRmFjdG9yLGxldmVscykge1xyXG4gICAgZm9yIChsZXQgaSA9IG1heEF1dG9MZXZlbDsgaSA+PSBtaW5BdXRvTGV2ZWw7IGktLSkge1xyXG4gICAgICBsZXQgbGV2ZWxJbmZvID0gbGV2ZWxzW2ldLFxyXG4gICAgICAgICAgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHMsXHJcbiAgICAgICAgICBhdmdEdXJhdGlvbiA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uL2xldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIDogY3VycmVudEZyYWdEdXJhdGlvbixcclxuICAgICAgICAgIGxpdmUgPSBsZXZlbERldGFpbHMgPyBsZXZlbERldGFpbHMubGl2ZSA6IGZhbHNlLFxyXG4gICAgICAgICAgYWRqdXN0ZWRidztcclxuICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XHJcbiAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxyXG4gICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXHJcbiAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXHJcbiAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxyXG4gICAgLy8gc3dpdGNoaW5nIGJhY2suXHJcbiAgICAgIGlmIChpIDw9IGN1cnJlbnRMZXZlbCkge1xyXG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBiaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW2ldLnJlYWxCaXRyYXRlLGxldmVsc1tpXS5iaXRyYXRlKSA6IGxldmVsc1tpXS5iaXRyYXRlLFxyXG4gICAgICAgICAgICBmZXRjaER1cmF0aW9uID0gYml0cmF0ZSAqIGF2Z0R1cmF0aW9uIC8gYWRqdXN0ZWRidztcclxuXHJcbiAgICBsb2dnZXIudHJhY2UoYGxldmVsL2FkanVzdGVkYncvYml0cmF0ZS9hdmdEdXJhdGlvbi9tYXhGZXRjaER1cmF0aW9uL2ZldGNoRHVyYXRpb246ICR7aX0vJHtNYXRoLnJvdW5kKGFkanVzdGVkYncpfS8ke2JpdHJhdGV9LyR7YXZnRHVyYXRpb259LyR7bWF4RmV0Y2hEdXJhdGlvbn0vJHtmZXRjaER1cmF0aW9ufWApO1xyXG4gICAgICAvLyBpZiBhZGp1c3RlZCBidyBpcyBncmVhdGVyIHRoYW4gbGV2ZWwgYml0cmF0ZSBBTkRcclxuICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmXHJcbiAgICAgIC8vIGZyYWdtZW50IGZldGNoRHVyYXRpb24gdW5rbm93biBPUiBsaXZlIHN0cmVhbSBPUiBmcmFnbWVudCBmZXRjaER1cmF0aW9uIGxlc3MgdGhhbiBtYXggYWxsb3dlZCBmZXRjaCBkdXJhdGlvbiwgdGhlbiB0aGlzIGxldmVsIG1hdGNoZXNcclxuICAgICAgLy8gd2UgZG9uJ3QgYWNjb3VudCBmb3IgbWF4IEZldGNoIER1cmF0aW9uIGZvciBsaXZlIHN0cmVhbXMsIHRoaXMgaXMgdG8gYXZvaWQgc3dpdGNoaW5nIGRvd24gd2hlbiBuZWFyIHRoZSBlZGdlIG9mIGxpdmUgc2xpZGluZyB3aW5kb3cgLi4uXHJcbiAgICAgICAgKCFmZXRjaER1cmF0aW9uIHx8wqBsaXZlIHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKSApIHtcclxuICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxyXG5cclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIHNldCBuZXh0QXV0b0xldmVsKG5leHRMZXZlbCkge1xyXG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFickNvbnRyb2xsZXI7XHJcblxyXG4iLCIvKlxyXG4gKiBBdWRpbyBTdHJlYW0gQ29udHJvbGxlclxyXG4qL1xyXG5cclxuaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcclxuaW1wb3J0IEJ1ZmZlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvYnVmZmVyLWhlbHBlcic7XHJcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IExldmVsSGVscGVyIGZyb20gJy4uL2hlbHBlci9sZXZlbC1oZWxwZXInO1xyXG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lUmFuZ2VzJztcclxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuY29uc3QgU3RhdGUgPSB7XHJcbiAgU1RPUFBFRCA6ICdTVE9QUEVEJyxcclxuICBTVEFSVElORyA6ICdTVEFSVElORycsXHJcbiAgSURMRSA6ICdJRExFJyxcclxuICBQQVVTRUQgOiAnUEFVU0VEJyxcclxuICBLRVlfTE9BRElORyA6ICdLRVlfTE9BRElORycsXHJcbiAgRlJBR19MT0FESU5HIDogJ0ZSQUdfTE9BRElORycsXHJcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkgOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxyXG4gIFdBSVRJTkdfVFJBQ0sgOiAnV0FJVElOR19UUkFDSycsXHJcbiAgUEFSU0lORyA6ICdQQVJTSU5HJyxcclxuICBQQVJTRUQgOiAnUEFSU0VEJyxcclxuICBCVUZGRVJfRkxVU0hJTkcgOiAnQlVGRkVSX0ZMVVNISU5HJyxcclxuICBFTkRFRCA6ICdFTkRFRCcsXHJcbiAgRVJST1IgOiAnRVJST1InLFxyXG4gIFdBSVRJTkdfSU5JVF9QVFMgOiAnV0FJVElOR19JTklUX1BUUydcclxufTtcclxuXHJcbmNsYXNzIEF1ZGlvU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcclxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxyXG4gICAgICBFdmVudC5BVURJT19UUkFDS1NfVVBEQVRFRCxcclxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENISU5HLFxyXG4gICAgICBFdmVudC5BVURJT19UUkFDS19MT0FERUQsXHJcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXHJcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxyXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULFxyXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcclxuICAgICAgRXZlbnQuRlJBR19QQVJTRUQsXHJcbiAgICAgIEV2ZW50LkVSUk9SLFxyXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcclxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVOREVELFxyXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hFRCxcclxuICAgICAgRXZlbnQuSU5JVF9QVFNfRk9VTkQpO1xyXG5cclxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcclxuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcclxuICAgIHRoaXMudGlja3MgPSAwO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xyXG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcclxuICAgIHRoaXMuaW5pdFBUUz1bXTtcclxuICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50PW51bGw7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5zdG9wTG9hZCgpO1xyXG4gICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xyXG4gIH1cclxuXHJcbiAgLy9TaWduYWwgdGhhdCB2aWRlbyBQVFMgd2FzIGZvdW5kXHJcbiAgb25Jbml0UHRzRm91bmQoZGF0YSkge1xyXG4gICAgdmFyIGRlbXV4ZXJJZD1kYXRhLmlkLCBjYyA9IGRhdGEuZnJhZy5jYywgaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcclxuICAgIGlmKGRlbXV4ZXJJZCA9PT0gJ21haW4nKSB7XHJcbiAgICAgIC8vQWx3YXlzIHVwZGF0ZSB0aGUgbmV3IElOSVQgUFRTXHJcbiAgICAgIC8vQ2FuIGNoYW5nZSBkdWUgbGV2ZWwgc3dpdGNoXHJcbiAgICAgIHRoaXMuaW5pdFBUU1tjY10gPSBpbml0UFRTO1xyXG4gICAgICBsb2dnZXIubG9nKGBJbml0UFRTIGZvciBjYzoke2NjfSBmb3VuZCBmcm9tIHZpZGVvIHRyYWNrOiR7aW5pdFBUU31gKTtcclxuXHJcbiAgICAgIC8vSWYgd2UgYXJlIHdhaXRpbmcgd2UgbmVlZCB0byBkZW11eC9yZW11eCB0aGUgd2FpdGluZyBmcmFnXHJcbiAgICAgIC8vV2l0aCB0aGUgbmV3IGluaXRQVFNcclxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfSU5JVF9QVFMpIHtcclxuICAgICAgICBsb2dnZXIubG9nKCdzZW5kaW5nIHBlbmRpbmcgYXVkaW8gZnJhZyB0byBkZW11eGVyJyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcclxuICAgICAgICAvL1dlIGhhdmUgYXVkaW8gZnJhZyB3YWl0aW5nIG9yIHZpZGVvIHB0c1xyXG4gICAgICAgIC8vTGV0IHByb2Nlc3MgaXRcclxuICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZCh0aGlzLndhaXRpbmdGcmFnbWVudCk7XHJcbiAgICAgICAgLy9MZXRzIGNsZWFuIHRoZSB3YWl0aW5nIGZyYWdcclxuICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XHJcbiAgICBpZiAodGhpcy50cmFja3MpIHtcclxuICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xyXG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XHJcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9udGljaywgMTAwKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xyXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvOm92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCR7bGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLnN0YXJ0UG9zaXRpb24gPyB0aGlzLnN0YXJ0UG9zaXRpb24gOiBzdGFydFBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVEFSVElORztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xyXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0b3BMb2FkKCkge1xyXG4gICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgaWYgKGZyYWcpIHtcclxuICAgICAgaWYgKGZyYWcubG9hZGVyKSB7XHJcbiAgICAgICAgZnJhZy5sb2FkZXIuYWJvcnQoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcclxuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcclxuICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xyXG4gIH1cclxuXHJcbiAgc2V0IHN0YXRlKG5leHRTdGF0ZSkge1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IG5leHRTdGF0ZSkge1xyXG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XHJcbiAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHN0cmVhbToke3ByZXZpb3VzU3RhdGV9LT4ke25leHRTdGF0ZX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBzdGF0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcclxuICB9XHJcblxyXG4gIHRpY2soKSB7XHJcbiAgICB0aGlzLnRpY2tzKys7XHJcbiAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xyXG4gICAgICB0aGlzLmRvVGljaygpO1xyXG4gICAgICBpZiAodGhpcy50aWNrcyA+IDEpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50aWNrcyA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb1RpY2soKSB7XHJcbiAgICB2YXIgcG9zLCB0cmFjaywgdHJhY2tEZXRhaWxzLCBobHMgPSB0aGlzLmhscywgY29uZmlnID0gaGxzLmNvbmZpZztcclxuICAgIC8vbG9nZ2VyLmxvZygnYXVkaW9TdHJlYW06JyArIHRoaXMuc3RhdGUpO1xyXG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcclxuICAgICAgY2FzZSBTdGF0ZS5FUlJPUjpcclxuICAgICAgICAvL2Rvbid0IGRvIGFueXRoaW5nIGluIGVycm9yIHN0YXRlIHRvIGF2b2lkIGJyZWFraW5nIGZ1cnRoZXIgLi4uXHJcbiAgICAgIGNhc2UgU3RhdGUuUEFVU0VEOlxyXG4gICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gcGF1c2VkIHN0YXRlIGVpdGhlciAuLi5cclxuICAgICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgU3RhdGUuU1RBUlRJTkc6XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XHJcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFN0YXRlLklETEU6XHJcbiAgICAgICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3M7XHJcbiAgICAgICAgLy8gYXVkaW8gdHJhY2tzIG5vdCByZWNlaXZlZCA9PiBleGl0IGxvb3BcclxuICAgICAgICBpZiAoIXRyYWNrcykge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcclxuICAgICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcclxuICAgICAgICAvLyBleGl0IGxvb3BcclxuICAgICAgICAvLyA9PiBpZiBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXHJcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhICYmXHJcbiAgICAgICAgICAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZFxyXG4gICAgICAgIC8vICBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXHJcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XHJcbiAgICAgICAgICBwb3MgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSxcclxuICAgICAgICAgICAgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLHBvcyxjb25maWcubWF4QnVmZmVySG9sZSksXHJcbiAgICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuLFxyXG4gICAgICAgICAgICBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCxcclxuICAgICAgICAgICAgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMsXHJcbiAgICAgICAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgsXHJcbiAgICAgICAgICAgIGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaCxcclxuICAgICAgICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcclxuXHJcbiAgICAgICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XHJcbiAgICAgICAgaWYgKChidWZmZXJMZW4gPCBtYXhCdWZMZW4gfHwgYXVkaW9Td2l0Y2gpICYmIHRyYWNrSWQgPCB0cmFja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0cmFja0RldGFpbHMgPSB0cmFja3NbdHJhY2tJZF0uZGV0YWlscztcclxuICAgICAgICAgIC8vIGlmIHRyYWNrIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgdHJhY2sgcmV0cmlldmFsXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZmluYWxpemUgbWVkaWEgc3RyZWFtXHJcbiAgICAgICAgICBpZiAoIWF1ZGlvU3dpdGNoICYmICF0cmFja0RldGFpbHMubGl2ZSAmJiBmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnNuID09PSB0cmFja0RldGFpbHMuZW5kU04pIHtcclxuICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IHNlZWtpbmcgb3IgaWYgd2UgYXJlIHNlZWtpbmcgYnV0IGV2ZXJ5dGhpbmcgKGFsbW9zdCkgdGlsIHRoZSBlbmQgaXMgYnVmZmVyZWQsIGxldCdzIHNpZ25hbCBlb3NcclxuICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBjb21wYXJlIGV4YWN0bHkgbWVkaWEuZHVyYXRpb24gPT09IGJ1ZmZlckluZm8uZW5kIGFzIHRoZXJlIGNvdWxkIGJlIHNvbWUgc3VidGxlIG1lZGlhIGR1cmF0aW9uIGRpZmZlcmVuY2Ugd2hlbiBzd2l0Y2hpbmdcclxuICAgICAgICAgICAgICAvLyBiZXR3ZWVuIGRpZmZlcmVudCByZW5kaXRpb25zLiB1c2luZyBoYWxmIGZyYWcgZHVyYXRpb24gc2hvdWxkIGhlbHAgY29wZSB3aXRoIHRoZXNlIGNhc2VzLlxyXG4gICAgICAgICAgICAgIGlmICghdGhpcy5tZWRpYS5zZWVraW5nIHx8ICh0aGlzLm1lZGlhLmR1cmF0aW9uLWJ1ZmZlckVuZCkgPCBmcmFnUHJldmlvdXMuZHVyYXRpb24vMikge1xyXG4gICAgICAgICAgICAgIC8vIEZpbmFsaXplIHRoZSBtZWRpYSBzdHJlYW1cclxuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9FT1MseyB0eXBlIDogJ2F1ZGlvJ30pO1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXHJcbiAgICAgICAgICBsZXQgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cyxcclxuICAgICAgICAgICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgICBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcclxuICAgICAgICAgICAgICBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuLTFdLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgIGZyYWc7XHJcblxyXG4gICAgICAgICAgLy8gV2hlbiBzd2l0Y2hpbmcgYXVkaW8gdHJhY2ssIHJlbG9hZCBhdWRpbyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byBjdXJyZW50VGltZVxyXG4gICAgICAgICAgaWYoYXVkaW9Td2l0Y2gpe1xyXG4gICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgIXRyYWNrRGV0YWlscy5QVFNLbm93bikge1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyBhdWRpb3RyYWNrLCBsaXZlIHN0cmVhbSwgdW5rbm93biBQVFMsbG9hZCBmaXJzdCBmcmFnbWVudGApO1xyXG4gICAgICAgICAgICAgIGJ1ZmZlckVuZCA9IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYnVmZmVyRW5kID0gcG9zO1xyXG4gICAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRUaW1lIChwb3MpIGlzIGxlc3MgdGhhbiBhbHQgYXVkaW8gcGxheWxpc3Qgc3RhcnQgdGltZSwgaXQgbWVhbnMgdGhhdCBhbHQgYXVkaW8gaXMgYWhlYWQgb2YgY3VycmVudFRpbWVcclxuICAgICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLlBUU0tub3duICYmIHBvcyA8IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVySW5mby5lbmQgPiBzdGFydCB8fCBidWZmZXJJbmZvLm5leHRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdhbHQgYXVkaW8gdHJhY2sgYWhlYWQgb2YgbWFpbiB0cmFjaywgc2VlayB0byBzdGFydCBvZiBhbHQgYXVkaW8gdHJhY2snKTtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQgJiYgIXRyYWNrRGV0YWlscy5pbml0U2VnbWVudC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgZnJhZyA9IHRyYWNrRGV0YWlscy5pbml0U2VnbWVudDtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBpZiBidWZmZXJFbmQgYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XHJcbiAgICAgICAgICBlbHNlIGlmIChidWZmZXJFbmQgPD0gc3RhcnQpIHtcclxuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcclxuICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmIGZyYWcubG9hZElkeCAmJiBmcmFnLmxvYWRJZHggPT09IHRoaXMuZnJhZ0xvYWRJZHgpIHtcclxuICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGxvYWRlZCB0aGlzIGZpcnN0IGZyYWdtZW50LCBhbmQgd2UgYXJlIHN0aWxsIGxhZ2dpbmcgYmVoaW5kIHRoZSBzdGFydCBvZiB0aGUgbGl2ZSBwbGF5bGlzdFxyXG4gICAgICAgICAgICAgIC8vIGxldCdzIGZvcmNlIHNlZWsgdG8gc3RhcnRcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0QnVmZmVyZWQgPSBidWZmZXJJbmZvLm5leHRTdGFydCA/IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDogc3RhcnQ7XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbm8gYWx0IGF1ZGlvIGF2YWlsYWJsZSBAY3VycmVudFRpbWU6JHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lfSwgc2Vla2luZyBAJHtuZXh0QnVmZmVyZWQgKyAwLjA1fWApO1xyXG4gICAgICAgICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBuZXh0QnVmZmVyZWQgKyAwLjA1O1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZztcclxuICAgICAgICAgICAgbGV0IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcclxuICAgICAgICAgICAgY29uc3QgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgPSAoY2FuZGlkYXRlKSA9PiB7XHJcbiAgICAgICAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxyXG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxyXG4gICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXHJcbiAgICAgICAgICAgICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cclxuICAgICAgICAgICAgICAvLyBmcmFnWzFdIDogWzEwLDIwXVxyXG4gICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cclxuICAgICAgICAgICAgICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXHJcbiAgICAgICAgICAgICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXHJcbiAgICAgICAgICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcclxuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XHJcbiAgICAgICAgICAgICAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcclxuICAgICAgICAgICAgICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICBpZiAoKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSkgPD0gYnVmZmVyRW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICB9Ly8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcclxuICAgICAgICAgICAgICBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xyXG4gICAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxyXG4gICAgICAgICAgICAgIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGZyYWdOZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ05leHQ7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcclxuICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnKSB7XHJcbiAgICAgICAgICAgICAgZnJhZyA9IGZvdW5kRnJhZztcclxuICAgICAgICAgICAgICBzdGFydCA9IGZvdW5kRnJhZy5zdGFydDtcclxuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcclxuICAgICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChmcmFnLnNuIDwgdHJhY2tEZXRhaWxzLmVuZFNOKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZy5zbiArIDEgLSB0cmFja0RldGFpbHMuc3RhcnRTTl07XHJcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKGZyYWcpIHtcclxuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCcgICAgICBsb2FkaW5nIGZyYWcgJyArIGkgKycscG9zL2J1ZkVuZDonICsgcG9zLnRvRml4ZWQoMykgKyAnLycgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XHJcbiAgICAgICAgICAgIGlmIChmcmFnLmRlY3J5cHRkYXRhICYmIChmcmFnLmRlY3J5cHRkYXRhLnVyaSAhPSBudWxsKSAmJiAoZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHt0cmFja0RldGFpbHMuc3RhcnRTTn0gLCR7dHJhY2tEZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcclxuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nICR7ZnJhZy5zbn0gb2YgWyR7dHJhY2tEZXRhaWxzLnN0YXJ0U059ICwke3RyYWNrRGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH0sIGN1cnJlbnRUaW1lOiR7cG9zfSxidWZmZXJFbmQ6JHtidWZmZXJFbmQudG9GaXhlZCgzKX1gKTtcclxuICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB3ZSBhcmUgbm90IHJlbG9hZGluZyB0aGUgc2FtZSBmcmFnbWVudHMgaW4gbG9vcCAuLi5cclxuICAgICAgICAgICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkSWR4Kys7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggPSAwO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlcikge1xyXG4gICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1heFRocmVzaG9sZCA9IGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGZyYWcgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgMyB0aW1lcywgYW5kIGlmIGl0IGhhcyBiZWVuIHJlbG9hZGVkIHJlY2VudGx5XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiAoTWF0aC5hYnModGhpcy5mcmFnTG9hZElkeCAtIGZyYWcubG9hZElkeCkgPCBtYXhUaHJlc2hvbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWd9KTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZnJhZy5sb2FkSWR4ID0gdGhpcy5mcmFnTG9hZElkeDtcclxuICAgICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcclxuICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihmcmFnLnNuKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcclxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfVFJBQ0s6XHJcbiAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXHJcbiAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLmRldGFpbHMpIHtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcclxuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xyXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgICAgICB2YXIgaXNTZWVraW5nID0gbWVkaWEgJiYgbWVkaWEuc2Vla2luZztcclxuICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xyXG4gICAgICAgIGlmKCFyZXRyeURhdGUgfHwgKG5vdyA+PSByZXRyeURhdGUpIHx8IGlzU2Vla2luZykge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW9TdHJlYW1Db250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZWApO1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfSU5JVF9QVFM6XHJcbiAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcclxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XHJcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcclxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XHJcbiAgICAgIGNhc2UgU3RhdGUuRU5ERUQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xyXG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xyXG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XHJcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcclxuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XHJcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XHJcbiAgICBpZih0aGlzLnRyYWNrcyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xyXG4gICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xyXG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xyXG4gICAgICBsb2dnZXIubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xyXG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZGluZyBjb3VudGVyIG9uIE1TRSBkZXRhY2hpbmcgdG8gYXZvaWQgcmVwb3J0aW5nIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SIGFmdGVyIGVycm9yIHJlY292ZXJ5XHJcbiAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XHJcbiAgICBpZiAodHJhY2tzKSB7XHJcbiAgICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWQgY291bnRlclxyXG4gICAgICAgIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgICAgIGlmKHRyYWNrLmRldGFpbHMpIHtcclxuICAgICAgICAgICAgdHJhY2suZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgZnJhZ21lbnQubG9hZENvdW50ZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcclxuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcclxuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0b3BMb2FkKCk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhU2Vla2luZygpIHtcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xyXG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tZWRpYSkge1xyXG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XHJcbiAgICB9XHJcbiAgICAvLyBhdm9pZCByZXBvcnRpbmcgZnJhZ21lbnQgbG9vcCBsb2FkaW5nIGVycm9yIGluIGNhc2UgdXNlciBpcyBzZWVraW5nIHNldmVyYWwgdGltZXMgb24gc2FtZSBwb3NpdGlvblxyXG4gICAgaWYgKHRoaXMuZnJhZ0xvYWRJZHggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XHJcbiAgICB9XHJcbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcclxuICAgIHRoaXMudGljaygpO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYUVuZGVkKCkge1xyXG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXHJcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgb25BdWRpb1RyYWNrc1VwZGF0ZWQoZGF0YSkge1xyXG4gICAgbG9nZ2VyLmxvZygnYXVkaW8gdHJhY2tzIHVwZGF0ZWQnKTtcclxuICAgIHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcztcclxuICB9XHJcblxyXG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhkYXRhKSB7XHJcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXHJcbiAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xyXG4gICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG5cclxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBVVNFRDtcclxuICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50PW51bGw7XHJcbiAgICAvLyBkZXN0cm95IHVzZWxlc3MgZGVtdXhlciB3aGVuIHN3aXRjaGluZyBhdWRpbyB0byBtYWluXHJcbiAgICBpZiAoIWFsdEF1ZGlvKSB7XHJcbiAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxyXG4gICAgICBpZiAoIXRoaXMudGltZXIpIHtcclxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL3Nob3VsZCB3ZSBzd2l0Y2ggdHJhY2tzID9cclxuICAgIGlmKGFsdEF1ZGlvKXtcclxuICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IHRydWU7XHJcbiAgICAgIC8vbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xyXG4gICAgICB0aGlzLnN0YXRlPVN0YXRlLklETEU7XHJcbiAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXHJcbiAgICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMudGljaygpO1xyXG4gIH1cclxuXHJcbiAgb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcclxuICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxyXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkLFxyXG4gICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXHJcbiAgICAgICAgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24sXHJcbiAgICAgICAgc2xpZGluZyA9IDA7XHJcblxyXG4gICAgbG9nZ2VyLmxvZyhgdHJhY2sgJHt0cmFja0lkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xyXG5cclxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcclxuICAgICAgdmFyIGN1ckRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xyXG4gICAgICBpZiAoY3VyRGV0YWlscyAmJiBuZXdEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gd2UgYWxyZWFkeSBoYXZlIGRldGFpbHMgZm9yIHRoYXQgbGV2ZWwsIG1lcmdlIHRoZW1cclxuICAgICAgICBMZXZlbEhlbHBlci5tZXJnZURldGFpbHMoY3VyRGV0YWlscyxuZXdEZXRhaWxzKTtcclxuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIC8vdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xyXG4gICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIGF1ZGlvIHBsYXlsaXN0IHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBhdWRpbyBwbGF5bGlzdCAtIGZpcnN0IGxvYWQsIHVua25vd24gc2xpZGluZycpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcclxuXHJcbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uXHJcbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XHJcbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxyXG4gICAgICBpZiAodGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSkge1xyXG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcclxuICAgICAgICBsZXQgc3RhcnRUaW1lT2Zmc2V0ID0gbmV3RGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XHJcbiAgICAgICAgaWYoIWlzTmFOKHN0YXJ0VGltZU9mZnNldCkpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcclxuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIHRyYWNrIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSykge1xyXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgIH1cclxuICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xyXG4gICAgdGhpcy50aWNrKCk7XHJcbiAgfVxyXG5cclxuICBvbktleUxvYWRlZCgpIHtcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xyXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZyYWdMb2FkZWQoZGF0YSkge1xyXG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcclxuICAgICAgICBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxyXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXHJcbiAgICAgICAgZnJhZ0xvYWRlZC50eXBlID09PSAnYXVkaW8nICYmXHJcbiAgICAgICAgZnJhZ0xvYWRlZC5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcclxuICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xyXG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF0sXHJcbiAgICAgICAgICAgIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzLFxyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcclxuICAgICAgICAgICAgdHJhY2tJZCA9IGZyYWdDdXJyZW50LmxldmVsLFxyXG4gICAgICAgICAgICBzbiA9IGZyYWdDdXJyZW50LnNuLFxyXG4gICAgICAgICAgICBjYyA9IGZyYWdDdXJyZW50LmNjLFxyXG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJyxcclxuICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzID0gZGF0YS5zdGF0cztcclxuICAgICAgaWYgKHNuID09PSAnaW5pdFNlZ21lbnQnKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcblxyXG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgPSBkYXRhLnBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQgOiAnYXVkaW8nfSk7XHJcbiAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XHJcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xyXG4gICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcclxuICAgICAgICBpZighdGhpcy5kZW11eGVyKSB7XHJcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcih0aGlzLmhscywnYXVkaW8nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9DaGVjayBpZiB3ZSBoYXZlIHZpZGVvIGluaXRQVFNcclxuICAgICAgICAvLyBJZiBub3Qgd2UgbmVlZCB0byB3YWl0IGZvciBpdFxyXG4gICAgICAgIGxldCBpbml0UFRTID0gdGhpcy5pbml0UFRTW2NjXTtcclxuICAgICAgICBsZXQgaW5pdFNlZ21lbnREYXRhID0gZGV0YWlscy5pbml0U2VnbWVudCA/IGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA6IFtdO1xyXG4gICAgICAgIGlmIChkZXRhaWxzLmluaXRTZWdtZW50IHx8IGluaXRQVFMgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgRGVtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xyXG4gICAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXHJcbiAgICAgICAgICBsZXQgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZmFsc2U7IC8vZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xyXG4gICAgICAgICAgdGhpcy5kZW11eGVyLnB1c2goZGF0YS5wYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIG51bGwsIGZyYWdDdXJyZW50LCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBpbml0UFRTKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgdW5rbm93biB2aWRlbyBQVFMgZm9yIGNvbnRpbnVpdHkgY291bnRlciAke2NjfSwgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcclxuICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50PWRhdGE7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlPVN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xyXG4gIH1cclxuXHJcbiAgb25GcmFnUGFyc2luZ0luaXRTZWdtZW50KGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXHJcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcclxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxyXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcclxuICAgICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFjaztcclxuXHJcbiAgICAgIC8vIGRlbGV0ZSBhbnkgdmlkZW8gdHJhY2sgZm91bmQgb24gYXVkaW8gZGVtdXhlclxyXG4gICAgICBpZiAodHJhY2tzLnZpZGVvKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcclxuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XHJcbiAgICAgIGlmKHRyYWNrKSB7XHJcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9ICdtcDRhLjQwLjInO1xyXG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsdHJhY2tzKTtcclxuICAgICAgICBsb2dnZXIubG9nKGBhdWRpbyB0cmFjazphdWRpbyxjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske3RyYWNrLmxldmVsQ29kZWN9LyR7dHJhY2suY29kZWN9XWApO1xyXG4gICAgICAgIGxldCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xyXG4gICAgICAgIGlmIChpbml0U2VnbWVudCkge1xyXG4gICAgICAgICAgbGV0IGFwcGVuZE9iaiA9IHt0eXBlOiAnYXVkaW8nLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50IDogJ2F1ZGlvJyxjb250ZW50IDogJ2luaXRTZWdtZW50J307XHJcbiAgICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCkge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW2FwcGVuZE9ial07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgICAgICB0aGlzLnRpY2soKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnUGFyc2luZ0RhdGEoZGF0YSkge1xyXG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcclxuICAgIGlmIChmcmFnQ3VycmVudCAmJlxyXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcclxuICAgICAgICBkYXRhLnR5cGUgPT09ICdhdWRpbycgJiZcclxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxyXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xyXG4gICAgICBsZXQgdHJhY2tJZD0gdGhpcy50cmFja0lkLFxyXG4gICAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXSxcclxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xyXG5cclxuICAgICAgaWYgKGlzTmFOKGRhdGEuZW5kUFRTKSkge1xyXG4gICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xyXG4gICAgICAgIGRhdGEuZW5kRFRTID0gZGF0YS5zdGFydERUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn1gKTtcclxuICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyh0cmFjay5kZXRhaWxzLGZyYWdDdXJyZW50LGRhdGEuc3RhcnRQVFMsZGF0YS5lbmRQVFMpO1xyXG5cclxuICAgICAgbGV0IGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaCwgbWVkaWEgPSB0aGlzLm1lZGlhLCBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gZmFsc2U7XHJcbiAgICAgIC8vT25seSBmbHVzaCBhdWRpbyBmcm9tIG9sZCBhdWRpbyB0cmFja3Mgd2hlbiBQVFMgaXMga25vd24gb24gbmV3IGF1ZGlvIHRyYWNrXHJcbiAgICAgIGlmKGF1ZGlvU3dpdGNoICYmIG1lZGlhKSB7XHJcbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcclxuICAgICAgICAgIGxldCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogY3VycmVudFRpbWU6JysgY3VycmVudFRpbWUpO1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID49IGRhdGEuc3RhcnRQVFMpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogZmx1c2hpbmcgYWxsIGF1ZGlvJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XHJcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywge3N0YXJ0T2Zmc2V0OiAwICwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGUgOiAnYXVkaW8nfSk7XHJcbiAgICAgICAgICAgIGFwcGVuZE9uQnVmZmVyRmx1c2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAvL0xldHMgYW5ub3VuY2UgdGhhdCB0aGUgaW5pdGlhbCBhdWRpbyB0cmFjayBzd2l0Y2ggZmx1c2ggb2NjdXJcclxuICAgICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwge2lkIDogdHJhY2tJZH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvL0xldHMgYW5ub3VuY2UgdGhhdCB0aGUgaW5pdGlhbCBhdWRpbyB0cmFjayBzd2l0Y2ggZmx1c2ggb2NjdXJcclxuICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2g9ZmFsc2U7XHJcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwge2lkIDogdHJhY2tJZH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIGxldCBwZW5kaW5nRGF0YSA9IHRoaXMucGVuZGluZ0RhdGE7XHJcbiAgICAgIGlmKCF0aGlzLmF1ZGlvU3dpdGNoKSB7XHJcbiAgICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goYnVmZmVyID0+IHtcclxuICAgICAgICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBwZW5kaW5nRGF0YS5wdXNoKHt0eXBlOiBkYXRhLnR5cGUsIGRhdGE6IGJ1ZmZlciwgcGFyZW50IDogJ2F1ZGlvJyxjb250ZW50IDogJ2RhdGEnfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIGlmICghYXBwZW5kT25CdWZmZXJGbHVzaCAmJiBwZW5kaW5nRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgIHBlbmRpbmdEYXRhLmZvckVhY2goYXBwZW5kT2JqID0+IHtcclxuICAgICAgICAgICAgLy8gb25seSBhcHBlbmQgaW4gUEFSU0lORyBzdGF0ZSAocmF0aW9uYWxlIGlzIHRoYXQgYW4gYXBwZW5kaW5nIGVycm9yIGNvdWxkIGhhcHBlbiBzeW5jaHJvbm91c2x5IG9uIGZpcnN0IHNlZ21lbnQgYXBwZW5kaW5nKVxyXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XHJcbiAgICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcclxuICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW107XHJcbiAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XHJcbiAgICAgIHRoaXMudGljaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnUGFyc2VkKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXHJcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcclxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxyXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcclxuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XHJcbiAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBvbkJ1ZmZlckNyZWF0ZWQoZGF0YSkge1xyXG4gICAgbGV0IGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrcy5hdWRpbztcclxuICAgIGlmIChhdWRpb1RyYWNrKSB7XHJcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlcjtcclxuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkJ1ZmZlckFwcGVuZGVkKGRhdGEpIHtcclxuICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gKGRhdGEucGVuZGluZyA+IDApO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NoZWNrQXBwZW5kZWRQYXJzZWQoKSB7XHJcbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8ICF0aGlzLnBlbmRpbmdCdWZmZXJpbmcpKSAgIHtcclxuICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LCBzdGF0cyA9IHRoaXMuc3RhdHMsIGhscyA9IHRoaXMuaGxzO1xyXG4gICAgICBpZiAoZnJhZykge1xyXG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcclxuICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZCA6ICdhdWRpbyd9KTtcclxuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xyXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoICYmIHRoaXMuYXBwZW5kZWQpIHtcclxuICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7aWQgOiB0aGlzLnRyYWNrSWR9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkVycm9yKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcclxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ2F1ZGlvJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBzd2l0Y2goZGF0YS5kZXRhaWxzKSB7XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XHJcbiAgICAgICAgaWYoIWRhdGEuZmF0YWwpIHtcclxuICAgICAgICAgIHZhciBsb2FkRXJyb3IgPSB0aGlzLmZyYWdMb2FkRXJyb3I7XHJcbiAgICAgICAgICBpZihsb2FkRXJyb3IpIHtcclxuICAgICAgICAgICAgbG9hZEVycm9yKys7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsb2FkRXJyb3I9MTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgICAgICAgIGlmIChsb2FkRXJyb3IgPD0gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcclxuICAgICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gbG9hZEVycm9yO1xyXG4gICAgICAgICAgICAvLyByZXNldCBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3JcclxuICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDA7XHJcbiAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxyXG4gICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLGxvYWRFcnJvci0xKSpjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IGZyYWcgbG9hZGluZyBmYWlsZWQsIHJldHJ5IGluICR7ZGVsYXl9IG1zYCk7XHJcbiAgICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcclxuICAgICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLmApO1xyXG4gICAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcclxuICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOlxyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxyXG4gICAgICAgIC8vICB3aGVuIGluIEVSUk9SIHN0YXRlLCBkb24ndCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGluIGNhc2UgYSBub24tZmF0YWwgZXJyb3IgaXMgcmVjZWl2ZWRcclxuICAgICAgICBpZih0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xyXG4gICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nLCBvdGhlcndpc2UgbW92ZSB0byBJRExFIHRvIHJldHJ5IGxvYWRpbmdcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGRhdGEuZmF0YWwgPyBTdGF0ZS5FUlJPUiA6IFN0YXRlLklETEU7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSB3aGlsZSBsb2FkaW5nIGZyYWcsc3dpdGNoIHRvICR7dGhpcy5zdGF0ZX0gc3RhdGUgLi4uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcclxuICAgICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcclxuICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHzCoHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkpIHtcclxuICAgICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlcixcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZSxcclxuICAgICAgICAgICAgICAgIG1lZGlhQnVmZmVyZWQgPSBtZWRpYSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSxjdXJyZW50VGltZSkgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsY3VycmVudFRpbWUrMC41KTtcclxuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXHJcbiAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgICAgICAgICAgaWYoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBjb25maWcubWF4QnVmZmVyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXHJcbiAgICAgICAgICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aC89MjtcclxuICAgICAgICAgICAgICBsb2dnZXIud2FybihgYXVkaW86cmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvICR7Y29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aH1zYCk7XHJcbiAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcclxuICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXHJcbiAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxyXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdidWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggYXVkaW8gYnVmZmVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XHJcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7c3RhcnRPZmZzZXQ6IDAgLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZSA6ICdhdWRpbyd9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkJ1ZmZlckZsdXNoZWQoKSB7XHJcbiAgICBsZXQgcGVuZGluZ0RhdGEgPSB0aGlzLnBlbmRpbmdEYXRhO1xyXG4gICAgaWYgKHBlbmRpbmdEYXRhICYmIHBlbmRpbmdEYXRhLmxlbmd0aCkge1xyXG4gICAgICBsb2dnZXIubG9nKCdhcHBlbmRpbmcgcGVuZGluZyBhdWRpbyBkYXRhIG9uIEJ1ZmZlciBGbHVzaGVkJyk7XHJcbiAgICAgIHBlbmRpbmdEYXRhLmZvckVhY2goYXBwZW5kT2JqID0+IHtcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xyXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gbW92ZSB0byBJRExFIG9uY2UgZmx1c2ggY29tcGxldGUuIHRoaXMgc2hvdWxkIHRyaWdnZXIgbmV3IGZyYWdtZW50IGxvYWRpbmdcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXHJcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcclxuXHJcbiIsIi8qXHJcbiAqIGF1ZGlvIHRyYWNrIGNvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNsYXNzIEF1ZGlvVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXHJcbiAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcclxuICAgICAgICAgICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVEKTtcclxuICAgIHRoaXMudGlja3MgPSAwO1xyXG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICB9XHJcbiAgdGljaygpIHtcclxuICAgIHRoaXMudGlja3MrKztcclxuICAgIGlmICh0aGlzLnRpY2tzID09PSAxKSB7XHJcbiAgICAgIHRoaXMuZG9UaWNrKCk7XHJcbiAgICAgIGlmICh0aGlzLnRpY2tzID4gMSkge1xyXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy50aWNrLCAxKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRpY2tzID0gMDtcclxuICAgIH1cclxuICB9XHJcbiAgZG9UaWNrKCkge1xyXG4gICAgdGhpcy51cGRhdGVUcmFjayh0aGlzLnRyYWNrSWQpO1xyXG4gIH1cclxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcclxuICAgIC8vIHJlc2V0IGF1ZGlvIHRyYWNrcyBvbiBtYW5pZmVzdCBsb2FkaW5nXHJcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xyXG4gICAgdGhpcy50cmFja0lkID0gLTE7XHJcbiAgfVxyXG5cclxuICBvbk1hbmlmZXN0TG9hZGVkKGRhdGEpIHtcclxuICAgIGxldCB0cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzIHx8IFtdO1xyXG4gICAgbGV0IGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xyXG4gICAgdGhpcy50cmFja3MgPSB0cmFja3M7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLU19VUERBVEVELCB7YXVkaW9UcmFja3MgOiB0cmFja3N9KTtcclxuICAgIC8vIGxvb3AgdGhyb3VnaCBhdmFpbGFibGUgYXVkaW8gdHJhY2tzIGFuZCBhdXRvc2VsZWN0IGRlZmF1bHQgaWYgbmVlZGVkXHJcbiAgICBsZXQgaWQgPSAwO1xyXG4gICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICBpZih0cmFjay5kZWZhdWx0KSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrID0gaWQ7XHJcbiAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWQrKztcclxuICAgIH0pO1xyXG4gICAgaWYgKGRlZmF1bHRGb3VuZCA9PT0gZmFsc2UgJiYgdHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICBsb2dnZXIubG9nKCdubyBkZWZhdWx0IGF1ZGlvIHRyYWNrIGRlZmluZWQsIHVzZSBmaXJzdCBhdWRpbyB0cmFjayBhcyBkZWZhdWx0Jyk7XHJcbiAgICAgIHRoaXMuYXVkaW9UcmFjayA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkF1ZGlvVHJhY2tMb2FkZWQoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEuaWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhgYXVkaW9UcmFjayAke2RhdGEuaWR9IGxvYWRlZGApO1xyXG4gICAgICB0aGlzLnRyYWNrc1tkYXRhLmlkXS5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xyXG4gICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdFxyXG4gICAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMudGltZXIpIHtcclxuICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0IHdlIHdpbGwgaGF2ZSB0byByZWxvYWQgaXQgcGVyaW9kaWNhbGx5XHJcbiAgICAgICAgLy8gc2V0IHJlbG9hZCBwZXJpb2QgdG8gcGxheWxpc3QgdGFyZ2V0IGR1cmF0aW9uXHJcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDAwICogZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWRhdGEuZGV0YWlscy5saXZlICYmIHRoaXMudGltZXIpIHtcclxuICAgICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgYXJtZWQgOiBzdG9wcGluZyBpdFxyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXHJcbiAgZ2V0IGF1ZGlvVHJhY2tzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xyXG4gIH1cclxuXHJcbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKSAqKi9cclxuICBnZXQgYXVkaW9UcmFjaygpIHtcclxuICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcclxuICB9XHJcblxyXG4gIC8qKiBzZWxlY3QgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cyoqL1xyXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZCkge1xyXG4gICAgaWYgKHRoaXMudHJhY2tJZCAhPT0gYXVkaW9UcmFja0lkIHx8IHRoaXMudHJhY2tzW2F1ZGlvVHJhY2tJZF0uZGV0YWlscyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuc2V0QXVkaW9UcmFja0ludGVybmFsKGF1ZGlvVHJhY2tJZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuIHNldEF1ZGlvVHJhY2tJbnRlcm5hbChuZXdJZCkge1xyXG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXHJcbiAgICBpZiAobmV3SWQgPj0gMCAmJiBuZXdJZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcclxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcclxuICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcclxuICAgICAgbGV0IGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF0sXHJcbiAgICAgICAgICBobHMgPSB0aGlzLmhscyxcclxuICAgICAgICAgIHR5cGUgPSBhdWRpb1RyYWNrLnR5cGUsXHJcbiAgICAgICAgICB1cmwgPSBhdWRpb1RyYWNrLnVybCxcclxuICAgICAgICAgIGV2ZW50T2JqID0ge2lkOiBuZXdJZCwgdHlwZSA6IHR5cGUsIHVybCA6IHVybH07XHJcbiAgICAgIC8vIGtlZXAgQVVESU9fVFJBQ0tfU1dJVENIIGZvciBsZWdhY3kgcmVhc29uXHJcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSCwgZXZlbnRPYmopO1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hJTkcsIGV2ZW50T2JqKTtcclxuICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBhdWRpbyBUcmFja1xyXG4gICAgICAgbGV0IGRldGFpbHMgPSBhdWRpb1RyYWNrLmRldGFpbHM7XHJcbiAgICAgIGlmICh1cmwgJiYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBkZXRhaWxzLmxpdmUgPT09IHRydWUpKSB7XHJcbiAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxyXG4gICAgICAgIGxvZ2dlci5sb2coYChyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBhdWRpb1RyYWNrICR7bmV3SWR9YCk7XHJcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORywge3VybDogdXJsLCBpZDogbmV3SWR9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlVHJhY2sobmV3SWQpIHtcclxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxyXG4gICAgaWYgKG5ld0lkID49IDAgJiYgbmV3SWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcclxuICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XHJcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XHJcbiAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XHJcbiAgICAgIGxvZ2dlci5sb2coYHVwZGF0aW5nIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcclxuICAgICAgbGV0IGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF0sIHVybCA9IGF1ZGlvVHJhY2sudXJsO1xyXG4gICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGF1ZGlvIFRyYWNrXHJcbiAgICAgICBsZXQgZGV0YWlscyA9IGF1ZGlvVHJhY2suZGV0YWlscztcclxuICAgICAgaWYgKHVybCAmJiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkpIHtcclxuICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX0xPQURJTkcsIHt1cmw6IHVybCwgaWQ6IG5ld0lkfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEF1ZGlvVHJhY2tDb250cm9sbGVyO1xyXG4iLCIvKlxyXG4gKiBCdWZmZXIgQ29udHJvbGxlclxyXG4qL1xyXG5cclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcclxuXHJcblxyXG5jbGFzcyBCdWZmZXJDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsXHJcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcclxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXHJcbiAgICAgIEV2ZW50LkJVRkZFUl9SRVNFVCxcclxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVORElORyxcclxuICAgICAgRXZlbnQuQlVGRkVSX0NPREVDUyxcclxuICAgICAgRXZlbnQuQlVGRkVSX0VPUyxcclxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNISU5HLFxyXG4gICAgICBFdmVudC5MRVZFTF9QVFNfVVBEQVRFRCxcclxuICAgICAgRXZlbnQuTEVWRUxfVVBEQVRFRCk7XHJcblxyXG4gICAgLy8gdGhlIHZhbHVlIHRoYXQgd2UgaGF2ZSBzZXQgbWVkaWFzb3VyY2UuZHVyYXRpb24gdG9cclxuICAgIC8vICh0aGUgYWN0dWFsIGR1cmF0aW9uIG1heSBiZSB0d2Vha2VkIHNsaWdobHkgYnkgdGhlIGJyb3dzZXIpXHJcbiAgICB0aGlzLl9tc0R1cmF0aW9uID0gbnVsbDtcclxuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIHdhbnQgdG8gc2V0IG1lZGlhU291cmNlLmR1cmF0aW9uIHRvXHJcbiAgICB0aGlzLl9sZXZlbER1cmF0aW9uID0gbnVsbDtcclxuXHJcbiAgICAvLyBTb3VyY2UgQnVmZmVyIGxpc3RlbmVyc1xyXG4gICAgdGhpcy5vbnNidWUgPSB0aGlzLm9uU0JVcGRhdGVFbmQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25zYmUgID0gdGhpcy5vblNCVXBkYXRlRXJyb3IuYmluZCh0aGlzKTtcclxuICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xyXG4gICAgdGhpcy50cmFja3MgPSB7fTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICB9XHJcblxyXG4gIG9uTGV2ZWxQdHNVcGRhdGVkKGRhdGEpIHtcclxuICAgIGxldCB0eXBlID0gZGF0YS50eXBlO1xyXG4gICAgbGV0IGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrcy5hdWRpbztcclxuXHJcbiAgICAvLyBBZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIChkZXNpcmVkIHBvaW50IGluIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgbmV4dCBmcmFtZXMgc2hvdWxkIGJlIGFwcGVuZGVkKVxyXG4gICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxyXG4gICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLiBBdCB0aGUgdGltZSBvZiBjaGFuZ2Ugd2UgaXNzdWVcclxuICAgIC8vIGBTb3VyY2VCdWZmZXIuYWJvcnQoKWAgYW5kIGFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgaWYgYFNvdXJjZUJ1ZmZlci51cGRhdGluZ2AgaXMgZmFsc2Ugb3IgYXdhaXRpbmcgYHVwZGF0ZWVuZGBcclxuICAgIC8vIGV2ZW50IGlmIFNCIGlzIGluIHVwZGF0aW5nIHN0YXRlLlxyXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zMzIjaXNzdWVjb21tZW50LTI1Nzk4NjQ4NlxyXG5cclxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIGF1ZGlvVHJhY2sgJiYgYXVkaW9UcmFjay5jb250YWluZXIgPT09ICdhdWRpby9tcGVnJykgeyAvLyBDaHJvbWUgYXVkaW8gbXAzIHRyYWNrXHJcbiAgICAgIGxldCBhdWRpb0J1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLmF1ZGlvO1xyXG4gICAgICBsZXQgZGVsdGEgPSBNYXRoLmFicyhhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgLSBkYXRhLnN0YXJ0KTtcclxuXHJcbiAgICAgIC8vIGFkanVzdCB0aW1lc3RhbXAgb2Zmc2V0IGlmIHRpbWUgZGVsdGEgaXMgZ3JlYXRlciB0aGFuIDEwMG1zXHJcbiAgICAgIGlmIChkZWx0YSA+IDAuMSkge1xyXG4gICAgICAgIGxldCB1cGRhdGluZyA9IGF1ZGlvQnVmZmVyLnVwZGF0aW5nO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXVkaW9CdWZmZXIuYWJvcnQoKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIHVwZGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKCdjYW4gbm90IGFib3J0IGF1ZGlvIGJ1ZmZlcjogJyArIGVycik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXVwZGF0aW5nKSB7XHJcbiAgICAgICAgICBsb2dnZXIud2FybignY2hhbmdlIG1wZWcgYXVkaW8gdGltZXN0YW1wIG9mZnNldCBmcm9tICcgKyBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgKyAnIHRvICcgKyBkYXRhLnN0YXJ0KTtcclxuICAgICAgICAgIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCA9IGRhdGEuc3RhcnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XHJcbiAgICBsZXQgYXVkaW9FeHBlY3RlZCA9IGRhdGEuYXVkaW8sXHJcbiAgICAgICAgdmlkZW9FeHBlY3RlZCA9IGRhdGEudmlkZW8sXHJcbiAgICAgICAgc291cmNlQnVmZmVyTmIgPSAwO1xyXG4gICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxyXG4gICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxyXG4gICAgLy8gaW4gY2FzZSBhbHQgYXVkaW8gaXMgbm90IHVzZWQsIG9ubHkgb25lIEJVRkZFUl9DT0RFQyBldmVudCB3aWxsIGJlIGZpcmVkIGZyb20gbWFpbiBzdHJlYW0gY29udHJvbGxlclxyXG4gICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XHJcbiAgICBpZiAoZGF0YS5hbHRBdWRpbyAmJiAoYXVkaW9FeHBlY3RlZCB8fCB2aWRlb0V4cGVjdGVkKSkge1xyXG4gICAgICBzb3VyY2VCdWZmZXJOYiA9IChhdWRpb0V4cGVjdGVkID8gMSA6IDApICsgKHZpZGVvRXhwZWN0ZWQgPyAxIDogMCk7XHJcbiAgICAgIGxvZ2dlci5sb2coYCR7c291cmNlQnVmZmVyTmJ9IHNvdXJjZUJ1ZmZlcihzKSBleHBlY3RlZGApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA9IHNvdXJjZUJ1ZmZlck5iO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXHJcbiAgICAgIHZhciBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTtcclxuICAgICAgLy9NZWRpYSBTb3VyY2UgbGlzdGVuZXJzXHJcbiAgICAgIHRoaXMub25tc28gPSB0aGlzLm9uTWVkaWFTb3VyY2VPcGVuLmJpbmQodGhpcyk7XHJcbiAgICAgIHRoaXMub25tc2UgPSB0aGlzLm9uTWVkaWFTb3VyY2VFbmRlZC5iaW5kKHRoaXMpO1xyXG4gICAgICB0aGlzLm9ubXNjID0gdGhpcy5vbk1lZGlhU291cmNlQ2xvc2UuYmluZCh0aGlzKTtcclxuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xyXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xyXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xyXG4gICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcclxuICAgICAgbWVkaWEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xyXG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xyXG4gICAgdmFyIG1zID0gdGhpcy5tZWRpYVNvdXJjZTtcclxuICAgIGlmIChtcykge1xyXG4gICAgICBpZiAobXMucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcclxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxyXG4gICAgICAgICAgLy8gYXMgd2UgYXJlIGFueXdheSBkZXRhY2hpbmcgdGhlIE1lZGlhU291cmNlXHJcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxyXG4gICAgICAgICAgbXMuZW5kT2ZTdHJlYW0oKTtcclxuICAgICAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG9uTWVkaWFEZXRhY2hpbmc6JHtlcnIubWVzc2FnZX0gd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XHJcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XHJcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XHJcblxyXG4gICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcclxuICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cclxuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcclxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMubWVkaWEuc3JjKTtcclxuICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XHJcbiAgICAgICAgdGhpcy5tZWRpYS5sb2FkKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xyXG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcclxuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XHJcbiAgICAgIHRoaXMudHJhY2tzID0ge307XHJcbiAgICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XHJcbiAgICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xyXG4gICAgICB0aGlzLnNlZ21lbnRzID0gW107XHJcbiAgICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xyXG4gICAgfVxyXG4gICAgdGhpcy5vbm1zbyA9IHRoaXMub25tc2UgPSB0aGlzLm9ubXNjID0gbnVsbDtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUVESUFfREVUQUNIRUQpO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYVNvdXJjZU9wZW4oKSB7XHJcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50Lk1FRElBX0FUVEFDSEVELCB7IG1lZGlhIDogdGhpcy5tZWRpYSB9KTtcclxuICAgIGxldCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XHJcbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcclxuICAgICAgLy8gb25jZSByZWNlaXZlZCwgZG9uJ3QgbGlzdGVuIGFueW1vcmUgdG8gc291cmNlb3BlbiBldmVudFxyXG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xyXG4gIH1cclxuXHJcbiAgY2hlY2tQZW5kaW5nVHJhY2tzKCkge1xyXG4gICAgLy8gaWYgYW55IGJ1ZmZlciBjb2RlY3MgcGVuZGluZywgY2hlY2sgaWYgd2UgaGF2ZSBlbm91Z2ggdG8gY3JlYXRlIHNvdXJjZUJ1ZmZlcnNcclxuICAgIGxldCBwZW5kaW5nVHJhY2tzID0gdGhpcy5wZW5kaW5nVHJhY2tzLFxyXG4gICAgICAgIHBlbmRpbmdUcmFja3NOYiA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcclxuICAgIC8vIGlmIGFueSBwZW5kaW5nIHRyYWNrcyBhbmQgKGlmIG5iIG9mIHBlbmRpbmcgdHJhY2tzIGd0IG9yIGVxdWFsIHRoYW4gZXhwZWN0ZWQgbmIgb3IgaWYgdW5rbm93biBleHBlY3RlZCBuYilcclxuICAgIGlmIChwZW5kaW5nVHJhY2tzTmIgJiYgKFxyXG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyTmIgPD0gcGVuZGluZ1RyYWNrc05iIHx8XHJcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA9PT0gMCkpIHtcclxuICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXHJcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcclxuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XHJcbiAgICAgIC8vIGFwcGVuZCBhbnkgcGVuZGluZyBzZWdtZW50cyBub3cgIVxyXG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhU291cmNlQ2xvc2UoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgY2xvc2VkJyk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhU291cmNlRW5kZWQoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZW5kZWQnKTtcclxuICB9XHJcblxyXG5cclxuICBvblNCVXBkYXRlRW5kKCkge1xyXG4gICAgLy8gdXBkYXRlIHRpbWVzdGFtcE9mZnNldFxyXG4gICAgaWYgKHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpIHtcclxuICAgICAgbGV0IGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XHJcbiAgICAgIGxvZ2dlci53YXJuKCdjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gJyArIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCArICcgdG8gJyArIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpO1xyXG4gICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xyXG4gICAgICBkZWxldGUgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbmVlZHNGbHVzaCkge1xyXG4gICAgICB0aGlzLmRvRmx1c2goKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbmVlZHNFb3MpIHtcclxuICAgICAgdGhpcy5jaGVja0VvcygpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hcHBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgIC8vIGNvdW50IG5iIG9mIHBlbmRpbmcgc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIG9uIHRoaXMgc291cmNlYnVmZmVyXHJcbiAgICBsZXQgcGVuZGluZyA9IHRoaXMuc2VnbWVudHMucmVkdWNlKCAoY291bnRlciwgc2VnbWVudCkgPT4gKHNlZ21lbnQucGFyZW50ID09PSBwYXJlbnQpID8gY291bnRlciArIDEgOiBjb3VudGVyICwgMCk7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRFRCwgeyBwYXJlbnQgOiBwYXJlbnQsIHBlbmRpbmcgOiBwZW5kaW5nIH0pO1xyXG5cclxuICAgIC8vIGRvbid0IGFwcGVuZCBpbiBmbHVzaGluZyBtb2RlXHJcbiAgICBpZiAoIXRoaXMuX25lZWRzRmx1c2gpIHtcclxuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcclxuICB9XHJcblxyXG4gIG9uU0JVcGRhdGVFcnJvcihldmVudCkge1xyXG4gICAgbG9nZ2VyLmVycm9yKCdzb3VyY2VCdWZmZXIgZXJyb3I6JywgZXZlbnQpO1xyXG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxyXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcclxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2V9KTtcclxuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gbW9yZSB0aGFuIHRoYXQsIGFzIGFjY29yZGluIHRvIHRoZSBzcGVjLCB1cGRhdGVlbmQgd2lsbCBiZSBmaXJlZCBqdXN0IGFmdGVyXHJcbiAgfVxyXG5cclxuICBvbkJ1ZmZlclJlc2V0KCkge1xyXG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgZm9yKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xyXG4gICAgICB2YXIgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xyXG4gICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcclxuICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xyXG4gICAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xyXG4gICAgdGhpcy5mbHVzaFJhbmdlID0gW107XHJcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XHJcbiAgICB0aGlzLmFwcGVuZGVkID0gMDtcclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQ29kZWNzKHRyYWNrcykge1xyXG4gICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXHJcbiAgICAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cclxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHsgdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFja3NbdHJhY2tOYW1lXTsgfVxyXG4gICAgICBsZXQgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xyXG4gICAgICBpZiAobWVkaWFTb3VyY2UgJiYgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJzIGlmIG1lZGlhc291cmNlIG9wZW5lZFxyXG4gICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBjcmVhdGVTb3VyY2VCdWZmZXJzKHRyYWNrcykge1xyXG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcclxuXHJcbiAgICBmb3IgKGxldCB0cmFja05hbWUgaW4gdHJhY2tzKSB7XHJcbiAgICAgIGlmKCFzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSkge1xyXG4gICAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xyXG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XHJcbiAgICAgICAgbGV0IGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcclxuICAgICAgICBsZXQgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgY3JlYXRpbmcgc291cmNlQnVmZmVyKCR7bWltZVR5cGV9KWApO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsZXQgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XHJcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uc2J1ZSk7XHJcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xyXG4gICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHtjb2RlYzogY29kZWMsIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyfTtcclxuICAgICAgICAgIHRyYWNrLmJ1ZmZlciA9IHNiO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IsIGZhdGFsOiBmYWxzZSwgZXJyOiBlcnIsIG1pbWVUeXBlIDogbWltZVR5cGV9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NSRUFURUQsIHsgdHJhY2tzIDogdHJhY2tzIH0gKTtcclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQXBwZW5kaW5nKGRhdGEpIHtcclxuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xyXG4gICAgICBpZiAoIXRoaXMuc2VnbWVudHMpIHtcclxuICAgICAgICB0aGlzLnNlZ21lbnRzID0gWyBkYXRhIF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQXBwZW5kRmFpbChkYXRhKSB7XHJcbiAgICBsb2dnZXIuZXJyb3IoJ3NvdXJjZUJ1ZmZlciBlcnJvcjonLGRhdGEuZXZlbnQpO1xyXG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxyXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcclxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2V9KTtcclxuICB9XHJcblxyXG4gIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxyXG4gIG9uQnVmZmVyRW9zKGRhdGEpIHtcclxuICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgbGV0IGRhdGFUeXBlID0gZGF0YS50eXBlO1xyXG4gICAgZm9yKGxldCB0eXBlIGluIHNiKSB7XHJcbiAgICAgIGlmICghZGF0YVR5cGUgfHwgdHlwZSA9PT0gZGF0YVR5cGUpIHtcclxuICAgICAgICBpZiAoIXNiW3R5cGVdLmVuZGVkKSB7XHJcbiAgICAgICAgICBzYlt0eXBlXS5lbmRlZCA9IHRydWU7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGAke3R5cGV9IHNvdXJjZUJ1ZmZlciBub3cgRU9TYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmNoZWNrRW9zKCk7XHJcbiAgfVxyXG5cclxuIC8vIGlmIGFsbCBzb3VyY2UgYnVmZmVycyBhcmUgbWFya2VkIGFzIGVuZGVkLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZS5cclxuIGNoZWNrRW9zKCkge1xyXG4gICAgdmFyIHNiID0gdGhpcy5zb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcclxuICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XHJcbiAgICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvcihsZXQgdHlwZSBpbiBzYikge1xyXG4gICAgICBsZXQgc2JvYmogPSBzYlt0eXBlXTtcclxuICAgICAgaWYgKCFzYm9iai5lbmRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZihzYm9iai51cGRhdGluZykge1xyXG4gICAgICAgIHRoaXMuX25lZWRzRW9zID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGxvZ2dlci5sb2coJ2FsbCBtZWRpYSBkYXRhIGF2YWlsYWJsZSwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UgYW5kIHN0b3AgbG9hZGluZyBmcmFnbWVudCcpO1xyXG4gICAgLy9Ob3RpZnkgdGhlIG1lZGlhIGVsZW1lbnQgdGhhdCBpdCBub3cgaGFzIGFsbCBvZiB0aGUgbWVkaWEgZGF0YVxyXG4gICAgdHJ5IHtcclxuICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcclxuICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICBsb2dnZXIud2FybignZXhjZXB0aW9uIHdoaWxlIGNhbGxpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKScpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcclxuIH1cclxuXHJcblxyXG4gIG9uQnVmZmVyRmx1c2hpbmcoZGF0YSkge1xyXG4gICAgdGhpcy5mbHVzaFJhbmdlLnB1c2goe3N0YXJ0OiBkYXRhLnN0YXJ0T2Zmc2V0LCBlbmQ6IGRhdGEuZW5kT2Zmc2V0LCB0eXBlIDogZGF0YS50eXBlfSk7XHJcbiAgICAvLyBhdHRlbXB0IGZsdXNoIGltbWVkaWF0bHlcclxuICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcclxuICAgIHRoaXMuZG9GbHVzaCgpO1xyXG4gIH1cclxuXHJcbiAgb25MZXZlbFVwZGF0ZWQoZXZlbnQpIHtcclxuICAgIGxldCBkZXRhaWxzID0gZXZlbnQuZGV0YWlscztcclxuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbiArIGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xyXG4gICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzM1NVxyXG4gIHVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCkge1xyXG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSxcclxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsXHJcbiAgICAgICAgbGV2ZWxEdXJhdGlvbiA9IHRoaXMuX2xldmVsRHVyYXRpb247XHJcbiAgICBpZiAobGV2ZWxEdXJhdGlvbiA9PT0gbnVsbCB8fCAhbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzb3VyY2VCdWZmZXIgfHwgbWVkaWEucmVhZHlTdGF0ZSA9PT0gMCB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcclxuICAgICAgaWYgKHNvdXJjZUJ1ZmZlclt0eXBlXS51cGRhdGluZykge1xyXG4gICAgICAgIC8vIGNhbid0IHNldCBkdXJhdGlvbiB3aGlsc3QgYSBidWZmZXIgaXMgdXBkYXRpbmdcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9tc0R1cmF0aW9uID09PSBudWxsKSB7XHJcbiAgICAgIC8vIGluaXRpYWxpc2UgdG8gdGhlIHZhbHVlIHRoYXQgdGhlIG1lZGlhIHNvdXJjZSBpcyByZXBvcnRpbmdcclxuICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IG1lZGlhU291cmNlLmR1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgbGV0IGR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XHJcbiAgICAvLyBsZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXHJcbiAgICAvLyBub3QgdXNpbmcgbWVkaWFTb3VyY2UuZHVyYXRpb24gYXMgdGhlIGJyb3dzZXIgbWF5IHR3ZWFrIHRoaXMgdmFsdWVcclxuICAgIC8vIG9ubHkgdXBkYXRlIG1lZGlhc291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxyXG4gICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxyXG4gICAgaWYgKChsZXZlbER1cmF0aW9uID4gdGhpcy5fbXNEdXJhdGlvbiAmJiBsZXZlbER1cmF0aW9uID4gZHVyYXRpb24pIHx8IChkdXJhdGlvbiA9PT0gSW5maW5pdHkgfHwgaXNOYU4oZHVyYXRpb24pICkpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhgVXBkYXRpbmcgbWVkaWFzb3VyY2UgZHVyYXRpb24gdG8gJHtsZXZlbER1cmF0aW9uLnRvRml4ZWQoMyl9YCk7XHJcbiAgICAgIHRoaXMuX21zRHVyYXRpb24gPSBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGxldmVsRHVyYXRpb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb0ZsdXNoKCkge1xyXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBidWZmZXIgcmFuZ2VzIHRvIGZsdXNoXHJcbiAgICB3aGlsZSh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoKSB7XHJcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZmx1c2hSYW5nZVswXTtcclxuICAgICAgLy8gZmx1c2hCdWZmZXIgd2lsbCBhYm9ydCBhbnkgYnVmZmVyIGFwcGVuZCBpbiBwcm9ncmVzcyBhbmQgZmx1c2ggQXVkaW8vVmlkZW8gQnVmZmVyXHJcbiAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIHJhbmdlLnR5cGUpKSB7XHJcbiAgICAgICAgLy8gcmFuZ2UgZmx1c2hlZCwgcmVtb3ZlIGZyb20gZmx1c2ggYXJyYXlcclxuICAgICAgICB0aGlzLmZsdXNoUmFuZ2Uuc2hpZnQoKTtcclxuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IHRydWU7XHJcbiAgICAgICAgLy8gYXZvaWQgbG9vcGluZywgd2FpdCBmb3IgU0IgdXBkYXRlIGVuZCB0byByZXRyaWdnZXIgYSBmbHVzaFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkXHJcbiAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIGxldCdzIHJlY29tcHV0ZSB0aGlzLmFwcGVuZGVkLCB3aGljaCBpcyB1c2VkIHRvIGF2b2lkIGZsdXNoIGxvb3BpbmdcclxuICAgICAgdmFyIGFwcGVuZGVkID0gMDtcclxuICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XHJcbiAgICAgICAgICBhcHBlbmRlZCArPSBzb3VyY2VCdWZmZXJbdHlwZV0uYnVmZmVyZWQubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaChlcnJvcikge1xyXG4gICAgICAgIC8vIGVycm9yIGNvdWxkIGJlIHRocm93biB3aGlsZSBhY2Nlc3NpbmcgYnVmZmVyZWQsIGluIGNhc2Ugc291cmNlYnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBmcm9tIE1lZGlhU291cmNlXHJcbiAgICAgICAgLy8gdGhpcyBpcyBoYXJtZXNzIGF0IHRoaXMgc3RhZ2UsIGNhdGNoIHRoaXMgdG8gYXZvaWQgcmVwb3J0aW5nIGFuIGludGVybmFsIGV4Y2VwdGlvblxyXG4gICAgICAgIGxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgYWNjZXNzaW5nIHNvdXJjZUJ1ZmZlci5idWZmZXJlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYXBwZW5kZWQgPSBhcHBlbmRlZDtcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hFRCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb0FwcGVuZGluZygpIHtcclxuICAgIHZhciBobHMgPSB0aGlzLmhscywgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcclxuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xyXG4gICAgICBpZiAodGhpcy5tZWRpYS5lcnJvcikge1xyXG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoJ3RyeWluZyB0byBhcHBlbmQgYWx0aG91Z2ggYSBtZWRpYSBlcnJvciBvY2N1cmVkLCBmbHVzaCBzZWdtZW50IGFuZCBhYm9ydCcpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5hcHBlbmRpbmcpIHtcclxuICAgICAgICAvL2xvZ2dlci5sb2coYHNiIGFwcGVuZGluZyBpbiBwcm9ncmVzc2ApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IHNlZ21lbnQgPSBzZWdtZW50cy5zaGlmdCgpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsZXQgdHlwZSA9IHNlZ21lbnQudHlwZSwgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XHJcbiAgICAgICAgICBpZihzYikge1xyXG4gICAgICAgICAgICBpZighc2IudXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAvLyByZXNldCBzb3VyY2VCdWZmZXIgZW5kZWQgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIHNlZ21lbnRcclxuICAgICAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgYXBwZW5kaW5nICR7c2VnbWVudC5jb250ZW50fSAke3R5cGV9IFNCLCBzaXplOiR7c2VnbWVudC5kYXRhLmxlbmd0aH0sICR7c2VnbWVudC5wYXJlbnR9YCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBzZWdtZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICBzYi5hcHBlbmRCdWZmZXIoc2VnbWVudC5kYXRhKTtcclxuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcclxuICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkKys7XHJcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoc2VnbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgc291cmNlIGJ1ZmZlciBtYXRjaGluZyB3aXRoIHRoaXMgc2VnbWVudCB0eXBlLFxyXG4gICAgICAgICAgICAvLyBpdCBtZWFucyB0aGF0IE1lZGlhc291cmNlIGZhaWxzIHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJcclxuICAgICAgICAgICAgLy8gZGlzY2FyZCB0aGlzIHNlZ21lbnQsIGFuZCB0cmlnZ2VyIHVwZGF0ZSBlbmRcclxuICAgICAgICAgICAgdGhpcy5vblNCVXBkYXRlRW5kKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXHJcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhcHBlbmQgYnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICBzZWdtZW50cy51bnNoaWZ0KHNlZ21lbnQpO1xyXG4gICAgICAgICAgdmFyIGV2ZW50ID0ge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIHBhcmVudCA6IHNlZ21lbnQucGFyZW50fTtcclxuICAgICAgICAgIGlmKGVyci5jb2RlICE9PSAyMikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvcikge1xyXG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XHJcbiAgICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXHJcbiAgICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gcmV0cnlpbmcgaGVscCByZWNvdmVyaW5nIHRoaXNcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IgPiBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkpIHtcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBmYWlsICR7aGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJgKTtcclxuICAgICAgICAgICAgICBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcclxuICAgICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXHJcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcclxuICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsZXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAgZmx1c2ggc3BlY2lmaWVkIGJ1ZmZlcmVkIHJhbmdlLFxyXG4gICAgcmV0dXJuIHRydWUgb25jZSByYW5nZSBoYXMgYmVlbiBmbHVzaGVkLlxyXG4gICAgYXMgc291cmNlQnVmZmVyLnJlbW92ZSgpIGlzIGFzeW5jaHJvbm91cywgZmx1c2hCdWZmZXIgd2lsbCBiZSByZXRyaWdnZXJlZCBvbiBzb3VyY2VCdWZmZXIgdXBkYXRlIGVuZFxyXG4gICovXHJcbiAgZmx1c2hCdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZUluKSB7XHJcbiAgICB2YXIgc2IsIGksIGJ1ZlN0YXJ0LCBidWZFbmQsIGZsdXNoU3RhcnQsIGZsdXNoRW5kLCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcclxuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xyXG4gICAgICBsb2dnZXIubG9nKGBmbHVzaEJ1ZmZlcixwb3Mvc3RhcnQvZW5kOiAke3RoaXMubWVkaWEuY3VycmVudFRpbWUudG9GaXhlZCgzKX0vJHtzdGFydE9mZnNldH0vJHtlbmRPZmZzZXR9YCk7XHJcbiAgICAgIC8vIHNhZmVndWFyZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIDogZG9uJ3QgdHJ5IHRvIGZsdXNoIG1vcmUgdGhhbiB0aGUgbmIgb2YgYXBwZW5kZWQgc2VnbWVudHNcclxuICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyIDwgdGhpcy5hcHBlbmRlZCkge1xyXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XHJcbiAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2VidWZmZXIgdHlwZSBpcyBkZWZpbmVkICh0eXBlSW4pOiBpZiB5ZXMsIGxldCdzIG9ubHkgZmx1c2ggdGhpcyBvbmVcclxuICAgICAgICAgIC8vIGlmIG5vLCBsZXQncyBmbHVzaCBhbGwgc291cmNlYnVmZmVyc1xyXG4gICAgICAgICAgaWYgKHR5cGVJbiAmJiB0eXBlICE9PSB0eXBlSW4pIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcclxuICAgICAgICAgIC8vIHdlIGFyZSBnb2luZyB0byBmbHVzaCBidWZmZXIsIG1hcmsgc291cmNlIGJ1ZmZlciBhcyAnbm90IGVuZGVkJ1xyXG4gICAgICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2IuYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGJ1ZlN0YXJ0ID0gc2IuYnVmZmVyZWQuc3RhcnQoaSk7XHJcbiAgICAgICAgICAgICAgICBidWZFbmQgPSBzYi5idWZmZXJlZC5lbmQoaSk7XHJcbiAgICAgICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZpcmVmb3ggbm90IGFibGUgdG8gcHJvcGVybHkgZmx1c2ggbXVsdGlwbGUgYnVmZmVyZWQgcmFuZ2UuXHJcbiAgICAgICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEgJiYgZW5kT2Zmc2V0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgICAgICAgICAgICAgZmx1c2hTdGFydCA9IHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICBmbHVzaEVuZCA9IGVuZE9mZnNldDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGZsdXNoU3RhcnQgPSBNYXRoLm1heChidWZTdGFydCwgc3RhcnRPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICBmbHVzaEVuZCA9IE1hdGgubWluKGJ1ZkVuZCwgZW5kT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qIHNvbWV0aW1lcyBzb3VyY2VidWZmZXIucmVtb3ZlKCkgZG9lcyBub3QgZmx1c2hcclxuICAgICAgICAgICAgICAgICAgIHRoZSBleGFjdCBleHBlY3RlZCB0aW1lIHJhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzL2luZmluaXRlIGxvb3AsXHJcbiAgICAgICAgICAgICAgICAgICBvbmx5IGZsdXNoIGJ1ZmZlciByYW5nZSBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDUwMG1zLlxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihmbHVzaEVuZCxidWZFbmQpIC0gZmx1c2hTdGFydCA+IDAuNSApIHtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgZmx1c2ggJHt0eXBlfSBbJHtmbHVzaFN0YXJ0fSwke2ZsdXNoRW5kfV0sIG9mIFske2J1ZlN0YXJ0fSwke2J1ZkVuZH1dLCBwb3M6JHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICBzYi5yZW1vdmUoZmx1c2hTdGFydCwgZmx1c2hFbmQpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICBsb2dnZXIud2FybignZXhjZXB0aW9uIHdoaWxlIGFjY2Vzc2luZyBzb3VyY2VidWZmZXIsIGl0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gTWVkaWFTb3VyY2UnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdhYm9ydCAnICsgdHlwZSArICcgYXBwZW5kIGluIHByb2dyZXNzJyk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhYm9ydCBhbnkgYXBwZW5kaW5nIGluIHByb2dyZXNzXHJcbiAgICAgICAgICAgIC8vc2IuYWJvcnQoKTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2Nhbm5vdCBmbHVzaCwgc2IgdXBkYXRpbmcgaW4gcHJvZ3Jlc3MnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsb2dnZXIud2FybignYWJvcnQgZmx1c2hpbmcgdG9vIG1hbnkgcmV0cmllcycpO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZ2dlci5sb2coJ2J1ZmZlciBmbHVzaGVkJyk7XHJcbiAgICB9XHJcbiAgICAvLyBldmVyeXRoaW5nIGZsdXNoZWQgIVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJDb250cm9sbGVyO1xyXG4iLCIvKlxyXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5cclxuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHRjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscyxcclxuICAgICAgRXZlbnQuRlBTX0RST1BfTEVWRUxfQ0FQUElORyxcclxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQpO1xyXG5cdH1cclxuXHJcblx0ZGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcclxuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMucmVzdHJpY3RlZExldmVscyA9IG51bGw7XHJcbiAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgICB0aGlzLnRpbWVyID0gY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcHNEcm9wTGV2ZWxDYXBwaW5nKGRhdGEpIHtcclxuICAgIGlmICghdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSB7XHJcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLmlzTGV2ZWxSZXN0cmljdGVkKGRhdGEuZHJvcHBlZExldmVsKSkge1xyXG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaChkYXRhLmRyb3BwZWRMZXZlbCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHRvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcclxuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XHJcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcclxuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XHJcbiAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcclxuICAgICAgaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKGRhdGEuZmlyc3RMZXZlbCk7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XHJcbiAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGV0ZWN0UGxheWVyU2l6ZSgpIHtcclxuICAgIGlmICh0aGlzLm1lZGlhKSB7XHJcbiAgICAgIGxldCBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XHJcbiAgICAgIGlmIChsZXZlbHNMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcclxuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgaWYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XHJcbiAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxyXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxyXG4gICAgICAgICAgaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcclxuICAqL1xyXG4gIGdldE1heExldmVsKGNhcExldmVsSW5kZXgpIHtcclxuICAgIGxldCByZXN1bHQgPSAwLFxyXG4gICAgICAgIGksXHJcbiAgICAgICAgbGV2ZWwsXHJcbiAgICAgICAgbVdpZHRoID0gdGhpcy5tZWRpYVdpZHRoLFxyXG4gICAgICAgIG1IZWlnaHQgPSB0aGlzLm1lZGlhSGVpZ2h0LFxyXG4gICAgICAgIGxXaWR0aCA9IDAsXHJcbiAgICAgICAgbEhlaWdodCA9IDA7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8PSBjYXBMZXZlbEluZGV4OyBpKyspIHtcclxuICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsc1tpXTtcclxuICAgICAgaWYgKHRoaXMuaXNMZXZlbFJlc3RyaWN0ZWQoaSkpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXN1bHQgPSBpO1xyXG4gICAgICBsV2lkdGggPSBsZXZlbC53aWR0aDtcclxuICAgICAgbEhlaWdodCA9IGxldmVsLmhlaWdodDtcclxuICAgICAgaWYgKG1XaWR0aCA8PSBsV2lkdGggfHwgbUhlaWdodCA8PSBsSGVpZ2h0KSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBpc0xldmVsUmVzdHJpY3RlZChsZXZlbCkge1xyXG4gICAgcmV0dXJuICh0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgJiYgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpICE9PSAtMSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgfVxyXG5cclxuICBnZXQgY29udGVudFNjYWxlRmFjdG9yKCkge1xyXG4gICAgbGV0IHBpeGVsUmF0aW8gPSAxO1xyXG4gICAgdHJ5IHtcclxuICAgICAgcGl4ZWxSYXRpbyA9ICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIH0gY2F0Y2goZSkge31cclxuICAgIHJldHVybiBwaXhlbFJhdGlvO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG1lZGlhV2lkdGgoKSB7XHJcbiAgICBsZXQgd2lkdGg7XHJcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgd2lkdGggPSBtZWRpYS53aWR0aCB8fCBtZWRpYS5jbGllbnRXaWR0aCB8fCBtZWRpYS5vZmZzZXRXaWR0aDtcclxuICAgICAgd2lkdGggKj0gdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gd2lkdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgbWVkaWFIZWlnaHQoKSB7XHJcbiAgICBsZXQgaGVpZ2h0O1xyXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgIGhlaWdodCA9IG1lZGlhLmhlaWdodCB8fCBtZWRpYS5jbGllbnRIZWlnaHQgfHwgbWVkaWEub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICBoZWlnaHQgKj0gdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGVpZ2h0O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FwTGV2ZWxDb250cm9sbGVyO1xyXG4iLCIvKlxyXG4gKiBGUFMgQ29udHJvbGxlclxyXG4qL1xyXG5cclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuY2xhc3MgRlBTQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlcntcclxuXHJcbiAgY29uc3RydWN0b3IoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsIEV2ZW50Lk1FRElBX0FUVEFDSElORyk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgIH1cclxuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XHJcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XHJcbiAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XHJcbiAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy52aWRlbyA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XHJcbiAgICAgIGlmICh0eXBlb2YgdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNoZWNrRlBTKHZpZGVvLCBkZWNvZGVkRnJhbWVzLCBkcm9wcGVkRnJhbWVzKSB7XHJcbiAgICBsZXQgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIGlmIChkZWNvZGVkRnJhbWVzKSB7XHJcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRQZXJpb2QgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUsXHJcbiAgICAgICAgICAgIGN1cnJlbnREcm9wcGVkID0gZHJvcHBlZEZyYW1lcyAtIHRoaXMubGFzdERyb3BwZWRGcmFtZXMsXHJcbiAgICAgICAgICAgIGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXMsXHJcbiAgICAgICAgICAgIGRyb3BwZWRGUFMgPSAxMDAwICogY3VycmVudERyb3BwZWQgLyBjdXJyZW50UGVyaW9kLFxyXG4gICAgICAgICAgICBobHMgPSB0aGlzLmhscztcclxuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUFNfRFJPUCwge2N1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXN9KTtcclxuICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcclxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcclxuICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IGhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQgKiBjdXJyZW50RGVjb2RlZCkge1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gaGxzLmN1cnJlbnRMZXZlbDtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2Ryb3AgRlBTIHJhdGlvIGdyZWF0ZXIgdGhhbiBtYXggYWxsb3dlZCB2YWx1ZSBmb3IgY3VycmVudExldmVsOiAnICsgY3VycmVudExldmVsKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsIC0gMTtcclxuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7bGV2ZWw6IGN1cnJlbnRMZXZlbCwgZHJvcHBlZExldmVsOiBobHMuY3VycmVudExldmVsfSk7XHJcbiAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XHJcbiAgICAgICAgICAgICAgaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gZHJvcHBlZEZyYW1lcztcclxuICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjaGVja0ZQU0ludGVydmFsKCkge1xyXG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLnZpZGVvO1xyXG4gICAgaWYgKHZpZGVvKSB7XHJcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcclxuICAgICAgICBsZXQgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW8ud2Via2l0RGVjb2RlZEZyYW1lQ291bnQsIHZpZGVvLndlYmtpdERyb3BwZWRGcmFtZUNvdW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRlBTQ29udHJvbGxlcjtcclxuXHJcbiIsIi8qXG4gKiBpZDMgbWV0YWRhdGEgdHJhY2sgY29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuXG5jbGFzcyBJRDNUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgICAgICAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgICAgICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgICAgICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVkaWEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gQWRkIElEMyBtZXRhdGFkYXRhIHRleHQgdHJhY2suXG4gIG9uTWVkaWFBdHRhY2hlZChkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pZDNUcmFjayA9IHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKCdtZXRhZGF0YScsICdpZDMnKTtcbiAgICB0aGlzLmlkM1RyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdNZXRhZGF0YShkYXRhKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBkYXRhLmZyYWc7XG4gICAgY29uc3Qgc2FtcGxlcyA9IGRhdGEuc2FtcGxlcztcbiAgICBjb25zdCBzdGFydFRpbWUgPSBmcmFnbWVudC5zdGFydDtcbiAgICBsZXQgZW5kVGltZSA9IGZyYWdtZW50LnN0YXJ0ICsgZnJhZ21lbnQuZHVyYXRpb247XG4gICAgLy8gR2l2ZSBhIHNsaWdodCBidW1wIHRvIHRoZSBlbmRUaW1lIGlmIGl0J3MgZXF1YWwgdG8gc3RhcnRUaW1lIHRvIGF2b2lkIGEgU3ludGF4RXJyb3IgaW4gSUVcbiAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKSB7XG4gICAgICBlbmRUaW1lICs9IDAuMDAwMTtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IHRvIHJlY3JlYXRlIFNhZmFyaSBmdW5jdGlvbmFsaXR5IGJ5IGNyZWF0aW5nXG4gICAgLy8gV2ViS2l0RGF0YUN1ZSBvYmplY3RzIHdoZW4gYXZhaWxhYmxlIGFuZCBzdG9yZSB0aGUgZGVjb2RlZFxuICAgIC8vIElEMyBkYXRhIGluIHRoZSB2YWx1ZSBwcm9wZXJ0eSBvZiB0aGUgY3VlXG4gICAgbGV0IEN1ZSA9IHdpbmRvdy5XZWJLaXREYXRhQ3VlIHx8IHdpbmRvdy5WVFRDdWUgfHwgd2luZG93LlRleHRUcmFja0N1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZnJhbWVzID0gdGhpcy5wYXJzZUlEM1RhZyhzYW1wbGVzW2ldLmRhdGEpO1xuICAgICAgaWYgKGZyYW1lcykge1xuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgZnJhbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsICcnKTtcbiAgICAgICAgICBjdWUudmFsdWUgPSBmcmFtZXNbal07XG4gICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlSUQzVGFnKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAxMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVzID0gW107XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8qIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgICAgWzBdICAgICA9ICdJJ1xuICAgICAgWzFdICAgICA9ICdEJ1xuICAgICAgWzJdICAgICA9ICczJ1xuICAgICAgWzMsNF0gICA9IHtWZXJzaW9ufVxuICAgICAgWzVdICAgICA9IHtGbGFnc31cbiAgICAgIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAgICAqL1xuICAgICAgY29uc3QgaGVhZGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW29mZnNldCsrXSwgZGF0YVtvZmZzZXQrK10sIGRhdGFbb2Zmc2V0KytdKTtcbiAgICAgIGlmIChoZWFkZXIgPT09ICdJRDMnKSB7XG5cbiAgICAgICAgLy9za2lwIHZlcnNpb24gYW5kIGZsYWdzXG4gICAgICAgIG9mZnNldCArPSAzO1xuXG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgc2l6ZSAgPSAoKGRhdGFbb2Zmc2V0KytdICYgMHg3ZikgPDwgMjEpO1xuICAgICAgICBzaXplIHw9ICgoZGF0YVtvZmZzZXQrK10gJiAweDdmKSA8PCAxNCk7XG4gICAgICAgIHNpemUgfD0gKChkYXRhW29mZnNldCsrXSAmIDB4N2YpIDw8IDcpO1xuICAgICAgICBzaXplIHw9ICAoZGF0YVtvZmZzZXQrK10gJiAweDdmKTtcblxuICAgICAgICBjb25zdCBkZWNvZGVkRnJhbWVzID0gdGhpcy5kZWNvZGVJRDNGcmFtZXMoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpKTtcbiAgICAgICAgZnJhbWVzID0gZnJhbWVzLmNvbmNhdChkZWNvZGVkRnJhbWVzKTtcblxuICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZGVyID09PSAnM0RJJykge1xuICAgICAgICAvL2Zvb3RlciBpcyBzYW1lIHNpemUgYXMgaGVhZGVyXG4gICAgICAgIG9mZnNldCArPSA3O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFtZXM7XG4gIH1cblxuICBkZWNvZGVJRDNGcmFtZXMoZGF0YSkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBmcmFtZXMgPSBbXTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgLypcbiAgICAgIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxuICAgICAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XG4gICAgICBGbGFncyAgICAgICAgICAkeHggeHhcbiAgICAgICovXG4gICAgICBjb25zdCB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW29mZnNldCsrXSwgZGF0YVtvZmZzZXQrK10sIGRhdGFbb2Zmc2V0KytdLCBkYXRhW29mZnNldCsrXSk7XG5cbiAgICAgIGxldCBzaXplID0gMDtcbiAgICAgIHNpemUgID0gKChkYXRhW29mZnNldCsrXSAmIDB4N2YpIDw8IDIxKTtcbiAgICAgIHNpemUgfD0gKChkYXRhW29mZnNldCsrXSAmIDB4N2YpIDw8IDE0KTtcbiAgICAgIHNpemUgfD0gKChkYXRhW29mZnNldCsrXSAmIDB4N2YpIDw8IDcpO1xuICAgICAgc2l6ZSB8PSAgKGRhdGFbb2Zmc2V0KytdICYgMHg3Zik7XG5cbiAgICAgIC8vc2tpcCBmbGFnc1xuICAgICAgb2Zmc2V0Kz0yO1xuXG4gICAgICBjb25zdCBmcmFtZSA9IHRoaXMuZGVjb2RlSUQzRnJhbWUoeyB0eXBlLCBzaXplLCBkYXRhOiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSkgfSk7XG4gICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lcztcbiAgfVxuXG4gIGRlY29kZUlEM0ZyYW1lKGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlVHh4eEZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdUJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlVGV4dEZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGUgPT09ICdXWFhYJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlV1hYWEZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlVVJMTGlua0ZyYW1lKGZyYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZGVjb2RlVHh4eEZyYW1lKGZyYW1lKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6XG4gICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VmFsdWV9XG4gICAgKi9cblxuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZnJhbWUuZGF0YVswXSAhPT0gMykge1xuICAgICAgLy9vbmx5IHN1cHBvcnQgVVRGLThcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gMTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMudXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcbiAgfVxuXG4gIGRlY29kZVRleHRGcmFtZShmcmFtZSkge1xuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgWzEtP10gPSB7VmFsdWV9XG4gICAgKi9cblxuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZnJhbWUuZGF0YVswXSAhPT0gMykge1xuICAgICAgLy9vbmx5IHN1cHBvcnQgVVRGLThcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IHRoaXMudXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XG4gICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB0ZXh0IH07XG4gIH1cblxuICBkZWNvZGVQcml2RnJhbWUoZnJhbWUpIHtcbiAgICAvKlxuICAgIEZvcm1hdDogPHRleHQgc3RyaW5nPlxcMDxiaW5hcnkgZGF0YT5cbiAgICAqL1xuXG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IG93bmVyID0gdGhpcy51dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhKTtcbiAgICBjb25zdCBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuXG4gICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBvd25lciwgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyIH07XG4gIH1cblxuICBkZWNvZGVXWFhYRnJhbWUoZnJhbWUpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lLmRhdGFbMF0gIT09IDMpIHtcbiAgICAgIC8vb25seSBzdXBwb3J0IFVURi04XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLnV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcblxuICAgIGluZGV4ICs9IGRlc2NyaXB0aW9uLmxlbmd0aCArIDE7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcblxuICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogZGVzY3JpcHRpb24sIGRhdGE6IHZhbHVlIH07XG4gIH1cblxuICBkZWNvZGVVUkxMaW5rRnJhbWUoZnJhbWUpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMC0/XSAgID0ge1VSTH1cbiAgICAqL1xuICAgIGNvbnN0IHVybCA9IHRoaXMudXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSk7XG4gICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB1cmwgfTtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4gIC8vIGh0dHA6Ly93d3cub25pY29zLmNvbS9zdGFmZi9pei9hbXVzZS9qYXZhc2NyaXB0L2V4cGVydC91dGYudHh0XG4gIC8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxuICAgKlxuICAgKiBDb3B5cmlnaHQgKEMpIDE5OTkgTWFzYW5hbyBJenVtbyA8aXpAb25pY29zLmNvLmpwPlxuICAgKiBWZXJzaW9uOiAxLjBcbiAgICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICAgKiBUaGlzIGxpYnJhcnkgaXMgZnJlZS4gIFlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXQuXG4gICAqL1xuICB1dGY4QXJyYXlUb1N0cihhcnJheSkge1xuXG4gICAgbGV0IGNoYXIyO1xuICAgIGxldCBjaGFyMztcbiAgICBsZXQgb3V0ID0gJyc7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgbGV0IGMgPSBhcnJheVtpKytdO1xuICAgICAgc3dpdGNoIChjID4+IDQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIGNhc2UgMTogY2FzZSAyOiBjYXNlIDM6IGNhc2UgNDogY2FzZSA1OiBjYXNlIDY6IGNhc2UgNzpcbiAgICAgICAgICAvLyAweHh4eHh4eFxuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOiBjYXNlIDEzOlxuICAgICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFGKSA8PCA2KSB8IChjaGFyMiAmIDB4M0YpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDBGKSA8PCAxMikgfFxuICAgICAgICAgICAgKChjaGFyMiAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgICgoY2hhcjMgJiAweDNGKSA8PCAwKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJRDNUcmFja0NvbnRyb2xsZXI7XG4iLCIvKlxyXG4gKiBMZXZlbCBDb250cm9sbGVyXHJcbiovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcclxuXHJcbmNsYXNzIExldmVsQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXHJcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcclxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXHJcbiAgICAgIEV2ZW50LkVSUk9SKTtcclxuICAgIHRoaXMub250aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLl9tYW51YWxMZXZlbCA9IC0xO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLnRpbWVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcclxuICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9tYW51YWxMZXZlbCA9IC0xO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRMb2FkKCkge1xyXG4gICAgdGhpcy5jYW5sb2FkID0gdHJ1ZTtcclxuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XHJcbiAgICAvLyBjbGVhbiB1cCBsaXZlIGxldmVsIGRldGFpbHMgdG8gZm9yY2UgcmVsb2FkIHRoZW0sIGFuZCByZXNldCBsb2FkIGVycm9yc1xyXG4gICAgaWYobGV2ZWxzKSB7XHJcbiAgICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcclxuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xyXG4gICAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XHJcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscyAmJiBsZXZlbERldGFpbHMubGl2ZSkge1xyXG4gICAgICAgICAgbGV2ZWwuZGV0YWlscyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gc3BlZWQgdXAgbGl2ZSBwbGF5bGlzdCByZWZyZXNoIGlmIHRpbWVyIGV4aXN0c1xyXG4gICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdG9wTG9hZCgpIHtcclxuICAgIHRoaXMuY2FubG9hZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XHJcbiAgICB2YXIgbGV2ZWxzMCA9IFtdLFxyXG4gICAgICAgIGxldmVscyA9IFtdLFxyXG4gICAgICAgIGJpdHJhdGVTdGFydCxcclxuICAgICAgICBiaXRyYXRlU2V0ID0ge30sXHJcbiAgICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2UsXHJcbiAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2UsXHJcbiAgICAgICAgaGxzID0gdGhpcy5obHMsXHJcbiAgICAgICAgYnJva2VubXA0aW5tcDMgPSAvY2hyb21lfGZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSxcclxuICAgICAgICBjaGVja1N1cHBvcnRlZCA9IGZ1bmN0aW9uKHR5cGUsY29kZWMpIHsgcmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChgJHt0eXBlfS9tcDQ7Y29kZWNzPSR7Y29kZWN9YCk7fTtcclxuXHJcbiAgICAvLyByZWdyb3VwIHJlZHVuZGFudCBsZXZlbCB0b2dldGhlclxyXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XHJcbiAgICAgIGlmKGxldmVsLnZpZGVvQ29kZWMpIHtcclxuICAgICAgICB2aWRlb0NvZGVjRm91bmQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGVyYXNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQuIGRlbXV4ZXIgd2lsbCBhdXRvZGV0ZWN0IGNvZGVjIGFuZCBmYWxsYmFjayB0byBtcGVnL2F1ZGlvXHJcbiAgICAgIGlmKGJyb2tlbm1wNGlubXAzICYmIGxldmVsLmF1ZGlvQ29kZWMgJiYgbGV2ZWwuYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjM0JykgIT09IC0xKSB7XHJcbiAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZihsZXZlbC5hdWRpb0NvZGVjIHx8IChsZXZlbC5hdHRycyAmJiBsZXZlbC5hdHRycy5BVURJTykpIHtcclxuICAgICAgICBhdWRpb0NvZGVjRm91bmQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCByZWR1bmRhbnRMZXZlbElkID0gYml0cmF0ZVNldFtsZXZlbC5iaXRyYXRlXTtcclxuICAgICAgaWYgKHJlZHVuZGFudExldmVsSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGJpdHJhdGVTZXRbbGV2ZWwuYml0cmF0ZV0gPSBsZXZlbHMwLmxlbmd0aDtcclxuICAgICAgICBsZXZlbC51cmwgPSBbbGV2ZWwudXJsXTtcclxuICAgICAgICBsZXZlbC51cmxJZCA9IDA7XHJcbiAgICAgICAgbGV2ZWxzMC5wdXNoKGxldmVsKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXZlbHMwW3JlZHVuZGFudExldmVsSWRdLnVybC5wdXNoKGxldmVsLnVybCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCBhdWRpbyt2aWRlbyBjb2RlY3Mgc2lnbmFsbGVkXHJcbiAgICBpZih2aWRlb0NvZGVjRm91bmQgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XHJcbiAgICAgIGxldmVsczAuZm9yRWFjaChsZXZlbCA9PiB7XHJcbiAgICAgICAgaWYobGV2ZWwudmlkZW9Db2RlYykge1xyXG4gICAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXZlbHMgPSBsZXZlbHMwO1xyXG4gICAgfVxyXG4gICAgLy8gb25seSBrZWVwIGxldmVsIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xyXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbihsZXZlbCkge1xyXG4gICAgbGV0IGF1ZGlvQ29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjLCB2aWRlb0NvZGVjID0gbGV2ZWwudmlkZW9Db2RlYztcclxuICAgICAgcmV0dXJuICghYXVkaW9Db2RlYyB8fCBjaGVja1N1cHBvcnRlZCgnYXVkaW8nLGF1ZGlvQ29kZWMpKSAmJlxyXG4gICAgICAgICAgICAgKCF2aWRlb0NvZGVjIHx8IGNoZWNrU3VwcG9ydGVkKCd2aWRlbycsdmlkZW9Db2RlYykpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYobGV2ZWxzLmxlbmd0aCkge1xyXG4gICAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxyXG4gICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTtcclxuICAgICAgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXHJcbiAgICAgIGxldmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuYml0cmF0ZSAtIGIuYml0cmF0ZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcclxuICAgICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGxldmVsc1tpXS5iaXRyYXRlID09PSBiaXRyYXRlU3RhcnQpIHtcclxuICAgICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgbG9hZGVkLCR7bGV2ZWxzLmxlbmd0aH0gbGV2ZWwocykgZm91bmQsIGZpcnN0IGJpdHJhdGU6JHtiaXRyYXRlU3RhcnR9YCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfUEFSU0VELCB7bGV2ZWxzOiBsZXZlbHMsIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsIHN0YXRzOiBkYXRhLnN0YXRzLCBhdWRpbyA6IGF1ZGlvQ29kZWNGb3VuZCwgdmlkZW8gOiB2aWRlb0NvZGVjRm91bmQsIGFsdEF1ZGlvIDogZGF0YS5hdWRpb1RyYWNrcy5sZW5ndGggPiAwfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiBobHMudXJsLCByZWFzb246ICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0J30pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxldmVscygpIHtcclxuICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XHJcbiAgfVxyXG5cclxuICBnZXQgbGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XHJcbiAgfVxyXG5cclxuICBzZXQgbGV2ZWwobmV3TGV2ZWwpIHtcclxuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XHJcbiAgICBpZiAobGV2ZWxzICYmIGxldmVscy5sZW5ndGggPiBuZXdMZXZlbCkge1xyXG4gICAgICBpZiAodGhpcy5fbGV2ZWwgIT09IG5ld0xldmVsIHx8IGxldmVsc1tuZXdMZXZlbF0uZGV0YWlscyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5zZXRMZXZlbEludGVybmFsKG5ld0xldmVsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiBzZXRMZXZlbEludGVybmFsKG5ld0xldmVsKSB7XHJcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XHJcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcclxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxyXG4gICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPCBsZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxyXG4gICAgICBpZiAodGhpcy50aW1lcikge1xyXG4gICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xyXG4gICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX2xldmVsICE9PSBuZXdMZXZlbCkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyB0byBsZXZlbCAke25ld0xldmVsfWApO1xyXG4gICAgICAgIHRoaXMuX2xldmVsID0gbmV3TGV2ZWw7XHJcbiAgICAgICAgdmFyIGxldmVsUHJvcGVydGllcyA9IGxldmVsc1tuZXdMZXZlbF07XHJcbiAgICAgICAgbGV2ZWxQcm9wZXJ0aWVzLmxldmVsID0gbmV3TGV2ZWw7XHJcbiAgICAgICAgLy8gTEVWRUxfU1dJVENIIHRvIGJlIGRlcHJlY2F0ZWQgaW4gbmV4dCBtYWpvciByZWxlYXNlXHJcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENILCBsZXZlbFByb3BlcnRpZXMpO1xyXG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1NXSVRDSElORywgbGV2ZWxQcm9wZXJ0aWVzKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdLCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xyXG4gICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXHJcbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IGxldmVsRGV0YWlscy5saXZlID09PSB0cnVlKSB7XHJcbiAgICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxyXG4gICAgICAgIHZhciB1cmxJZCA9IGxldmVsLnVybElkO1xyXG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURJTkcsIHt1cmw6IGxldmVsLnVybFt1cmxJZF0sIGxldmVsOiBuZXdMZXZlbCwgaWQ6IHVybElkfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUiwgbGV2ZWw6IG5ld0xldmVsLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ2ludmFsaWQgbGV2ZWwgaWR4J30pO1xyXG4gICAgfVxyXG4gfVxyXG5cclxuICBnZXQgbWFudWFsTGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFudWFsTGV2ZWw7XHJcbiAgfVxyXG5cclxuICBzZXQgbWFudWFsTGV2ZWwobmV3TGV2ZWwpIHtcclxuICAgIHRoaXMuX21hbnVhbExldmVsID0gbmV3TGV2ZWw7XHJcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcclxuICAgIH1cclxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5sZXZlbCA9IG5ld0xldmVsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcclxuICB9XHJcblxyXG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XHJcbiAgICB0aGlzLl9maXJzdExldmVsID0gbmV3TGV2ZWw7XHJcbiAgfVxyXG5cclxuICBnZXQgc3RhcnRMZXZlbCgpIHtcclxuICAgIC8vIGhscy5zdGFydExldmVsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjb25maWcuc3RhcnRMZXZlbFxyXG4gICAgLy8gaWYgbm9uZSBvZiB0aGVzZSB2YWx1ZXMgYXJlIGRlZmluZWQsIGZhbGxiYWNrIG9uIHRoaXMuX2ZpcnN0TGV2ZWwgKGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIHZhcmlhbnQgbWFuaWZlc3QpXHJcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGxldCBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XHJcbiAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gY29uZmlnU3RhcnRMZXZlbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xyXG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xyXG4gIH1cclxuXHJcbiAgb25FcnJvcihkYXRhKSB7XHJcbiAgICBpZihkYXRhLmZhdGFsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZGV0YWlscyA9IGRhdGEuZGV0YWlscywgaGxzID0gdGhpcy5obHMsIGxldmVsSWQsIGxldmVsLCBsZXZlbEVycm9yID0gZmFsc2U7XHJcbiAgICAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXHJcbiAgICBzd2l0Y2goZGV0YWlscykge1xyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUjpcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XHJcbiAgICAgICAgIGxldmVsSWQgPSBkYXRhLmZyYWcubGV2ZWw7XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XHJcbiAgICAgICAgbGV2ZWxJZCA9IGRhdGEuY29udGV4dC5sZXZlbDtcclxuICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1I6XHJcbiAgICAgICAgbGV2ZWxJZCA9IGRhdGEubGV2ZWw7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICAvKiB0cnkgdG8gc3dpdGNoIHRvIGEgcmVkdW5kYW50IHN0cmVhbSBpZiBhbnkgYXZhaWxhYmxlLlxyXG4gICAgICogaWYgbm8gcmVkdW5kYW50IHN0cmVhbSBhdmFpbGFibGUsIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAoaWYgaW4gYXV0byBtb2RlIGFuZCBjdXJyZW50IGxldmVsIG5vdCAwKVxyXG4gICAgICogb3RoZXJ3aXNlLCB3ZSBjYW5ub3QgcmVjb3ZlciB0aGlzIG5ldHdvcmsgZXJyb3IgLi4uXHJcbiAgICAgKi9cclxuICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF07XHJcbiAgICAgIGlmKCFsZXZlbC5sb2FkRXJyb3IpIHtcclxuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldmVsLmxvYWRFcnJvcisrO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGlmIGFueSByZWR1bmRhbnQgc3RyZWFtcyBhdmFpbGFibGUgYW5kIGlmIHdlIGhhdmVuJ3QgdHJ5IHRoZW0gYWxsIChsZXZlbC5sb2FkRXJyb3IgaXMgcmVzZXRlZCBvbiBzdWNjZXNzZnVsIGZyYWcvbGV2ZWwgbG9hZC5cclxuICAgICAgLy8gaWYgbGV2ZWwubG9hZEVycm9yIHJlYWNoZXMgbmJSZWR1bmRhbnRMZXZlbCBpdCBtZWFucyB0aGF0IHdlIHRyaWVkIHRoZW0gYWxsLCBubyBob3BlICA9PiBsZXQncyBzd2l0Y2ggZG93blxyXG4gICAgICBjb25zdCBuYlJlZHVuZGFudExldmVsID0gbGV2ZWwudXJsLmxlbmd0aDtcclxuICAgICBpZiAobmJSZWR1bmRhbnRMZXZlbCA+IDEgJiYgbGV2ZWwubG9hZEVycm9yIDwgbmJSZWR1bmRhbnRMZXZlbCkge1xyXG4gICAgICAgIGxldmVsLnVybElkID0gKGxldmVsLnVybElkICsgMSkgJSBuYlJlZHVuZGFudExldmVsO1xyXG4gICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsJHtkZXRhaWxzfSBmb3IgbGV2ZWwgJHtsZXZlbElkfTogc3dpdGNoaW5nIHRvIHJlZHVuZGFudCBzdHJlYW0gaWQgJHtsZXZlbC51cmxJZH1gKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB3ZSBjb3VsZCB0cnkgdG8gcmVjb3ZlciBpZiBpbiBhdXRvIG1vZGUgYW5kIGN1cnJlbnQgbGV2ZWwgbm90IGxvd2VzdCBsZXZlbCAoMClcclxuICAgICAgICBsZXQgcmVjb3ZlcmFibGUgPSAoKHRoaXMuX21hbnVhbExldmVsID09PSAtMSkgJiYgbGV2ZWxJZCk7XHJcbiAgICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XHJcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwke2RldGFpbHN9OiBzd2l0Y2gtZG93biBmb3IgbmV4dCBmcmFnbWVudGApO1xyXG4gICAgICAgICAgaGxzLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heCgwLGxldmVsSWQtMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGxldmVsICYmIGxldmVsLmRldGFpbHMgJiYgbGV2ZWwuZGV0YWlscy5saXZlKSB7XHJcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwke2RldGFpbHN9IG9uIGxpdmUgc3RyZWFtLCBkaXNjYXJkYCk7XHJcbiAgICAgICAgICBpZiAobGV2ZWxFcnJvcikge1xyXG4gICAgICAgICAgICAvLyByZXNldCB0aGlzLl9sZXZlbCBzbyB0aGF0IGFub3RoZXIgY2FsbCB0byBzZXQgbGV2ZWwoKSB3aWxsIHJldHJpZ2dlciBhIGZyYWcgbG9hZFxyXG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIG90aGVyIGVycm9ycyBhcmUgaGFuZGxlZCBieSBzdHJlYW0gY29udHJvbGxlclxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1IgfHxcclxuICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPT09IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQpIHtcclxuICAgICAgICAgIGxldCBtZWRpYSA9IGhscy5tZWRpYSxcclxuICAgICAgICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXHJcbiAgICAgICAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLG1lZGlhLmN1cnJlbnRUaW1lKSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSxtZWRpYS5jdXJyZW50VGltZSswLjUpO1xyXG4gICAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcclxuICAgICAgICAgICAgbGV0IHJldHJ5RGVsYXkgPSBobHMuY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30sIGJ1dCBtZWRpYSBidWZmZXJlZCwgcmV0cnkgaW4gJHtyZXRyeURlbGF5fW1zYCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMub250aWNrLHJldHJ5RGVsYXkpO1xyXG4gICAgICAgICAgICAvLyBib29sZWFuIHVzZWQgdG8gaW5mb3JtIHN0cmVhbSBjb250cm9sbGVyIG5vdCB0byBzd2l0Y2ggYmFjayB0byBJRExFIG9uIG5vbiBmYXRhbCBlcnJvclxyXG4gICAgICAgICAgICBkYXRhLmxldmVsUmV0cnkgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBjYW5ub3QgcmVjb3ZlciAke2RldGFpbHN9IGVycm9yYCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XHJcbiAgICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXHJcbiAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkZWRcclxuICBvbkZyYWdMb2FkZWQoZGF0YSkge1xyXG4gICAgY29uc3QgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcclxuICAgIGlmIChmcmFnTG9hZGVkICYmIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nKSB7XHJcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5fbGV2ZWxzW2ZyYWdMb2FkZWQubGV2ZWxdO1xyXG4gICAgICBpZiAobGV2ZWwpIHtcclxuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkxldmVsTG9hZGVkKGRhdGEpIHtcclxuICAgIGNvbnN0IGxldmVsSWQgPSBkYXRhLmxldmVsO1xyXG4gICAgIC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcclxuICAgIGlmIChsZXZlbElkID09PSB0aGlzLl9sZXZlbCkge1xyXG4gICAgICBsZXQgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF07XHJcbiAgICAgIC8vIHJlc2V0IGxldmVsIGxvYWQgZXJyb3IgY291bnRlciBvbiBzdWNjZXNzZnVsIGxldmVsIGxvYWRlZFxyXG4gICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xyXG4gICAgICBsZXQgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcclxuICAgICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxyXG4gICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XHJcbiAgICAgICAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCooIG5ld0RldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID8gbmV3RGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gOiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSxcclxuICAgICAgICAgICAgY3VyRGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHM7XHJcbiAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5lbmRTTiA9PT0gY3VyRGV0YWlscy5lbmRTTikge1xyXG4gICAgICAgICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcclxuICAgICAgICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcclxuICAgICAgICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cclxuICAgICAgICAgIHJlbG9hZEludGVydmFsIC89MjtcclxuICAgICAgICAgIGxvZ2dlci5sb2coYHNhbWUgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIHR3aWNlIGZhc3RlcmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZWNyZW1lbnQgcmVsb2FkSW50ZXJ2YWwgd2l0aCBsZXZlbCBsb2FkaW5nIGRlbGF5XHJcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLT0gcGVyZm9ybWFuY2Uubm93KCkgLSBkYXRhLnN0YXRzLnRyZXF1ZXN0O1xyXG4gICAgICAgIC8vIGluIGFueSBjYXNlLCBkb24ndCByZWxvYWQgbW9yZSB0aGFuIGV2ZXJ5IHNlY29uZFxyXG4gICAgICAgIHJlbG9hZEludGVydmFsID0gTWF0aC5tYXgoMTAwMCxNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKSk7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIGluICR7cmVsb2FkSW50ZXJ2YWx9IG1zYCk7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5vbnRpY2sscmVsb2FkSW50ZXJ2YWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aWNrKCkge1xyXG4gICAgdmFyIGxldmVsSWQgPSB0aGlzLl9sZXZlbDtcclxuICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jYW5sb2FkKSB7XHJcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbElkXTtcclxuICAgICAgaWYgKGxldmVsICYmIGxldmVsLnVybCkge1xyXG4gICAgICAgIHZhciB1cmxJZCA9IGxldmVsLnVybElkO1xyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BRElORywge3VybDogbGV2ZWwudXJsW3VybElkXSwgbGV2ZWw6IGxldmVsSWQsIGlkOiB1cmxJZH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcclxuICAgIGlmICh0aGlzLl9tYW51YWxMZXZlbCAhPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbExldmVsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCBuZXh0TG9hZExldmVsKG5leHRMZXZlbCkge1xyXG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcclxuICAgIGlmICh0aGlzLl9tYW51YWxMZXZlbCA9PT0gLTEpIHtcclxuICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExldmVsQ29udHJvbGxlcjtcclxuXHJcbiIsIi8qXHJcbiAqIFN0cmVhbSBDb250cm9sbGVyXHJcbiovXHJcblxyXG5pbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4uL3V0aWxzL2JpbmFyeS1zZWFyY2gnO1xyXG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcclxuaW1wb3J0IERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlcic7XHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgTGV2ZWxIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2xldmVsLWhlbHBlcic7XHJcbmltcG9ydCBUaW1lUmFuZ2VzIGZyb20gJy4uL3V0aWxzL3RpbWVSYW5nZXMnO1xyXG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5jb25zdCBTdGF0ZSA9IHtcclxuICBTVE9QUEVEIDogJ1NUT1BQRUQnLFxyXG4gIElETEUgOiAnSURMRScsXHJcbiAgS0VZX0xPQURJTkcgOiAnS0VZX0xPQURJTkcnLFxyXG4gIEZSQUdfTE9BRElORyA6ICdGUkFHX0xPQURJTkcnLFxyXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZIDogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcclxuICBXQUlUSU5HX0xFVkVMIDogJ1dBSVRJTkdfTEVWRUwnLFxyXG4gIFBBUlNJTkcgOiAnUEFSU0lORycsXHJcbiAgUEFSU0VEIDogJ1BBUlNFRCcsXHJcbiAgQlVGRkVSX0ZMVVNISU5HIDogJ0JVRkZFUl9GTFVTSElORycsXHJcbiAgRU5ERUQgOiAnRU5ERUQnLFxyXG4gIEVSUk9SIDogJ0VSUk9SJ1xyXG59O1xyXG5cclxuY2xhc3MgU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcclxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXHJcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcclxuICAgICAgRXZlbnQuS0VZX0xPQURFRCxcclxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXHJcbiAgICAgIEV2ZW50LkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcclxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxcclxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsXHJcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxyXG4gICAgICBFdmVudC5FUlJPUixcclxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENISU5HLFxyXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCxcclxuICAgICAgRXZlbnQuQlVGRkVSX0NSRUFURUQsXHJcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcclxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xyXG5cclxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcclxuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcclxuICAgIHRoaXMudGlja3MgPSAwO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xyXG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLnN0b3BMb2FkKCk7XHJcbiAgICBpZiAodGhpcy50aW1lcikge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgfVxyXG5cclxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xyXG4gICAgaWYgKHRoaXMubGV2ZWxzKSB7XHJcbiAgICAgIGxldCBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZSwgaGxzID0gdGhpcy5obHM7XHJcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcclxuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGV2ZWwgPSAtMTtcclxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcclxuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xyXG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXHJcbiAgICAgICAgbGV0IHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcclxuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcclxuICAgICAgICAgIC8vIC0xIDogZ3Vlc3Mgc3RhcnQgTGV2ZWwgYnkgZG9pbmcgYSBiaXRyYXRlIHRlc3QgYnkgbG9hZGluZyBmaXJzdCBmcmFnbWVudCBvZiBsb3dlc3QgcXVhbGl0eSBsZXZlbFxyXG4gICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XHJcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXHJcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXHJcbiAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcclxuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcclxuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xyXG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmZvcmNlU3RhcnRMb2FkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdG9wTG9hZCgpIHtcclxuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGlmIChmcmFnKSB7XHJcbiAgICAgIGlmIChmcmFnLmxvYWRlcikge1xyXG4gICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XHJcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XHJcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcclxuICAgIHRoaXMuZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHRpY2soKSB7XHJcbiAgICB0aGlzLnRpY2tzKys7XHJcbiAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xyXG4gICAgICB0aGlzLmRvVGljaygpO1xyXG4gICAgICBpZiAodGhpcy50aWNrcyA+IDEpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50aWNrcyA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb1RpY2soKSB7XHJcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xyXG4gICAgICBjYXNlIFN0YXRlLkVSUk9SOlxyXG4gICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XHJcbiAgICAgIC8vIGluIGJ1ZmZlciBmbHVzaGluZyBzdGF0ZSwgcmVzZXQgZnJhZ0xvYWRFcnJvciBjb3VudGVyXHJcbiAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTdGF0ZS5JRExFOlxyXG4gICAgICAgIHRoaXMuX2RvVGlja0lkbGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0xFVkVMOlxyXG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXHJcbiAgICAgICAgaWYgKGxldmVsICYmIGxldmVsLmRldGFpbHMpIHtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcclxuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xyXG4gICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXHJcbiAgICAgICAgaWYoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgKHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYS5zZWVraW5nKSkge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbWVkaWFDb250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZWApO1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFN0YXRlLkVSUk9SOlxyXG4gICAgICBjYXNlIFN0YXRlLlNUT1BQRUQ6XHJcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxyXG4gICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XHJcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxyXG4gICAgICBjYXNlIFN0YXRlLkVOREVEOlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgYnVmZmVyXHJcbiAgICB0aGlzLl9jaGVja0J1ZmZlcigpO1xyXG4gICAgLy8gY2hlY2svdXBkYXRlIGN1cnJlbnQgZnJhZ21lbnRcclxuICAgIHRoaXMuX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XHJcbiAgfVxyXG5cclxuICAvLyBJcm9uaWNhbGx5IHRoZSBcImlkbGVcIiBzdGF0ZSBpcyB0aGUgb24gd2UgZG8gdGhlIG1vc3QgbG9naWMgaW4gaXQgc2VlbXMgLi4uLlxyXG4gIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxyXG4gIC8vICAgICAgIHBsYXllZCBzZWdtZW50LCBvciBvbiBwYXVzZS9wbGF5L3NlZWsgaW5zdGVhZCBvZiBuYWl2ZWx5IGNoZWNraW5nIGV2ZXJ5IDEwMG1zP1xyXG4gIF9kb1RpY2tJZGxlKCkge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXHJcbiAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxyXG4gICAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG5cclxuICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcclxuICAgIC8vIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggZGlzYWJsZVxyXG4gICAgLy8gZXhpdCBsb29wXHJcbiAgICAvLyA9PiBpZiBzdGFydCBsZXZlbCBsb2FkZWQgYW5kIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcclxuICAgIGlmICh0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gdW5kZWZpbmVkICYmICFtZWRpYSAmJlxyXG4gICAgICAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cclxuICAgIGxldCBwb3M7XHJcbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xyXG4gICAgICBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcclxuICAgIH1cclxuICAgIC8vIGRldGVybWluZSBuZXh0IGxvYWQgbGV2ZWxcclxuICAgIGxldCBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsLFxyXG4gICAgICAgIGxldmVsSW5mbyA9IHRoaXMubGV2ZWxzW2xldmVsXTtcclxuXHJcbiAgICBpZiAoIWxldmVsSW5mbykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGxldmVsQml0cmF0ZSA9IGxldmVsSW5mby5iaXRyYXRlLFxyXG4gICAgICAgIG1heEJ1ZkxlbjtcclxuXHJcbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXHJcbiAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XHJcbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgbWF4QnVmTGVuID0gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcclxuXHJcbiAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXHJcbiAgICAvLyBlbnN1cmUgdXAgdG8gYGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGhgIG9mIGJ1ZmZlciB1cGZyb250XHJcblxyXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxyXG4gICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XHJcbiAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcclxuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgLi4uXHJcbiAgICBsb2dnZXIudHJhY2UoYGJ1ZmZlciBsZW5ndGggb2YgJHtidWZmZXJMZW4udG9GaXhlZCgzKX0gaXMgYmVsb3cgbWF4IG9mICR7bWF4QnVmTGVuLnRvRml4ZWQoMyl9LiBjaGVja2luZyBmb3IgbW9yZSBwYXlsb2FkIC4uLmApO1xyXG5cclxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXHJcbiAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcclxuXHJcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcclxuICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXHJcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcclxuICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcclxuICAgIGlmICh0eXBlb2YgbGV2ZWxEZXRhaWxzID09PSAndW5kZWZpbmVkJyB8fCBsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50LCBjaGVjayBpZiB3ZSBuZWVkIHRvIGZpbmFsaXplIG1lZGlhIHN0cmVhbVxyXG4gICAgbGV0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xyXG4gICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnNuID09PSBsZXZlbERldGFpbHMuZW5kU04pIHtcclxuICAgICAgICAvLyBmcmFnUHJldmlvdXMgaXMgbGFzdCBmcmFnbWVudC4gcmV0cmlldmUgbGV2ZWwgZHVyYXRpb24gdXNpbmcgbGFzdCBmcmFnIHN0YXJ0IG9mZnNldCArIGR1cmF0aW9uXHJcbiAgICAgICAgLy8gcmVhbCBkdXJhdGlvbiBtaWdodCBiZSBsb3dlciB0aGFuIGluaXRpYWwgZHVyYXRpb24gaWYgdGhlcmUgYXJlIGRyaWZ0cyBiZXR3ZWVuIHJlYWwgZnJhZyBkdXJhdGlvbiBhbmQgcGxheWxpc3Qgc2lnbmFsaW5nXHJcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLm1pbihtZWRpYS5kdXJhdGlvbixmcmFnUHJldmlvdXMuc3RhcnQgKyBmcmFnUHJldmlvdXMuZHVyYXRpb24pO1xyXG4gICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgKGFsbW9zdCkgdGlsIHRoZSBlbmQgaXMgYnVmZmVyZWQsIGxldCdzIHNpZ25hbCBlb3NcclxuICAgICAgICAvLyB3ZSBkb24ndCBjb21wYXJlIGV4YWN0bHkgbWVkaWEuZHVyYXRpb24gPT09IGJ1ZmZlckluZm8uZW5kIGFzIHRoZXJlIGNvdWxkIGJlIHNvbWUgc3VidGxlIG1lZGlhIGR1cmF0aW9uIGRpZmZlcmVuY2UgKGF1ZGlvL3ZpZGVvIG9mZnNldHMuLi4pXHJcbiAgICAgICAgLy8gdG9sZXJhdGUgdXAgdG8gb25lIGZyYWcgZHVyYXRpb24gdG8gY29wZSB3aXRoIHRoZXNlIGNhc2VzLlxyXG4gICAgICAgIC8vIGFsc28gY29wZSB3aXRoIGFsbW9zdCB6ZXJvIGxhc3QgZnJhZyBkdXJhdGlvbiAobWF4IGxhc3QgZnJhZyBkdXJhdGlvbiB3aXRoIDIwMG1zKSByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzY1N1xyXG4gICAgICAgIGlmIChkdXJhdGlvbiAtIE1hdGgubWF4KGJ1ZmZlckluZm8uZW5kLGZyYWdQcmV2aW91cy5zdGFydCkgPD0gTWF0aC5tYXgoMC4yLGZyYWdQcmV2aW91cy5kdXJhdGlvbikpIHtcclxuICAgICAgICAvLyBGaW5hbGl6ZSB0aGUgbWVkaWEgc3RyZWFtXHJcbiAgICAgICAgbGV0IGRhdGEgPSB7fTtcclxuICAgICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xyXG4gICAgICAgICAgZGF0YS50eXBlID0gJ3ZpZGVvJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRU9TLGRhdGEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB3ZSBoYXZlIHRoZSBsZXZlbERldGFpbHMgZm9yIHRoZSBzZWxlY3RlZCB2YXJpYW50LCBsZXRzIGNvbnRpbnVlIGVucmljaGVuIG91ciBzdHJlYW0gKGxvYWQga2V5cy9mcmFnbWVudHMgb3IgdHJpZ2dlciBFT1MsIGV0Yy4uKVxyXG4gICAgdGhpcy5fZmV0Y2hQYXlsb2FkT3JFb3MocG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpO1xyXG4gIH1cclxuXHJcbiAgX2ZldGNoUGF5bG9hZE9yRW9zKHBvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XHJcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcclxuICAgICAgICAgIGxldmVsID0gdGhpcy5sZXZlbCxcclxuICAgICAgICAgIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXHJcbiAgICAgICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBlbXB0eSBwbGF5bGlzdFxyXG4gICAgaWYgKGZyYWdMZW4gPT09IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXHJcbiAgICBsZXQgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsXHJcbiAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4tMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbi0xXS5kdXJhdGlvbixcclxuICAgICAgICBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCxcclxuICAgICAgICBmcmFnO1xyXG5cclxuICAgIGlmIChsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQgJiYgIWxldmVsRGV0YWlscy5pbml0U2VnbWVudC5kYXRhKSB7XHJcbiAgICAgIGZyYWcgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBpbiBjYXNlIG9mIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgbm90IGxvY2F0ZWQgYmVmb3JlIHBsYXlsaXN0IHN0YXJ0XHJcbiAgICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xyXG4gICAgICAgIGxldCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IHRoaXMuY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xyXG4gICAgICAgIGlmKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSl7XHJcbiAgICAgICAgICBsb2dnZXIud2FybihgQ2FuIG5vdCBzdGFydCBwbGF5YmFjayBvZiBhIGxldmVsLCByZWFzb246IG5vdCBlbm91Z2ggZnJhZ21lbnRzICR7ZnJhZ0xlbn0gPCAke2luaXRpYWxMaXZlTWFuaWZlc3RTaXplfWApO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnJhZyA9IHRoaXMuX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQobGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVuKTtcclxuICAgICAgICAvLyBpZiBpdCBleHBsaWNpdGVseSByZXR1cm5zIG51bGwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnQgYW5kIGV4aXQgZnVuY3Rpb24gbm93XHJcbiAgICAgICAgaWYgKGZyYWcgPT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxyXG4gICAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xyXG4gICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZnJhZykge1xyXG4gICAgICBmcmFnID0gdGhpcy5fZmluZEZyYWdtZW50KHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscyk7XHJcbiAgICB9XHJcbiAgICBpZihmcmFnKSB7XHJcbiAgICAgIHRoaXMuX2xvYWRGcmFnbWVudE9yS2V5KGZyYWcsIGxldmVsLCBsZXZlbERldGFpbHMsIHBvcywgYnVmZmVyRW5kKTtcclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIF9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbikge1xyXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcblxyXG4gICAgbGV0IGZyYWc7XHJcblxyXG4gICAgLy8gY2hlY2sgaWYgcmVxdWVzdGVkIHBvc2l0aW9uIGlzIHdpdGhpbiBzZWVrYWJsZSBib3VuZGFyaWVzIDpcclxuICAgIC8vbG9nZ2VyLmxvZyhgc3RhcnQvcG9zL2J1ZkVuZC9zZWVraW5nOiR7c3RhcnQudG9GaXhlZCgzKX0vJHtwb3MudG9GaXhlZCgzKX0vJHtidWZmZXJFbmQudG9GaXhlZCgzKX0vJHt0aGlzLm1lZGlhLnNlZWtpbmd9YCk7XHJcbiAgICBsZXQgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQqbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xyXG5cclxuICAgIGlmIChidWZmZXJFbmQgPCBNYXRoLm1heChzdGFydC1jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZW5kIC0gbWF4TGF0ZW5jeSkpIHtcclxuICAgICAgICBsZXQgbGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzdGFydCwgbGV2ZWxEZXRhaWxzKTtcclxuICAgICAgICBsb2dnZXIubG9nKGBidWZmZXIgZW5kOiAke2J1ZmZlckVuZC50b0ZpeGVkKDMpfSBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdCwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiAke2xpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKX1gKTtcclxuICAgICAgICBidWZmZXJFbmQgPSBsaXZlU3luY1Bvc2l0aW9uO1xyXG4gICAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlICYmIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbikge1xyXG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBlbmQgb2YgYnVmZmVyIGdyZWF0ZXIgdGhhbiBsaXZlIGVkZ2UsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50XHJcbiAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpZiBsaXZlIHBsYXlsaXN0IGludGVybWl0dGVudGx5IHNsaWRlcyBpbiB0aGUgcGFzdC5cclxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjEsMTgyNTgwMTY3XVxyXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjldXHJcbiAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OCBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cclxuICAgIC8vIExvYWRpbmcgMTgyNTgwMTY5IG9mIFsxODI1ODAxNjIgLDE4MjU4MDE2OV0sbGV2ZWwgMSAuLlxyXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjhdIDw9PT09PT09PT09PT09IGhlcmUgd2Ugc2hvdWxkIGhhdmUgYnVmZmVyRW5kID4gZW5kLiBpbiB0aGF0IGNhc2UgYnJlYWsgdG8gYXZvaWQgcmVsb2FkaW5nIDE4MjU4MDE2OFxyXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2NCwxODI1ODAxNzFdXHJcbiAgICAvL1xyXG4gICAgLy8gZG9uJ3QgcmV0dXJuIG51bGwgaW4gY2FzZSBtZWRpYSBub3QgbG9hZGVkIHlldCAocmVhZHlzdGF0ZSA9PT0gMClcclxuICAgIGlmIChsZXZlbERldGFpbHMuUFRTS25vd24gJiYgYnVmZmVyRW5kID4gZW5kICYmIG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmICFsZXZlbERldGFpbHMuUFRTS25vd24pIHtcclxuICAgICAgLyogd2UgYXJlIHN3aXRjaGluZyBsZXZlbCBvbiBsaXZlIHBsYXlsaXN0LCBidXQgd2UgZG9uJ3QgaGF2ZSBhbnkgUFRTIGluZm8gZm9yIHRoYXQgcXVhbGl0eSBsZXZlbCAuLi5cclxuICAgICAgICAgdHJ5IHRvIGxvYWQgZnJhZyBtYXRjaGluZyB3aXRoIG5leHQgU04uXHJcbiAgICAgICAgIGV2ZW4gaWYgU04gYXJlIG5vdCBzeW5jaHJvbml6ZWQgYmV0d2VlbiBwbGF5bGlzdHMsIGxvYWRpbmcgdGhpcyBmcmFnIHdpbGwgaGVscCB1c1xyXG4gICAgICAgICBjb21wdXRlIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZSBhZnRlciBpbiBjYXNlIGl0IHdhcyBub3QgdGhlIHJpZ2h0IGNvbnNlY3V0aXZlIG9uZSAqL1xyXG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldFNOID0gZnJhZ1ByZXZpb3VzLnNuICsgMTtcclxuICAgICAgICBpZiAodGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XHJcbiAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBuZXh0IFNOOiAke2ZyYWcuc259YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghZnJhZykge1xyXG4gICAgICAgIC8qIHdlIGhhdmUgbm8gaWRlYSBhYm91dCB3aGljaCBmcmFnbWVudCBzaG91bGQgYmUgbG9hZGVkLlxyXG4gICAgICAgICAgIHNvIGxldCdzIGxvYWQgbWlkIGZyYWdtZW50LiBpdCB3aWxsIGhlbHAgY29tcHV0aW5nIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tNYXRoLm1pbihmcmFnTGVuIC0gMSwgTWF0aC5yb3VuZChmcmFnTGVuIC8gMikpXTtcclxuICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIHVua25vd24sIGxvYWQgbWlkZGxlIGZyYWcgOiAke2ZyYWcuc259YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmcmFnO1xyXG4gIH1cclxuXHJcbiAgX2ZpbmRGcmFnbWVudChzdGFydCwgZnJhZ1ByZXZpb3VzLCBmcmFnTGVuLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHMpIHtcclxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcclxuICAgIGxldCBmcmFnO1xyXG4gICAgbGV0IGZvdW5kRnJhZztcclxuICAgIGxldCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XHJcbiAgICBjb25zdCBmcmFnTmV4dCA9IGZyYWdQcmV2aW91cyA/IGZyYWdtZW50c1tmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc24gKyAxXSA6IHVuZGVmaW5lZDtcclxuICAgIGxldCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgPSAoY2FuZGlkYXRlKSA9PiB7XHJcbiAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcclxuICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXHJcbiAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXHJcbiAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXHJcbiAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXHJcbiAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcclxuICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXHJcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG4gICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cclxuICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxyXG4gICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcclxuICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcclxuICAgICAgLy9sb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xyXG4gICAgICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xyXG4gICAgICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uKTtcclxuICAgICAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfSAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxyXG4gICAgICBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XHJcbiAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XHJcbiAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxyXG4gICAgICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChmcmFnTmV4dCkpIHtcclxuICAgICAgICBmb3VuZEZyYWcgPSBmcmFnTmV4dDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3VuZEZyYWcgPSBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XHJcbiAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuLTFdO1xyXG4gICAgfVxyXG4gICAgaWYgKGZvdW5kRnJhZykge1xyXG4gICAgICBmcmFnID0gZm91bmRGcmFnO1xyXG4gICAgICBjb25zdCBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcclxuICAgICAgY29uc3Qgc2FtZUxldmVsID0gZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbDtcclxuICAgICAgY29uc3QgcHJldkZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggLSAxXTtcclxuICAgICAgY29uc3QgbmV4dEZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggKyAxXTtcclxuICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XHJcbiAgICAgICBpZiAoc2FtZUxldmVsICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbikge1xyXG4gICAgICAgICAgaWYgKGZyYWcuc24gPCBsZXZlbERldGFpbHMuZW5kU04pIHtcclxuICAgICAgICAgICAgbGV0IGRlbHRhUFRTID0gZnJhZ1ByZXZpb3VzLmRlbHRhUFRTO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBsYXJnZXIgdGhhbiBtYXggYWxsb3dlZCBob2xlLFxyXG4gICAgICAgICAgICAvLyBhbmQgaWYgcHJldmlvdXMgcmVtdXhlZCBmcmFnbWVudCBkaWQgbm90IHN0YXJ0IHdpdGggYSBrZXlmcmFtZS4gKGZyYWdQcmV2aW91cy5kcm9wcGVkKVxyXG4gICAgICAgICAgICAvLyBsZXQncyB0cnkgdG8gbG9hZCBwcmV2aW91cyBmcmFnbWVudCBhZ2FpbiB0byBnZXQgbGFzdCBrZXlmcmFtZVxyXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVsb2FkIGFnYWluIGN1cnJlbnQgZnJhZ21lbnQgKHRoYXQgd2F5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbGwgdGhlIGJ1ZmZlciBob2xlIC4uLilcclxuICAgICAgICAgICAgaWYgKGRlbHRhUFRTICYmIGRlbHRhUFRTID4gY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgZnJhZ1ByZXZpb3VzLmRyb3BwZWQgJiYgY3VyU05JZHgpIHtcclxuICAgICAgICAgICAgICBmcmFnID0gcHJldkZyYWc7XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFNOIGp1c3QgbG9hZGVkLCB3aXRoIGxhcmdlIFBUUyBnYXAgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8sIG1heWJlIGZyYWcgaXMgbm90IHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSA/IGxvYWQgcHJldmlvdXMgb25lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzYCk7XHJcbiAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IHByZXZpb3VzIGZyYWcgbG9hZCBjb3VudGVyIHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIHdoZW4gbmV4dCBmcmFnbWVudCB3aWxsIGdldCByZWxvYWRlZFxyXG4gICAgICAgICAgICAgIGZyYWdQcmV2aW91cy5sb2FkQ291bnRlci0tO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogJHtmcmFnLnNufWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmcmFnID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGZyYWcuZHJvcHBlZCAmJiAhc2FtZUxldmVsKSB7XHJcbiAgICAgICAgIC8vIE9ubHkgYmFja3RyYWNrIGEgbWF4IG9mIDEgY29uc2VjdXRpdmUgZnJhZ21lbnQgdG8gcHJldmVudCBzbGlkaW5nIGJhY2sgdG9vIGZhciB3aGVuIGxpdHRsZSBvciBubyBmcmFncyBzdGFydCB3aXRoIGtleWZyYW1lc1xyXG4gICAgICAgICBpZiAobmV4dEZyYWcgJiYgbmV4dEZyYWcuYmFja3RyYWNrZWQpIHtcclxuICAgICAgICAgICBsb2dnZXIud2FybihgQWxyZWFkeSBiYWNrdHJhY2tlZCBmcm9tIGZyYWdtZW50ICR7Y3VyU05JZHggKyAxfSwgd2lsbCBub3QgYmFja3RyYWNrIHRvIGZyYWdtZW50ICR7Y3VyU05JZHh9LiBMb2FkaW5nIGZyYWdtZW50ICR7Y3VyU05JZHggKyAxfWApO1xyXG4gICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAvLyBJZiBhIGZyYWdtZW50IGhhcyBkcm9wcGVkIGZyYW1lcyBhbmQgaXQncyBpbiBhIGRpZmZlcmVudCBsZXZlbC9zZXF1ZW5jZSwgbG9hZCB0aGUgcHJldmlvdXMgZnJhZ21lbnQgdG8gdHJ5IGFuZCBmaW5kIHRoZSBrZXlmcmFtZVxyXG4gICAgICAgICAgIC8vIFJlc2V0IHRoZSBkcm9wcGVkIGNvdW50IG5vdyBzaW5jZSBpdCB3b24ndCBiZSByZXNldCB1bnRpbCB3ZSBwYXJzZSB0aGUgZnJhZ21lbnQgYWdhaW4sIHdoaWNoIHByZXZlbnRzIGluZmluaXRlIGJhY2t0cmFja2luZyBvbiB0aGUgc2FtZSBzZWdtZW50XHJcbiAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0xvYWRlZCBmcmFnbWVudCB3aXRoIGRyb3BwZWQgZnJhbWVzLCBiYWNrdHJhY2tpbmcgMSBzZWdtZW50IHRvIGZpbmQgYSBrZXlmcmFtZScpO1xyXG4gICAgICAgICAgIGZyYWcuZHJvcHBlZCA9IDA7XHJcbiAgICAgICAgICAgaWYgKHByZXZGcmFnKSB7XHJcbiAgICAgICAgICAgICBpZiAocHJldkZyYWcubG9hZENvdW50ZXIpIHtcclxuICAgICAgICAgICAgICAgcHJldkZyYWcubG9hZENvdW50ZXItLTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgZnJhZyA9IG51bGw7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnJhZztcclxuICB9XHJcblxyXG4gIF9sb2FkRnJhZ21lbnRPcktleShmcmFnLCBsZXZlbCwgbGV2ZWxEZXRhaWxzLCBwb3MsIGJ1ZmZlckVuZCkge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXHJcbiAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnO1xyXG5cclxuICAgIC8vbG9nZ2VyLmxvZygnbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xyXG4gICAgaWYgKChmcmFnLmRlY3J5cHRkYXRhICYmIGZyYWcuZGVjcnlwdGRhdGEudXJpICE9IG51bGwpICYmIChmcmFnLmRlY3J5cHRkYXRhLmtleSA9PSBudWxsKSkge1xyXG4gICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH1gKTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH0sIGN1cnJlbnRUaW1lOiR7cG9zLnRvRml4ZWQoMyl9LGJ1ZmZlckVuZDoke2J1ZmZlckVuZC50b0ZpeGVkKDMpfWApO1xyXG4gICAgICAvLyBlbnN1cmUgdGhhdCB3ZSBhcmUgbm90IHJlbG9hZGluZyB0aGUgc2FtZSBmcmFnbWVudHMgaW4gbG9vcCAuLi5cclxuICAgICAgaWYgKHRoaXMuZnJhZ0xvYWRJZHggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHgrKztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZnJhZy5sb2FkQ291bnRlcikge1xyXG4gICAgICAgIGZyYWcubG9hZENvdW50ZXIrKztcclxuICAgICAgICBsZXQgbWF4VGhyZXNob2xkID0gY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcclxuICAgICAgICAvLyBpZiB0aGlzIGZyYWcgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgMyB0aW1lcywgYW5kIGlmIGl0IGhhcyBiZWVuIHJlbG9hZGVkIHJlY2VudGx5XHJcbiAgICAgICAgaWYgKGZyYWcubG9hZENvdW50ZXIgPiBtYXhUaHJlc2hvbGQgJiYgKE1hdGguYWJzKHRoaXMuZnJhZ0xvYWRJZHggLSBmcmFnLmxvYWRJZHgpIDwgbWF4VGhyZXNob2xkKSkge1xyXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMTtcclxuICAgICAgfVxyXG4gICAgICBmcmFnLmxvYWRJZHggPSB0aGlzLmZyYWdMb2FkSWR4O1xyXG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcclxuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xyXG4gICAgICBpZiAoIWlzTmFOKGZyYWcuc24pKSB7XHJcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XHJcbiAgICAgIH1cclxuICAgICAgZnJhZy5hdXRvTGV2ZWwgPSBobHMuYXV0b0xldmVsRW5hYmxlZDtcclxuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IHRoaXMuYml0cmF0ZVRlc3Q7XHJcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcclxuICAgICAgLy8gbGF6eSBkZW11eGVyIGluaXQsIGFzIHRoaXMgY291bGQgdGFrZSBzb21lIHRpbWUgLi4uIGRvIGl0IGR1cmluZyBmcmFnIGxvYWRpbmdcclxuICAgICAgaWYgKCF0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcihobHMsJ21haW4nKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhdGUobmV4dFN0YXRlKSB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XHJcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgbG9nZ2VyLmxvZyhgbWFpbiBzdHJlYW06JHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1RSRUFNX1NUQVRFX1RSQU5TSVRJT04sIHtwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGV9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBzdGF0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcclxuICB9XHJcblxyXG4gIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIEJpbmFyeVNlYXJjaC5zZWFyY2godGhpcy5fYnVmZmVyZWRGcmFncywgZnVuY3Rpb24oZnJhZykge1xyXG4gICAgICBpZiAocG9zaXRpb24gPCBmcmFnLnN0YXJ0UFRTKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gZnJhZy5lbmRQVFMpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgY29uc3QgZnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcclxuICAgICAgaWYgKGZyYWcpIHtcclxuICAgICAgICByZXR1cm4gZnJhZy5sZXZlbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG5leHRCdWZmZXJlZEZyYWcoKSB7XHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgIC8vIGZpcnN0IGdldCBlbmQgcmFuZ2Ugb2YgY3VycmVudCBmcmFnbWVudFxyXG4gICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcodGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpIHtcclxuICAgIGlmIChmcmFnKSB7XHJcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kUFRTICsgMC41KTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG5leHRMZXZlbCgpIHtcclxuICAgIGNvbnN0IGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XHJcbiAgICBpZiAoZnJhZykge1xyXG4gICAgICByZXR1cm4gZnJhZy5sZXZlbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcclxuICAgIHZhciBmcmFnUGxheWluZ0N1cnJlbnQsIGN1cnJlbnRUaW1lLCB2aWRlbyA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xyXG4gICAgICBjdXJyZW50VGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lO1xyXG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXHJcbiAgICAgICAgKGFzc3VtaW5nIHRoYXQgcGxheWJhY2sgcmF0ZSBpcyBwb3NpdGl2ZSAuLi4pXHJcbiAgICAgICAgQXMgc29tZXRpbWVzIGN1cnJlbnRUaW1lIGp1bXBzIGJhY2sgdG8gemVybyBhZnRlciBhXHJcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cclxuICAgICAgICB3cm9uZyBwb3NpdGlvbiBhZnRlciBhIG1lZGlhIGRlY29kZSBlcnJvclxyXG4gICAgICAqL1xyXG4gICAgICBpZihjdXJyZW50VGltZSA+IHZpZGVvLnBsYXliYWNrUmF0ZSp0aGlzLmxhc3RDdXJyZW50VGltZSkge1xyXG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLGN1cnJlbnRUaW1lKSkge1xyXG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGN1cnJlbnRUaW1lKTtcclxuICAgICAgfSBlbHNlIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbyxjdXJyZW50VGltZSArIDAuMSkpIHtcclxuICAgICAgICAvKiBlbnN1cmUgdGhhdCBGUkFHX0NIQU5HRUQgZXZlbnQgaXMgdHJpZ2dlcmVkIGF0IHN0YXJ0dXAsXHJcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxyXG4gICAgICAgICAgYWRkIGEgdG9sZXJhbmNlIG9mIDEwMG1zLCBpbiBjYXNlIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLFxyXG4gICAgICAgICAgY2hlY2sgaWYgY3VycmVudCBwb3MrMTAwbXMgaXMgYnVmZmVyZWQgYW5kIHVzZSB0aGF0IGJ1ZmZlciByYW5nZVxyXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cclxuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhjdXJyZW50VGltZSArIDAuMSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCkge1xyXG4gICAgICAgIHZhciBmcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nQ3VycmVudDtcclxuICAgICAgICBpZiAoZnJhZ1BsYXlpbmcgIT09IHRoaXMuZnJhZ1BsYXlpbmcpIHtcclxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19DSEFOR0VELCB7ZnJhZzogZnJhZ1BsYXlpbmd9KTtcclxuICAgICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nTGV2ZWwgPSBmcmFnUGxheWluZy5sZXZlbDtcclxuICAgICAgICAgIGlmICghdGhpcy5mcmFnUGxheWluZyB8fCB0aGlzLmZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnUGxheWluZ0xldmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENIRUQsIHtsZXZlbDogZnJhZ1BsYXlpbmdMZXZlbH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5mcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLypcclxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxyXG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xyXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxyXG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcclxuICAqL1xyXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoKCkge1xyXG4gICAgbG9nZ2VyLmxvZygnaW1tZWRpYXRlTGV2ZWxTd2l0Y2gnKTtcclxuICAgIGlmICghdGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcclxuICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSB0cnVlO1xyXG4gICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLCBwcmV2aW91c2x5UGF1c2VkO1xyXG4gICAgICBpZiAobWVkaWEpIHtcclxuICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gbWVkaWEucGF1c2VkO1xyXG4gICAgICAgIG1lZGlhLnBhdXNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZG9uJ3QgcmVzdGFydCBwbGF5YmFjayBhZnRlciBpbnN0YW50IGxldmVsIHN3aXRjaCBpbiBjYXNlIG1lZGlhIG5vdCBhdHRhY2hlZFxyXG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucHJldmlvdXNseVBhdXNlZCA9IHByZXZpb3VzbHlQYXVzZWQ7XHJcbiAgICB9XHJcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xyXG4gICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcclxuICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcclxuICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcclxuICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCBlbmQsIGFmdGVyIG5ldyBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZCA6XHJcbiAgICAgIC0gbnVkZ2UgdmlkZW8gZGVjb2RlciBieSBzbGlnaHRseSBhZGp1c3RpbmcgdmlkZW8gY3VycmVudFRpbWUgKGlmIGN1cnJlbnRUaW1lIGJ1ZmZlcmVkKVxyXG4gICAgICAtIHJlc3VtZSB0aGUgcGxheWJhY2sgaWYgbmVlZGVkXHJcbiAgKi9cclxuICBpbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCgpIHtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gZmFsc2U7XHJcbiAgICAgIGlmKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLG1lZGlhLmN1cnJlbnRUaW1lKSkge1xyXG4gICAgICAgIC8vIG9ubHkgbnVkZ2UgaWYgY3VycmVudFRpbWUgaXMgYnVmZmVyZWRcclxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSAtPSAwLjAwMDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLnByZXZpb3VzbHlQYXVzZWQpIHtcclxuICAgICAgICBtZWRpYS5wbGF5KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5leHRMZXZlbFN3aXRjaCgpIHtcclxuICAgIC8qIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrIDpcclxuICAgICAgIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcclxuICAgICAgd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcclxuICAgICAgd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcclxuICAgICovXHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcclxuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XHJcbiAgICAgIGxldCBmZXRjaGRlbGF5LCBmcmFnUGxheWluZ0N1cnJlbnQsIG5leHRCdWZmZXJlZEZyYWc7XHJcbiAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXHJcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcclxuICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xyXG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50ICYmIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydFBUUyA+IDEpIHtcclxuICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxyXG4gICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxyXG4gICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0UFRTIC0gMSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcclxuICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcclxuICAgICAgICB2YXIgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsLG5leHRMZXZlbCA9IHRoaXMubGV2ZWxzW25leHRMZXZlbElkXSwgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XHJcbiAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XHJcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5iaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZmV0Y2hkZWxheSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZldGNoZGVsYXkgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIC8vbG9nZ2VyLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xyXG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcclxuICAgICAgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XHJcbiAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XHJcbiAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xyXG4gICAgICAgIG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhuZXh0QnVmZmVyZWRGcmFnKTtcclxuICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xyXG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xyXG4gICAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgICAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcclxuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgIC8vIGZsdXNoIHBvc2l0aW9uIGlzIHRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGlzIG5ldyBidWZmZXJcclxuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKG5leHRCdWZmZXJlZEZyYWcuc3RhcnRQVFMgLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0LGVuZE9mZnNldCkge1xyXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcclxuICAgIGxldCBmbHVzaFNjb3BlID0ge3N0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXR9O1xyXG4gICAgLy8gaWYgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBhcmUgdXNlZCwgb25seSBmbHVzaCB2aWRlbywgb3RoZXJ3aXNlIGZsdXNoIGV2ZXJ5dGhpbmdcclxuICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XHJcbiAgICAgIGZsdXNoU2NvcGUudHlwZSA9ICd2aWRlbyc7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xyXG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xyXG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xyXG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XHJcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XHJcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xyXG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgaWYodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcclxuICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XHJcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmVuZGVkKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XHJcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkaW5nIGNvdW50ZXIgb24gTVNFIGRldGFjaGluZyB0byBhdm9pZCByZXBvcnRpbmcgRlJBR19MT09QX0xPQURJTkdfRVJST1IgYWZ0ZXIgZXJyb3IgcmVjb3ZlcnlcclxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuICAgIGlmIChsZXZlbHMpIHtcclxuICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZCBjb3VudGVyXHJcbiAgICAgICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xyXG4gICAgICAgICAgaWYobGV2ZWwuZGV0YWlscykge1xyXG4gICAgICAgICAgICBsZXZlbC5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZyYWdtZW50ID0+IHtcclxuICAgICAgICAgICAgICBmcmFnbWVudC5sb2FkQ291bnRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICBmcmFnbWVudC5iYWNrdHJhY2tlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xyXG4gICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xyXG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XHJcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XHJcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkICA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdG9wTG9hZCgpO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYVNlZWtpbmcoKSB7XHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiB1bmRlZmluZWQsIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgaWYgKCFpc05hTihjdXJyZW50VGltZSkpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhgbWVkaWEgc2Vla2luZyB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XHJcbiAgICB9XHJcbiAgICBsZXQgbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhO1xyXG4gICAgbGV0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYUJ1ZmZlcixjdXJyZW50VGltZSx0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcpIHtcclxuICAgICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIHNlZWtpbmcgdG8gYSB1bmJ1ZmZlcmVkIGFyZWEgQU5EIGlmIGZyYWcgbG9hZGluZyBpcyBpbiBwcm9ncmVzc1xyXG4gICAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDAgJiYgZnJhZ0N1cnJlbnQpIHtcclxuICAgICAgICBsZXQgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgIGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlLFxyXG4gICAgICAgICAgICBmcmFnRW5kT2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcclxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBzZWVrIHBvc2l0aW9uIHdpbGwgYmUgb3V0IG9mIGN1cnJlbnRseSBsb2FkZWQgZnJhZyByYW5nZSA6IGlmIG91dCBjYW5jZWwgZnJhZyBsb2FkLCBpZiBpbiwgZG9uJ3QgZG8gYW55dGhpbmdcclxuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCBmcmFnU3RhcnRPZmZzZXQgfHwgY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0KSB7XHJcbiAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQubG9hZGVyKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnKTtcclxuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciBidXQgd2l0aGluIGN1cnJlbnRseSBsb2FkZWQgZnJhZ21lbnQgcmFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcclxuICAgICAgICAvLyBpZiBzZWVraW5nIHRvIHVuYnVmZmVyZWQgYXJlYSwgY2xlYW4gdXAgZnJhZ1ByZXZpb3VzXHJcbiAgICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICB9XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcclxuICAgIH1cclxuICAgIC8vIGF2b2lkIHJlcG9ydGluZyBmcmFnbWVudCBsb29wIGxvYWRpbmcgZXJyb3IgaW4gY2FzZSB1c2VyIGlzIHNlZWtpbmcgc2V2ZXJhbCB0aW1lcyBvbiBzYW1lIHBvc2l0aW9uXHJcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRlJBR19MT0FESU5HICYmIHRoaXMuZnJhZ0xvYWRJZHggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xyXG4gICAgfVxyXG4gICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcclxuICAgIGlmKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xyXG4gICAgfVxyXG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXHJcbiAgICB0aGlzLnRpY2soKTtcclxuICB9XHJcblxyXG4gIG9uTWVkaWFTZWVrZWQoKSB7XHJcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWEsIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IHVuZGVmaW5lZDtcclxuICAgIGlmICghaXNOYU4oY3VycmVudFRpbWUpKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYG1lZGlhIHNlZWtlZCB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XHJcbiAgICB9XHJcbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdNRU5UX1BMQVlJTkcgdHJpZ2dlcmluZ1xyXG4gICAgdGhpcy50aWNrKCk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRW5kZWQoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBlbmRlZCcpO1xyXG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXHJcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XHJcbiAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xyXG4gICAgbG9nZ2VyLmxvZygndHJpZ2dlciBCVUZGRVJfUkVTRVQnKTtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX1JFU0VUKTtcclxuICAgIHRoaXMuX2J1ZmZlcmVkRnJhZ3MgPSBbXTtcclxuICAgIHRoaXMuc3RhbGxlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xyXG4gIH1cclxuXHJcbiAgb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XHJcbiAgICB2YXIgYWFjID0gZmFsc2UsIGhlYWFjID0gZmFsc2UsIGNvZGVjO1xyXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XHJcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXHJcbiAgICAgIGNvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYztcclxuICAgICAgaWYgKGNvZGVjKSB7XHJcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSkge1xyXG4gICAgICAgICAgYWFjID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xyXG4gICAgICAgICAgaGVhYWMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSAoYWFjICYmIGhlYWFjKTtcclxuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnYm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQycpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcclxuICAgIHRoaXMuc3RhcnRMZXZlbExvYWRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcclxuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgIGlmIChjb25maWcuYXV0b1N0YXJ0TG9hZCB8fCB0aGlzLmZvcmNlU3RhcnRMb2FkKSB7XHJcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkxldmVsTG9hZGVkKGRhdGEpIHtcclxuICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxyXG4gICAgICAgIG5ld0xldmVsSWQgPSBkYXRhLmxldmVsLFxyXG4gICAgICAgIGN1ckxldmVsID0gdGhpcy5sZXZlbHNbbmV3TGV2ZWxJZF0sXHJcbiAgICAgICAgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24sXHJcbiAgICAgICAgc2xpZGluZyA9IDA7XHJcblxyXG4gICAgbG9nZ2VyLmxvZyhgbGV2ZWwgJHtuZXdMZXZlbElkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xyXG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xyXG5cclxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcclxuICAgICAgdmFyIGN1ckRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xyXG4gICAgICBpZiAoY3VyRGV0YWlscyAmJiBuZXdEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gd2UgYWxyZWFkeSBoYXZlIGRldGFpbHMgZm9yIHRoYXQgbGV2ZWwsIG1lcmdlIHRoZW1cclxuICAgICAgICBMZXZlbEhlbHBlci5tZXJnZURldGFpbHMoY3VyRGV0YWlscyxuZXdEZXRhaWxzKTtcclxuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xyXG4gICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0IHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCAtIGZpcnN0IGxvYWQsIHVua25vd24gc2xpZGluZycpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXHJcbiAgICBjdXJMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfVVBEQVRFRCwgeyBkZXRhaWxzOiBuZXdEZXRhaWxzLCBsZXZlbDogbmV3TGV2ZWxJZCB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxyXG4gICAgICBpZiAodGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSB8fMKgdGhpcy5sYXN0Q3VycmVudFRpbWUgPT09IC0xKSB7XHJcbiAgICAgICAgLy8gZmlyc3QsIGNoZWNrIGlmIHN0YXJ0IHRpbWUgb2Zmc2V0IGhhcyBiZWVuIHNldCBpbiBwbGF5bGlzdCwgaWYgeWVzLCB1c2UgdGhpcyB2YWx1ZVxyXG4gICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBuZXdEZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcclxuICAgICAgICBpZighaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xyXG4gICAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbmVnYXRpdmUgc3RhcnQgdGltZSBvZmZzZXQgJHtzdGFydFRpbWVPZmZzZXR9LCBjb3VudCBmcm9tIGVuZCBvZiBsYXN0IGZyYWdtZW50YCk7XHJcbiAgICAgICAgICAgIHN0YXJ0VGltZU9mZnNldCA9IHNsaWRpbmcgKyBkdXJhdGlvbiArIHN0YXJ0VGltZU9mZnNldDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcclxuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgc2V0IHN0YXJ0IHBvc2l0aW9uIHRvIGJlIGZyYWdtZW50IE4tdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICh1c3VhbGx5IDMpXHJcbiAgICAgICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBuZXdEZXRhaWxzKTtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gdG8gJHt0aGlzLnN0YXJ0UG9zaXRpb259YCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgfVxyXG4gICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XHJcbiAgICB0aGlzLnRpY2soKTtcclxuICB9XHJcblxyXG4gIG9uS2V5TG9hZGVkKCkge1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICB0aGlzLnRpY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XHJcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxyXG4gICAgICAgIGZyYWdMb2FkZWQgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXHJcbiAgICAgICAgZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBmcmFnTG9hZGVkLnR5cGUgPT09ICdtYWluJyAmJlxyXG4gICAgICAgIGZyYWdMb2FkZWQubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgZnJhZ0xvYWRlZC5zbiA9PT0gZnJhZ0N1cnJlbnQuc24pIHtcclxuICAgICAgbGV0IHN0YXRzID0gZGF0YS5zdGF0cyxcclxuICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHRoaXMubGV2ZWxzW2ZyYWdDdXJyZW50LmxldmVsXSxcclxuICAgICAgICAgIGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscztcclxuICAgICAgbG9nZ2VyLmxvZyhgTG9hZGVkICAke2ZyYWdDdXJyZW50LnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWdDdXJyZW50LmxldmVsfWApO1xyXG4gICAgICAvLyByZXNldCBmcmFnIGJpdHJhdGUgdGVzdCBpbiBhbnkgY2FzZSBhZnRlciBmcmFnIGxvYWRlZCBldmVudFxyXG4gICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcclxuICAgICAgLy8gaWYgdGhpcyBmcmFnIHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCBBTkQgaWYgaGxzLm5leHRMb2FkTGV2ZWwgaXMgZ3JlYXRlciB0aGFuIDBcclxuICAgICAgLy8gdGhlbiB0aGlzIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGJlIGFibGUgdG8gbG9hZCBhIGZyYWdtZW50IGF0IGEgaGlnaGVyIHF1YWxpdHkgbGV2ZWxcclxuICAgICAgaWYgKGZyYWdMb2FkZWQuYml0cmF0ZVRlc3QgPT09IHRydWUgJiYgdGhpcy5obHMubmV4dExvYWRMZXZlbCkge1xyXG4gICAgICAgIC8vIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgLi4uIHdlIGp1c3QgbG9hZGVkIGEgZnJhZ21lbnQgdG8gZGV0ZXJtaW5lIGFkZXF1YXRlIHN0YXJ0IGJpdHJhdGUgYW5kIGluaXRpYWxpemUgYXV0b3N3aXRjaCBhbGdvXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQgOiAnbWFpbid9KTtcclxuICAgICAgICB0aGlzLnRpY2soKTtcclxuICAgICAgfSBlbHNlIGlmIChmcmFnTG9hZGVkLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA9IGRhdGEucGF5bG9hZDtcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHtzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZCA6ICdtYWluJ30pO1xyXG4gICAgICAgIHRoaXMudGljaygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xyXG4gICAgICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcclxuICAgICAgICBsZXQgZHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGxldmVsID0gZnJhZ0N1cnJlbnQubGV2ZWwsXHJcbiAgICAgICAgICAgIHNuID0gZnJhZ0N1cnJlbnQuc24sXHJcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcclxuICAgICAgICBpZih0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2FwcGluZyBwbGF5bGlzdCBhdWRpbyBjb2RlYycpO1xyXG4gICAgICAgICAgaWYoYXVkaW9Db2RlYyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSB0aGlzLmxhc3RBdWRpb0NvZGVjO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYoYXVkaW9Db2RlYykge1xyXG4gICAgICAgICAgICBpZihhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PS0xKSB7XHJcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcclxuICAgICAgICBsb2dnZXIubG9nKGBQYXJzaW5nICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7bGV2ZWx9LCBjYyAke2ZyYWdDdXJyZW50LmNjfWApO1xyXG4gICAgICAgIGxldCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xyXG4gICAgICAgIGlmICghZGVtdXhlcikge1xyXG4gICAgICAgICAgZGVtdXhlciA9IHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCdtYWluJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKSBhbmQgaWYgbWVkaWEgaXMgbm90IHNlZWtpbmcgKHRoaXMgaXMgdG8gb3ZlcmNvbWUgcG90ZW50aWFsIHRpbWVzdGFtcCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdHMgYW5kIGZyYWdtZW50cylcclxuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgICAgIGxldCBtZWRpYVNlZWtpbmcgPSBtZWRpYSAmJiBtZWRpYS5zZWVraW5nO1xyXG4gICAgICAgIGxldCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSAhbWVkaWFTZWVraW5nICYmIChkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmUpO1xyXG4gICAgICAgIGxldCBpbml0U2VnbWVudERhdGEgPSBkZXRhaWxzLmluaXRTZWdtZW50ID8gZGV0YWlscy5pbml0U2VnbWVudC5kYXRhIDogW107XHJcbiAgICAgICAgZGVtdXhlci5wdXNoKGRhdGEucGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLGF1ZGlvQ29kZWMsIGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjLCBmcmFnQ3VycmVudCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCx1bmRlZmluZWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xyXG4gIH1cclxuXHJcbiAgb25GcmFnUGFyc2luZ0luaXRTZWdtZW50KGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcclxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxyXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xyXG4gICAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrTmFtZSwgdHJhY2s7XHJcblxyXG4gICAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cclxuICAgICAgaWYgKHRyYWNrcy5hdWRpbyAmJiB0aGlzLmFsdEF1ZGlvKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpbztcclxuICAgICAgfVxyXG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xyXG4gICAgICB0cmFjayA9IHRyYWNrcy5hdWRpbztcclxuICAgICAgaWYodHJhY2spIHtcclxuICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLmF1ZGlvQ29kZWMsXHJcbiAgICAgICAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmKGF1ZGlvQ29kZWMgJiYgdGhpcy5hdWRpb0NvZGVjU3dhcCkge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcclxuICAgICAgICAgIGlmKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09LTEpIHtcclxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiBjYXNlIEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0XHJcbiAgICAgICAgLy8gZm9yY2UgSEUtQUFDICwgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgdGhhdCB3YXksXHJcbiAgICAgICAgLy8gZXhjZXB0IGZvciBtb25vIHN0cmVhbXMgT1Igb24gRkZcclxuICAgICAgICAvLyB0aGVzZSBjb25kaXRpb25zIG1pZ2h0IG5lZWQgdG8gYmUgcmV2aWV3ZWQgLi4uXHJcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xyXG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW1cclxuICAgICAgICAgICBpZih0cmFjay5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiZcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIGZpcmVmb3hcclxuICAgICAgICAgICAgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSEUtQUFDIGlzIGJyb2tlbiBvbiBBbmRyb2lkLCBhbHdheXMgc2lnbmFsIGF1ZGlvIGNvZGVjIGFzIEFBQyBldmVuIGlmIHZhcmlhbnQgbWFuaWZlc3Qgc3RhdGVzIG90aGVyd2lzZVxyXG4gICAgICAgIGlmKHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgdHJhY2suY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHsgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXHJcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byAke2F1ZGlvQ29kZWN9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSBhdWRpb0NvZGVjO1xyXG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcclxuICAgICAgfVxyXG4gICAgICB0cmFjayA9IHRyYWNrcy52aWRlbztcclxuICAgICAgaWYodHJhY2spIHtcclxuICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0udmlkZW9Db2RlYztcclxuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ09ERUNTLHRyYWNrcyk7XHJcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxyXG4gICAgICBmb3IgKHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcclxuICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xyXG4gICAgICAgIGxvZ2dlci5sb2coYG1haW4gdHJhY2s6JHt0cmFja05hbWV9LGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sY29kZWNzW2xldmVsL3BhcnNlZF09WyR7dHJhY2subGV2ZWxDb2RlY30vJHt0cmFjay5jb2RlY31dYCk7XHJcbiAgICAgICAgdmFyIGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XHJcbiAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XHJcbiAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XHJcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7dHlwZTogdHJhY2tOYW1lLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50IDogJ21haW4nLCBjb250ZW50IDogJ2luaXRTZWdtZW50J30pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZyYWdQYXJzaW5nRGF0YShkYXRhKSB7XHJcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XHJcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXHJcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXHJcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcclxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxyXG4gICAgICAgICEoZGF0YS50eXBlID09PSAnYXVkaW8nICYmIHRoaXMuYWx0QXVkaW8pICYmIC8vIGZpbHRlciBvdXQgbWFpbiBhdWRpbyBpZiBhdWRpbyB0cmFjayBpcyBsb2FkZWQgdGhyb3VnaCBhdWRpbyBzdHJlYW0gY29udHJvbGxlclxyXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcclxuICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0sXHJcbiAgICAgICAgICBmcmFnID0gZnJhZ0N1cnJlbnQ7XHJcbiAgICAgICAgICBpZiAoaXNOYU4oZGF0YS5lbmRQVFMpKSB7XHJcbiAgICAgICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xyXG4gICAgICAgICAgICBkYXRhLmVuZERUUyA9IGRhdGEuc3RhcnREVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgIGxvZ2dlci5sb2coYFBhcnNlZCAke2RhdGEudHlwZX0sUFRTOlske2RhdGEuc3RhcnRQVFMudG9GaXhlZCgzKX0sJHtkYXRhLmVuZFBUUy50b0ZpeGVkKDMpfV0sRFRTOlske2RhdGEuc3RhcnREVFMudG9GaXhlZCgzKX0vJHtkYXRhLmVuZERUUy50b0ZpeGVkKDMpfV0sbmI6JHtkYXRhLm5ifSxkcm9wcGVkOiR7ZGF0YS5kcm9wcGVkIHx8IDB9YCk7XHJcblxyXG4gICAgICAvLyBEZXRlY3QgZ2FwcyBpbiBhIGZyYWdtZW50ICBhbmQgdHJ5IHRvIGZpeCBpdCBieSBmaW5kaW5nIGEga2V5ZnJhbWUgaW4gdGhlIHByZXZpb3VzIGZyYWdtZW50IChzZWUgX2ZpbmRGcmFnbWVudHMpXHJcbiAgICAgIGlmKGRhdGEudHlwZSA9PT0gJ3ZpZGVvJykge1xyXG4gICAgICAgIGZyYWcuZHJvcHBlZCA9IGRhdGEuZHJvcHBlZDtcclxuICAgICAgICBpZiAoZnJhZy5kcm9wcGVkKSB7XHJcbiAgICAgICAgICBpZiAoIWZyYWcuYmFja3RyYWNrZWQpIHtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIGJhY2sgdG8gdGhlIElETEUgc3RhdGUgd2l0aG91dCBhcHBlbmRpbmcgdG8gYnVmZmVyXHJcbiAgICAgICAgICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayBhIHNlZ21lbnQgYW5kIGZpbmQgdGhlIGtleWZyYW1lXHJcbiAgICAgICAgICAgIC8vIEF1ZGlvIGZyYWdtZW50cyBhcnJpdmluZyBiZWZvcmUgdmlkZW8gc2V0cyB0aGUgbmV4dExvYWRQb3NpdGlvbiwgY2F1c2luZyBfZmluZEZyYWdtZW50cyB0byBza2lwIHRoZSBiYWNrdHJhY2tlZCBmcmFnbWVudFxyXG4gICAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZGF0YS5zdGFydFBUUztcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybignQWxyZWFkeSBiYWNrdHJhY2tlZCBvbiB0aGlzIGZyYWdtZW50LCBhcHBlbmRpbmcgd2l0aCB0aGUgZ2FwJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIE9ubHkgcmVzZXQgdGhlIGJhY2t0cmFja2VkIGZsYWcgaWYgd2UndmUgbG9hZGVkIHRoZSBmcmFnIHdpdGhvdXQgYW55IGRyb3BwZWQgZnJhbWVzXHJcbiAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZHJpZnQgPSBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKGxldmVsLmRldGFpbHMsZnJhZyxkYXRhLnN0YXJ0UFRTLGRhdGEuZW5kUFRTLGRhdGEuc3RhcnREVFMsZGF0YS5lbmREVFMpLFxyXG4gICAgICAgICAgaGxzID0gdGhpcy5obHM7XHJcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1BUU19VUERBVEVELCB7ZGV0YWlsczogbGV2ZWwuZGV0YWlscywgbGV2ZWw6IHRoaXMubGV2ZWwsIGRyaWZ0OiBkcmlmdCwgdHlwZTogZGF0YS50eXBlLCBzdGFydDogZGF0YS5zdGFydFBUUywgZW5kOiBkYXRhLmVuZFBUU30pO1xyXG5cclxuICAgICAgLy8gaGFzIHJlbXV4ZXIgZHJvcHBlZCB2aWRlbyBmcmFtZXMgbG9jYXRlZCBiZWZvcmUgZmlyc3Qga2V5ZnJhbWUgP1xyXG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xyXG4gICAgICAgIC8vIG9ubHkgYXBwZW5kIGluIFBBUlNJTkcgc3RhdGUgKHJhdGlvbmFsZSBpcyB0aGF0IGFuIGFwcGVuZGluZyBlcnJvciBjb3VsZCBoYXBwZW4gc3luY2hyb25vdXNseSBvbiBmaXJzdCBzZWdtZW50IGFwcGVuZGluZylcclxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXHJcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcclxuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcclxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XHJcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7dHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudCA6ICdtYWluJyxjb250ZW50IDogJ2RhdGEnfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XHJcbiAgICAgIHRoaXMudGljaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnUGFyc2VkKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcclxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxyXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xyXG4gICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcclxuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25BdWRpb1RyYWNrU3dpdGNoaW5nKGRhdGEpIHtcclxuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcclxuICAgIHZhciBhbHRBdWRpbyA9ICEhZGF0YS51cmwsXHJcbiAgICAgICAgdHJhY2tJZCA9IGRhdGEuaWQ7XHJcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXHJcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBzd2l0Y2ggdG8gYWx0IGF1ZGlvOiBhdWRpbyBzdHJlYW0gY29udHJvbGxlciBpcyBoYW5kbGluZyBpdC5cclxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcclxuICAgIGlmICghYWx0QXVkaW8pIHtcclxuICAgICAgaWYgKHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMubWVkaWEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xyXG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xyXG4gICAgICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXHJcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcclxuICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgLy8gZGVzdHJveSBkZW11eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxyXG4gICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBobHMgPSB0aGlzLmhscztcclxuICAgICAgLy8gc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHtzdGFydE9mZnNldDogMCAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlIDogJ2F1ZGlvJ30pO1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwge2lkIDogdHJhY2tJZH0pO1xyXG4gICAgICB0aGlzLmFsdEF1ZGlvID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChkYXRhKSB7XHJcbiAgICB2YXIgdHJhY2tJZCA9IGRhdGEuaWQsXHJcbiAgICBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xyXG4gICAgaWYgKGFsdEF1ZGlvKSB7XHJcbiAgICAgIGxldCB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XHJcbiAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxyXG4gICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XHJcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHZpZGVvQnVmZmVyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmFsdEF1ZGlvID0gYWx0QXVkaW87XHJcbiAgICB0aGlzLnRpY2soKTtcclxuICB9XHJcblxyXG5cclxuXHJcbiAgb25CdWZmZXJDcmVhdGVkKGRhdGEpIHtcclxuICAgIGxldCB0cmFja3MgPSBkYXRhLnRyYWNrcywgbWVkaWFUcmFjaywgbmFtZSwgYWx0ZXJuYXRlID0gZmFsc2U7XHJcbiAgICBmb3IodmFyIHR5cGUgaW4gdHJhY2tzKSB7XHJcbiAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0eXBlXTtcclxuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcclxuICAgICAgICBuYW1lID0gdHlwZTtcclxuICAgICAgICBtZWRpYVRyYWNrID0gdHJhY2s7XHJcbiAgICAgICAgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxyXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XHJcbiAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdHJhY2tzW3R5cGVdLmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFsdGVybmF0ZSAmJiBtZWRpYVRyYWNrKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYGFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICR7bmFtZX0uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XHJcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25CdWZmZXJBcHBlbmRlZChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJykge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gKGRhdGEucGVuZGluZyA+IDApO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NoZWNrQXBwZW5kZWRQYXJzZWQoKSB7XHJcbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8ICF0aGlzLnBlbmRpbmdCdWZmZXJpbmcpKSB7XHJcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgICBpZiAoZnJhZykge1xyXG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xyXG4gICAgICAgIGxvZ2dlci5sb2coYG1haW4gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xyXG4gICAgICAgIC8vIGZpbHRlciBmcmFnbWVudHMgcG90ZW50aWFsbHkgZXZpY3RlZCBmcm9tIGJ1ZmZlci4gdGhpcyBpcyB0byBhdm9pZCBtZW1sZWFrIG9uIGxpdmUgc3RyZWFtc1xyXG4gICAgICAgIGxldCBidWZmZXJlZEZyYWdzID0gdGhpcy5fYnVmZmVyZWRGcmFncy5maWx0ZXIoZnJhZyA9PiB7cmV0dXJuIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLChmcmFnLnN0YXJ0UFRTICsgZnJhZy5lbmRQVFMpIC8gMik7fSk7XHJcbiAgICAgICAgLy8gcHVzaCBuZXcgcmFuZ2VcclxuICAgICAgICBidWZmZXJlZEZyYWdzLnB1c2goZnJhZyk7XHJcbiAgICAgICAgLy8gc29ydCBmcmFncywgYXMgd2UgdXNlIEJpbmFyeVNlYXJjaCBmb3IgbG9va3VwIGluIGdldEJ1ZmZlcmVkRnJhZyAuLi5cclxuICAgICAgICB0aGlzLl9idWZmZXJlZEZyYWdzID0gYnVmZmVyZWRGcmFncy5zb3J0KGZ1bmN0aW9uKGEsYikge3JldHVybiAoYS5zdGFydFBUUyAtIGIuc3RhcnRQVFMpO30pO1xyXG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcclxuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XHJcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGdldCByaWQgb2YgdGhpcy5mcmFnTGFzdEticHNcclxuICAgICAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoOCAqIHN0YXRzLnRvdGFsIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRmaXJzdCkpO1xyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwge3N0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQgOiAnbWFpbid9KTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRpY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRXJyb3IoZGF0YSkge1xyXG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcgfHzCoHRoaXMuZnJhZ0N1cnJlbnQ7XHJcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBtYWluIGZyYWdtZW50XHJcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdtYWluJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLFxyXG4gICAgICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxyXG4gICAgICAgIG1lZGlhQnVmZmVyZWQgPSBtZWRpYSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSxtZWRpYS5jdXJyZW50VGltZSkgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsbWVkaWEuY3VycmVudFRpbWUrMC41KTtcclxuICAgIHN3aXRjaChkYXRhLmRldGFpbHMpIHtcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XHJcbiAgICAgICAgaWYoIWRhdGEuZmF0YWwpIHtcclxuICAgICAgICAgIHZhciBsb2FkRXJyb3IgPSB0aGlzLmZyYWdMb2FkRXJyb3I7XHJcbiAgICAgICAgICBpZihsb2FkRXJyb3IpIHtcclxuICAgICAgICAgICAgbG9hZEVycm9yKys7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsb2FkRXJyb3I9MTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgICAgICAgIC8vIGtlZXAgcmV0cnlpbmcgLyBkb24ndCByYWlzZSBmYXRhbCBuZXR3b3JrIGVycm9yIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWQgb3IgaWYgaW4gYXV0b21vZGUgd2l0aCBjdXJyZW50IGxldmVsIG5vdCAwXHJcbiAgICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5IHx8IG1lZGlhQnVmZmVyZWQgfHwgKGZyYWcuYXV0b0xldmVsICYmIGZyYWcubGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IGxvYWRFcnJvcjtcclxuICAgICAgICAgICAgLy8gcmVzZXQgbG9hZCBjb3VudGVyIHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yXHJcbiAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcclxuICAgICAgICAgICAgdmFyIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMixsb2FkRXJyb3ItMSkqY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSxjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgbWVkaWFDb250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAke2RlbGF5fSBtc2ApO1xyXG4gICAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XHJcbiAgICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcclxuICAgICAgICAgICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcclxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xyXG4gICAgICAgICAgICBpZighdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgbWVkaWFDb250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uYCk7XHJcbiAgICAgICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxyXG4gICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XHJcbiAgICAgICAgaWYoIWRhdGEuZmF0YWwpIHtcclxuICAgICAgICAgIC8vIGlmIGJ1ZmZlciBpcyBub3QgZW1wdHlcclxuICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XHJcbiAgICAgICAgICAgIC8vIHRyeSB0byByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggOiByYXRpb25hbGUgaXMgdGhhdCB3ZSBjb3VsZCBnZXRcclxuICAgICAgICAgICAgLy8gZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYmVjYXVzZSBvZiBidWZmZXIgZXZpY3Rpb25cclxuICAgICAgICAgICAgdGhpcy5fcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGZyYWcuZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlciBlbXB0eS4gcmVwb3J0IGFzIGZhdGFsIGlmIGluIG1hbnVhbCBtb2RlIG9yIGlmIGxvd2VzdCBsZXZlbC5cclxuICAgICAgICAgICAgLy8gbGV2ZWwgY29udHJvbGxlciB0YWtlcyBjYXJlIG9mIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBsb2dpY1xyXG4gICAgICAgICAgICBpZiAoIWZyYWcuYXV0b0xldmVsIHx8IGZyYWcubGV2ZWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcclxuICAgICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcclxuICAgICAgICBpZih0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xyXG4gICAgICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcclxuICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYHN0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSxzd2l0Y2ggdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgbGV2ZWwsIGlmIGxldmVsIGNvbnRyb2xsZXIgaXMgbm90IHJldHJ5aW5nIHRvIGxvYWQgbGV2ZWwgLCBzd2l0Y2ggYmFjayB0byBJRExFXHJcbiAgICAgICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcclxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XHJcbiAgICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXHJcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHzCoHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkpIHtcclxuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXHJcbiAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcclxuICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XHJcbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYnVmZmVyIHRvIHJlY292ZXJcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBldmVyeXRoaW5nJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKG1pbkxlbmd0aCkge1xyXG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XHJcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxyXG4gICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoLz0yO1xyXG4gICAgICBsb2dnZXIud2FybihgbWFpbjpyZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcclxuICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcclxuICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcclxuICAgIH1cclxuICB9XHJcblxyXG5fY2hlY2tCdWZmZXIoKSB7XHJcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgLy8gaWYgcmVhZHkgc3RhdGUgZGlmZmVyZW50IGZyb20gSEFWRV9OT1RISU5HIChudW1lcmljIHZhbHVlIDApLCB3ZSBhcmUgYWxsb3dlZCB0byBzZWVrXHJcbiAgICBpZihtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWUsXHJcbiAgICAgICAgICAgIG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYSxcclxuICAgICAgICAgICAgIGJ1ZmZlcmVkID0gbWVkaWFCdWZmZXIuYnVmZmVyZWQ7XHJcbiAgICAgIC8vIGFkanVzdCBjdXJyZW50VGltZSB0byBzdGFydCBwb3NpdGlvbiBvbiBsb2FkZWQgbWV0YWRhdGFcclxuICAgICAgaWYoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgYnVmZmVyZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XHJcbiAgICAgICAgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxyXG4gICAgICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXHJcbiAgICAgICAgbGV0IHN0YXJ0UG9zaXRpb24gPSBtZWRpYS5zZWVraW5nID8gY3VycmVudFRpbWUgOiB0aGlzLnN0YXJ0UG9zaXRpb24sXHJcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb25CdWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhQnVmZmVyLHN0YXJ0UG9zaXRpb24pO1xyXG4gICAgICAgIC8vIGlmIGN1cnJlbnRUaW1lIG5vdCBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIHN0YXJ0UG9zaXRpb24gb3Igc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcclxuICAgICAgICBpZiAoY3VycmVudFRpbWUgIT09IHN0YXJ0UG9zaXRpb24gfHwgIXN0YXJ0UG9zaXRpb25CdWZmZXJlZCkge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uOiR7c3RhcnRQb3NpdGlvbn1gKTtcclxuICAgICAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBsZXQncyBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApXHJcbiAgICAgICAgICBpZighc3RhcnRQb3NpdGlvbkJ1ZmZlcmVkKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBidWZmZXJlZC5zdGFydCgwKTtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIG5vdCBidWZmZXJlZCwgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKSAke3N0YXJ0UG9zaXRpb259YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBhZGp1c3QgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3N0YXJ0UG9zaXRpb259YCk7XHJcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XHJcbiAgICAgICAgdGhpcy5pbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsY3VycmVudFRpbWUsMCksXHJcbiAgICAgICAgICAgIGV4cGVjdGVkUGxheWluZyA9ICEobWVkaWEucGF1c2VkIHx8IC8vIG5vdCBwbGF5aW5nIHdoZW4gbWVkaWEgaXMgcGF1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWEuZW5kZWQgIHx8IC8vIG5vdCBwbGF5aW5nIHdoZW4gbWVkaWEgaXMgZW5kZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5idWZmZXJlZC5sZW5ndGggPT09IDApLCAvLyBub3QgcGxheWluZyBpZiBub3RoaW5nIGJ1ZmZlcmVkXHJcbiAgICAgICAgICAgIGp1bXBUaHJlc2hvbGQgPSAwLjUsIC8vIHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIHJhbmdlIGVuZFxyXG4gICAgICAgICAgICBwbGF5aGVhZE1vdmluZyA9IGN1cnJlbnRUaW1lICE9PSB0aGlzLmxhc3RDdXJyZW50VGltZSxcclxuICAgICAgICAgICAgY29uZmlnID0gdGhpcy5jb25maWc7XHJcblxyXG4gICAgICAgIGlmIChwbGF5aGVhZE1vdmluZykge1xyXG4gICAgICAgICAgLy8gcGxheWVkIG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWQgPT4gbm93IG5vdCBzdHVjayBhbnltb3JlXHJcbiAgICAgICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAJHtjdXJyZW50VGltZX0sIGFmdGVyICR7TWF0aC5yb3VuZChwZXJmb3JtYW5jZS5ub3coKS10aGlzLnN0YWxsZWQpfW1zYCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5zdGFsbGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gcGxheWhlYWQgbm90IG1vdmluZ1xyXG4gICAgICAgICAgaWYoZXhwZWN0ZWRQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIHBsYXloZWFkIG5vdCBtb3ZpbmcgQlVUIG1lZGlhIGV4cGVjdGVkIHRvIHBsYXlcclxuICAgICAgICAgICAgY29uc3QgdG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcclxuICAgICAgICAgICAgaWYoIXRoaXMuc3RhbGxlZCkge1xyXG4gICAgICAgICAgICAgIC8vIHN0YWxsIGp1c3QgZGV0ZWN0ZWQsIHN0b3JlIGN1cnJlbnQgdGltZVxyXG4gICAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XHJcbiAgICAgICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gcGxheWJhY2sgYWxyZWFkeSBzdGFsbGVkLCBjaGVjayBzdGFsbGluZyBkdXJhdGlvblxyXG4gICAgICAgICAgICAgIC8vIGlmIHN0YWxsaW5nIGZvciBtb3JlIHRoYW4gYSBnaXZlbiB0aHJlc2hvbGQsIGxldCdzIHRyeSB0byByZWNvdmVyXHJcbiAgICAgICAgICAgICAgY29uc3Qgc3RhbGxlZER1cmF0aW9uID0gdG5vdyAtIHRoaXMuc3RhbGxlZDtcclxuICAgICAgICAgICAgICBjb25zdCBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcclxuICAgICAgICAgICAgICBsZXQgbnVkZ2VSZXRyeSA9IHRoaXMubnVkZ2VSZXRyeSB8fCAwO1xyXG4gICAgICAgICAgICAgIC8vIGhhdmUgd2UgcmVhY2hlZCBzdGFsbCBkZWFkbGluZSA/XHJcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlckxlbiA8PSBqdW1wVGhyZXNob2xkICYmIHN0YWxsZWREdXJhdGlvbiA+IGNvbmZpZy5sb3dCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcG9ydCBzdGFsbGVkIGVycm9yIG9uY2VcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGFsbFJlcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBwbGF5YmFjayBzdGFsbGluZyBpbiBsb3cgYnVmZmVyIEAke2N1cnJlbnRUaW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBidWZmZXIgOiBidWZmZXJMZW59KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIGJ1ZmZlciBsZW4gaXMgYmVsb3cgdGhyZXNob2xkLCB0cnkgdG8ganVtcCB0byBzdGFydCBvZiBuZXh0IGJ1ZmZlciByYW5nZSBpZiBjbG9zZVxyXG4gICAgICAgICAgICAgICAgLy8gbm8gYnVmZmVyIGF2YWlsYWJsZSBAIGN1cnJlbnRUaW1lLCBjaGVjayBpZiBuZXh0IGJ1ZmZlciBpcyBjbG9zZSAod2l0aGluIGEgY29uZmlnLm1heFNlZWtIb2xlIHNlY29uZCByYW5nZSlcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0QnVmZmVyU3RhcnQgPSBidWZmZXJJbmZvLm5leHRTdGFydCwgZGVsdGEgPSBuZXh0QnVmZmVyU3RhcnQtY3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgICAgICBpZihuZXh0QnVmZmVyU3RhcnQgJiZcclxuICAgICAgICAgICAgICAgICAgIChkZWx0YSA8IGNvbmZpZy5tYXhTZWVrSG9sZSkgJiZcclxuICAgICAgICAgICAgICAgICAgIChkZWx0YSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9ICsrbnVkZ2VSZXRyeTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgbnVkZ2VPZmZzZXQgPSBudWRnZVJldHJ5ICogY29uZmlnLm51ZGdlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAvLyBuZXh0IGJ1ZmZlciBpcyBjbG9zZSAhIGFkanVzdCBjdXJyZW50VGltZSB0byBuZXh0QnVmZmVyU3RhcnRcclxuICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGVuc3VyZSBlZmZlY3RpdmUgdmlkZW8gZGVjb2RpbmdcclxuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgYWRqdXN0IGN1cnJlbnRUaW1lIGZyb20gJHttZWRpYS5jdXJyZW50VGltZX0gdG8gbmV4dCBidWZmZXJlZCBAICR7bmV4dEJ1ZmZlclN0YXJ0fSArIG51ZGdlICR7bnVkZ2VPZmZzZXR9YCk7XHJcbiAgICAgICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbmV4dEJ1ZmZlclN0YXJ0ICsgbnVkZ2VPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHN0YWxsZWQgc28gdG8gcmVhcm0gd2F0Y2hkb2cgdGltZXJcclxuICAgICAgICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsIGZhdGFsOiBmYWxzZSwgaG9sZSA6IG5leHRCdWZmZXJTdGFydCArIG51ZGdlT2Zmc2V0IC0gY3VycmVudFRpbWV9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlckxlbiA+IGp1bXBUaHJlc2hvbGQgJiYgc3RhbGxlZER1cmF0aW9uID4gY29uZmlnLmhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcG9ydCBzdGFsbGVkIGVycm9yIG9uY2VcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGFsbFJlcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBwbGF5YmFjayBzdGFsbGluZyBpbiBoaWdoIGJ1ZmZlciBAJHtjdXJyZW50VGltZX1gKTtcclxuICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnVmZmVyIDogYnVmZmVyTGVufSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWxsZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSArK251ZGdlUmV0cnk7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIG51ZGdlUmV0cnkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcclxuICAgICAgICAgICAgICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xyXG4gICAgICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCwgZmF0YWw6IGZhbHNlfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYHN0aWxsIHN0dWNrIGluIGhpZ2ggYnVmZmVyIEAke2N1cnJlbnRUaW1lfSBhZnRlciAke2NvbmZpZy5udWRnZU1heFJldHJ5fSwgcmFpc2UgZmF0YWwgZXJyb3JgKTtcclxuICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsIGZhdGFsOiB0cnVlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcclxuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcclxuICAgIGlmKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XHJcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcclxuICAgIH1cclxuICAgIHRoaXMudGljaygpO1xyXG4gIH1cclxuXHJcbiAgb25CdWZmZXJGbHVzaGVkKCkge1xyXG4gICAgLyogYWZ0ZXIgc3VjY2Vzc2Z1bCBidWZmZXIgZmx1c2hpbmcsIGZpbHRlciBmbHVzaGVkIGZyYWdtZW50cyBmcm9tIGJ1ZmZlcmVkRnJhZ3NcclxuICAgICAgdXNlIG1lZGlhQnVmZmVyZWQgaW5zdGVhZCBvZiBtZWRpYSAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxyXG4gICAgKi9cclxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xyXG4gICAgdGhpcy5fYnVmZmVyZWRGcmFncyA9IHRoaXMuX2J1ZmZlcmVkRnJhZ3MuZmlsdGVyKGZyYWcgPT4ge3JldHVybiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwoZnJhZy5zdGFydFBUUyArIGZyYWcuZW5kUFRTKSAvIDIpO30pO1xyXG5cclxuICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXHJcbiAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XHJcbiAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xyXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xyXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgc3dhcEF1ZGlvQ29kZWMoKSB7XHJcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XHJcbiAgfVxyXG5cclxuICBjb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGxldmVsRGV0YWlscykge1xyXG4gICAgbGV0IHRhcmdldExhdGVuY3kgPSB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uIDogdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIHNsaWRpbmcgKyBNYXRoLm1heCgwLCBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbiAtIHRhcmdldExhdGVuY3kpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBsaXZlU3luY1Bvc2l0aW9uKHZhbHVlKSB7XHJcbiAgICB0aGlzLl9saXZlU3luY1Bvc2l0aW9uID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFN0cmVhbUNvbnRyb2xsZXI7XHJcblxyXG4iLCIvKlxyXG4gKiBTdWJ0aXRsZSBTdHJlYW0gQ29udHJvbGxlclxyXG4qL1xyXG5cclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuY2xhc3MgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsXHJcbiAgICAgIEV2ZW50LkVSUk9SLFxyXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCxcclxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfU1dJVENILFxyXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQsXHJcbiAgICAgIEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEKTtcclxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcclxuICAgIHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZCA9IHt9O1xyXG4gICAgdGhpcy52dHRGcmFnUXVldWVzID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudFRyYWNrSWQgPSAtMTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSBhbGwgcXVldWVkIGl0ZW1zIGFuZCBjcmVhdGUgYSBuZXcsIGVtcHR5IHF1ZXVlIGZvciBlYWNoIHRyYWNrLlxyXG4gIGNsZWFyVnR0RnJhZ1F1ZXVlcygpIHtcclxuICAgIHRoaXMudnR0RnJhZ1F1ZXVlcyA9IHt9O1xyXG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgIHRoaXMudnR0RnJhZ1F1ZXVlc1t0cmFjay5pZF0gPSBbXTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgbm8gZnJhZyBpcyBiZWluZyBwcm9jZXNzZWQgYW5kIHF1ZXVlIGlzbid0IGVtcHR5LCBpbml0aWF0ZSBwcm9jZXNzaW5nIG9mIG5leHQgZnJhZyBpbiBsaW5lLlxyXG4gIG5leHRGcmFnKCkge1xyXG4gICAgaWYodGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID09PSBudWxsICYmIHRoaXMuY3VycmVudFRyYWNrSWQgPiAtMSAmJiB0aGlzLnZ0dEZyYWdRdWV1ZXNbdGhpcy5jdXJyZW50VHJhY2tJZF0ubGVuZ3RoKSB7XHJcbiAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID0gdGhpcy52dHRGcmFnUXVldWVzW3RoaXMuY3VycmVudFRyYWNrSWRdLnNoaWZ0KCk7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7ZnJhZ30pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gV2hlbiBmcmFnbWVudCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZywgYWRkIHNuIHRvIGxpc3Qgb2YgY29tcGxldGVkIGlmIHN1Y2Nlc3NmdWwuXHJcbiAgb25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQoZGF0YSkge1xyXG4gICAgaWYoZGF0YS5zdWNjZXNzKSB7XHJcbiAgICAgIHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZFtkYXRhLmZyYWcudHJhY2tJZF0ucHVzaChkYXRhLmZyYWcuc24pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID0gbnVsbDtcclxuICAgIHRoaXMubmV4dEZyYWcoKTtcclxuICB9XHJcblxyXG4gIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWRlIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cclxuICBvbkVycm9yKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gc3VidGl0bGUgZnJhZ21lbnRcclxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ3N1YnRpdGxlJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZih0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcpIHtcclxuICAgICAgdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID0gbnVsbDtcclxuICAgICAgdGhpcy5uZXh0RnJhZygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgdHJhY2tzLlxyXG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGRhdGEpIHtcclxuICAgIGxvZ2dlci5sb2coJ3N1YnRpdGxlIHRyYWNrcyB1cGRhdGVkJyk7XHJcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XHJcbiAgICB0aGlzLmNsZWFyVnR0RnJhZ1F1ZXVlcygpO1xyXG4gICAgdGhpcy52dHRGcmFnU05zUHJvY2Vzc2VkID0ge307XHJcbiAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgdGhpcy52dHRGcmFnU05zUHJvY2Vzc2VkW3RyYWNrLmlkXSA9IFtdO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZGF0YSkge1xyXG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XHJcbiAgICB0aGlzLmNsZWFyVnR0RnJhZ1F1ZXVlcygpO1xyXG4gIH1cclxuXHJcbiAgLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXHJcbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGRhdGEpIHtcclxuICAgIGNvbnN0IHByb2Nlc3NlZEZyYWdTTnMgPSB0aGlzLnZ0dEZyYWdTTnNQcm9jZXNzZWRbZGF0YS5pZF0sXHJcbiAgICAgICAgZnJhZ1F1ZXVlID0gdGhpcy52dHRGcmFnUXVldWVzW2RhdGEuaWRdLFxyXG4gICAgICAgIGN1cnJlbnRGcmFnU04gPSAhIXRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA/IHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZy5zbiA6IC0xO1xyXG5cclxuICAgIGNvbnN0IGFscmVhZHlQcm9jZXNzZWQgPSBmdW5jdGlvbihmcmFnKSB7XHJcbiAgICAgIHJldHVybiBwcm9jZXNzZWRGcmFnU05zLmluZGV4T2YoZnJhZy5zbikgPiAtMTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgYWxyZWFkeUluUXVldWUgPSBmdW5jdGlvbihmcmFnKSB7XHJcbiAgICAgIHJldHVybiBmcmFnUXVldWUuc29tZShmcmFnSW5RdWV1ZSA9PiB7cmV0dXJuIGZyYWdJblF1ZXVlLnNuID09PSBmcmFnLnNuO30pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyB0aGF0IGhhdmVuJ3QgYmVlbiwgYXJlbid0IGN1cnJlbnRseSBiZWluZyBhbmQgYXJlbid0IHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkLCB0byBxdWV1ZS5cclxuICAgIGRhdGEuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnID0+wqB7XHJcbiAgICAgIGlmKCEoYWxyZWFkeVByb2Nlc3NlZChmcmFnKSB8fCBmcmFnLnNuID09PSBjdXJyZW50RnJhZ1NOIHx8IGFscmVhZHlJblF1ZXVlKGZyYWcpKSkge1xyXG4gICAgICAgIC8vIEZyYWdzIGRvbid0IGtub3cgdGhlaXIgc3VidGl0bGUgdHJhY2sgSUQsIHNvIGxldCdzIGp1c3QgYWRkIHRoYXQuLi5cclxuICAgICAgICBmcmFnLnRyYWNrSWQgPSBkYXRhLmlkO1xyXG4gICAgICAgIGZyYWdRdWV1ZS5wdXNoKGZyYWcpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm5leHRGcmFnKCk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcclxuXHJcbiIsIi8qXHJcbiAqIGF1ZGlvIHRyYWNrIGNvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzKHRleHRUcmFja0xpc3QpIHtcclxuICBsZXQgdHJhY2tzID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAodGV4dFRyYWNrTGlzdFtpXS5raW5kID09PSAnc3VidGl0bGVzJykge1xyXG4gICAgICB0cmFja3MucHVzaCh0ZXh0VHJhY2tMaXN0W2ldKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRyYWNrcztcclxufVxyXG5cclxuY2xhc3MgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscyxcclxuICAgICAgICAgICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXHJcbiAgICAgICAgICAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcclxuICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcclxuICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxyXG4gICAgICAgICAgICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQpO1xyXG4gICAgdGhpcy50cmFja3MgPSBbXTtcclxuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xyXG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8vIExpc3RlbiBmb3Igc3VidGl0bGUgdHJhY2sgY2hhbmdlLCB0aGVuIGV4dHJhY3QgdGhlIGN1cnJlbnQgdHJhY2sgSUQuXHJcbiAgb25NZWRpYUF0dGFjaGVkKGRhdGEpIHtcclxuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xyXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAvLyBNZWRpYSBpcyB1bmRlZmluZWQgd2hlbiBzd2l0Y2hpbmcgc3RyZWFtcyB2aWEgbG9hZFNvdXJjZSgpXHJcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHRyYWNrSWQgPSAtMTtcclxuICAgICAgbGV0IHRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XHJcbiAgICAgIGZvciAobGV0IGlkID0gMDsgaWQgPCB0cmFja3MubGVuZ3RoOyBpZCsrKSB7XHJcbiAgICAgICAgaWYgKHRyYWNrc1tpZF0ubW9kZSA9PT0gJ3Nob3dpbmcnKSB7XHJcbiAgICAgICAgICB0cmFja0lkID0gaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIFNldHRpbmcgY3VycmVudCBzdWJ0aXRsZVRyYWNrIHdpbGwgaW52b2tlIGNvZGUuXHJcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrSWQ7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XHJcbiAgICAvLyBUT0RPOiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIC8vIFJlc2V0IHN1YnRpdGxlIHRyYWNrcyBvbiBtYW5pZmVzdCBsb2FkaW5nXHJcbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XHJcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xyXG4gICAgdGhpcy50cmFja0lkID0gLTE7XHJcbiAgfVxyXG5cclxuICAvLyBGaXJlZCB3aGVuZXZlciBhIG5ldyBtYW5pZmVzdCBpcyBsb2FkZWQuXHJcbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XHJcbiAgICBsZXQgdHJhY2tzID0gZGF0YS5zdWJ0aXRsZXMgfHwgW107XHJcbiAgICBsZXQgZGVmYXVsdEZvdW5kID0gZmFsc2U7XHJcbiAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcclxuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwge3N1YnRpdGxlVHJhY2tzIDogdHJhY2tzfSk7XHJcblxyXG4gICAgLy8gbG9vcCB0aHJvdWdoIGF2YWlsYWJsZSBzdWJ0aXRsZSB0cmFja3MgYW5kIGF1dG9zZWxlY3QgZGVmYXVsdCBpZiBuZWVkZWRcclxuICAgIC8vIFRPRE86IGltcHJvdmUgc2VsZWN0aW9uIGxvZ2ljIHRvIGhhbmRsZSBmb3JjZWQsIGV0Y1xyXG4gICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICBpZiAodHJhY2suZGVmYXVsdCkge1xyXG4gICAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrLmlkO1xyXG4gICAgICAgIGRlZmF1bHRGb3VuZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVHJpZ2dlciBzdWJ0aXRsZSB0cmFjayBwbGF5bGlzdCByZWxvYWQuXHJcbiAgb25UaWNrKCkge1xyXG4gICAgY29uc3QgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcclxuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXTtcclxuICAgIGlmICghc3VidGl0bGVUcmFjaykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGV0YWlscyA9IHN1YnRpdGxlVHJhY2suZGV0YWlscztcclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBzdWJ0aXRsZSBUcmFja1xyXG4gICAgaWYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBkZXRhaWxzLmxpdmUgPT09IHRydWUpIHtcclxuICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxyXG4gICAgICBsb2dnZXIubG9nKGAocmUpbG9hZGluZyBwbGF5bGlzdCBmb3Igc3VidGl0bGUgdHJhY2sgJHt0cmFja0lkfWApO1xyXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHt1cmw6IHN1YnRpdGxlVHJhY2sudXJsLCBpZDogdHJhY2tJZH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGRhdGEpIHtcclxuICAgIGlmIChkYXRhLmlkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYHN1YnRpdGxlIHRyYWNrICR7ZGF0YS5pZH0gbG9hZGVkYCk7XHJcbiAgICAgIHRoaXMudHJhY2tzW2RhdGEuaWRdLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XHJcbiAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XHJcbiAgICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSAmJiAhdGhpcy50aW1lcikge1xyXG4gICAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3Qgd2Ugd2lsbCBoYXZlIHRvIHJlbG9hZCBpdCBwZXJpb2RpY2FsbHlcclxuICAgICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cclxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5vblRpY2soKTtcclxuICAgICAgICB9LCAxMDAwICogZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uLCB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWRhdGEuZGV0YWlscy5saXZlICYmIHRoaXMudGltZXIpIHtcclxuICAgICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgYXJtZWQgOiBzdG9wcGluZyBpdFxyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXHJcbiAgZ2V0IHN1YnRpdGxlVHJhY2tzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xyXG4gIH1cclxuXHJcbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cclxuICBnZXQgc3VidGl0bGVUcmFjaygpIHtcclxuICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcclxuICB9XHJcblxyXG4gIC8qKiBzZWxlY3QgYSBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKiovXHJcbiAgc2V0IHN1YnRpdGxlVHJhY2soc3VidGl0bGVUcmFja0lkKSB7XHJcbiAgICBpZiAodGhpcy50cmFja0lkICE9PSBzdWJ0aXRsZVRyYWNrSWQpIHsvLyB8fCB0aGlzLnRyYWNrc1tzdWJ0aXRsZVRyYWNrSWRdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2tJbnRlcm5hbChzdWJ0aXRsZVRyYWNrSWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiBzZXRTdWJ0aXRsZVRyYWNrSW50ZXJuYWwobmV3SWQpIHtcclxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxyXG4gICAgaWYgKG5ld0lkID49IDAgJiYgbmV3SWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcclxuICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XHJcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XHJcbiAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XHJcbiAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyB0byBzdWJ0aXRsZSB0cmFjayAke25ld0lkfWApO1xyXG4gICAgICBsZXQgc3VidGl0bGVUcmFjayA9IHRoaXMudHJhY2tzW25ld0lkXTtcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHtpZDogbmV3SWR9KTtcclxuICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBzdWJ0aXRsZSBUcmFja1xyXG4gICAgICBsZXQgZGV0YWlscyA9IHN1YnRpdGxlVHJhY2suZGV0YWlscztcclxuICAgICAgaWYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBkZXRhaWxzLmxpdmUgPT09IHRydWUpIHtcclxuICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIHN1YnRpdGxlIHRyYWNrICR7bmV3SWR9YCk7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB7dXJsOiBzdWJ0aXRsZVRyYWNrLnVybCwgaWQ6IG5ld0lkfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xyXG4iLCIvKlxyXG4gKiBUaW1lbGluZSBDb250cm9sbGVyXHJcbiovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IENlYTYwOFBhcnNlciBmcm9tICcuLi91dGlscy9jZWEtNjA4LXBhcnNlcic7XHJcbmltcG9ydCBXZWJWVFRQYXJzZXIgZnJvbSAnLi4vdXRpbHMvd2VidnR0LXBhcnNlcic7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaykge1xyXG4gIGlmICh0cmFjayAmJiB0cmFjay5jdWVzKSB7XHJcbiAgICB3aGlsZSAodHJhY2suY3Vlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzWzBdKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2ssIG1hbmlmZXN0VHJhY2spIHtcclxuICByZXR1cm4gaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHgxLCB4MiwgeTEsIHkyKSB7XHJcbiAgcmV0dXJuIE1hdGgubWluKHgyLCB5MikgLSBNYXRoLm1heCh4MSwgeTEpO1xyXG59XHJcblxyXG5jbGFzcyBUaW1lbGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscywgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxyXG4gICAgICAgICAgICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxyXG4gICAgICAgICAgICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLFxyXG4gICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcclxuICAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcclxuICAgICAgICAgICAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxyXG4gICAgICAgICAgICAgICAgRXZlbnQuTEVWRUxfU1dJVENISU5HLFxyXG4gICAgICAgICAgICAgICAgRXZlbnQuSU5JVF9QVFNfRk9VTkQpO1xyXG5cclxuICAgIHRoaXMuaGxzID0gaGxzO1xyXG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xyXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgIHRoaXMuQ3VlcyA9IGhscy5jb25maWcuY3VlSGFuZGxlcjtcclxuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xyXG4gICAgdGhpcy50cmFja3MgPSBbXTtcclxuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xyXG4gICAgdGhpcy5pbml0UFRTID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcclxuXHJcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpXHJcbiAgICB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgdmFyIHNlbmRBZGRUcmFja0V2ZW50ID0gZnVuY3Rpb24gKHRyYWNrLCBtZWRpYSlcclxuICAgICAge1xyXG4gICAgICAgIHZhciBlID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZSA9IG5ldyB3aW5kb3cuRXZlbnQoJ2FkZHRyYWNrJyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAvL2ZvciBJRTExXHJcbiAgICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICAgICAgICBlLmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlLnRyYWNrID0gdHJhY2s7XHJcbiAgICAgICAgbWVkaWEuZGlzcGF0Y2hFdmVudChlKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBjaGFubmVsMSA9XHJcbiAgICAgIHtcclxuICAgICAgICAnbmV3Q3VlJzogZnVuY3Rpb24oc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWYgKCFzZWxmLnRleHRUcmFjazEpXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXHJcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1RyYWNrMSA9IHNlbGYuZ2V0RXhpc3RpbmdUcmFjaygnMScpO1xyXG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVHJhY2sxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdGV4dFRyYWNrMSA9IHNlbGYuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsIHNlbGYuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLCBzZWxmLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGUpO1xyXG4gICAgICAgICAgICAgIGlmICh0ZXh0VHJhY2sxKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0VHJhY2sxLnRleHRUcmFjazEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2sxID0gdGV4dFRyYWNrMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2sxID0gZXhpc3RpbmdUcmFjazE7XHJcbiAgICAgICAgICAgICAgY2xlYXJDdXJyZW50Q3VlcyhzZWxmLnRleHRUcmFjazEpO1xyXG5cclxuICAgICAgICAgICAgICBzZW5kQWRkVHJhY2tFdmVudChzZWxmLnRleHRUcmFjazEsIHNlbGYubWVkaWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZWxmLmFkZEN1ZXMoJ3RleHRUcmFjazEnLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGNoYW5uZWwyID1cclxuICAgICAge1xyXG4gICAgICAgICduZXdDdWUnOiBmdW5jdGlvbihzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZiAoIXNlbGYudGV4dFRyYWNrMilcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgLy9FbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVHJhY2syID0gc2VsZi5nZXRFeGlzdGluZ1RyYWNrKCcyJyk7XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUcmFjazIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBjb25zdCB0ZXh0VHJhY2syID0gc2VsZi5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgc2VsZi5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwsIHNlbGYuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHRleHRUcmFjazIpIHtcclxuICAgICAgICAgICAgICAgIHRleHRUcmFjazIudGV4dFRyYWNrMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazIgPSB0ZXh0VHJhY2syO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazIgPSBleGlzdGluZ1RyYWNrMjtcclxuICAgICAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHNlbGYudGV4dFRyYWNrMik7XHJcblxyXG4gICAgICAgICAgICAgIHNlbmRBZGRUcmFja0V2ZW50KHNlbGYudGV4dFRyYWNrMiwgc2VsZi5tZWRpYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNlbGYuYWRkQ3VlcygndGV4dFRyYWNrMicsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmNlYTYwOFBhcnNlciA9IG5ldyBDZWE2MDhQYXJzZXIoMCwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFkZEN1ZXMoY2hhbm5lbCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcclxuICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xyXG4gICAgY29uc3QgcmFuZ2VzID0gdGhpcy5jdWVSYW5nZXM7XHJcbiAgICBsZXQgbWVyZ2VkID0gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOykge1xyXG4gICAgICBsZXQgY3VlUmFuZ2UgPSByYW5nZXNbaV07XHJcbiAgICAgIGxldCBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcclxuICAgICAgaWYgKG92ZXJsYXAgPj0gMCkge1xyXG4gICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XHJcbiAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkpID4gMC41KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW1lcmdlZCkge1xyXG4gICAgICByYW5nZXMucHVzaChbc3RhcnRUaW1lLCBlbmRUaW1lXSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLkN1ZXMubmV3Q3VlKHRoaXNbY2hhbm5lbF0sIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcclxuICB9XHJcblxyXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGluaXRpYWwgUFRTIGlzIGZvdW5kOyB1c2VkIGZvciBzeW5jaHJvbmlzYXRpb24gb2YgV2ViVlRULlxyXG4gIG9uSW5pdFB0c0ZvdW5kKGRhdGEpIHtcclxuICAgIGlmICh0eXBlb2YgdGhpcy5pbml0UFRTID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aGlzLmluaXRQVFMgPSBkYXRhLmluaXRQVFM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHVlIHRvIGFzeW5jaHJvbnksIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxyXG4gICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXHJcbiAgICBpZiAodGhpcy51bnBhcnNlZFZ0dEZyYWdzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MuZm9yRWFjaChmcmFnID0+IHtcclxuICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZChmcmFnKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0RXhpc3RpbmdUcmFjayhjaGFubmVsTnVtYmVyKSB7XHJcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYS50ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHRleHRUcmFjayA9IG1lZGlhLnRleHRUcmFja3NbaV07XHJcbiAgICAgICAgbGV0IHByb3BOYW1lID0gJ3RleHRUcmFjaycgKyBjaGFubmVsTnVtYmVyO1xyXG4gICAgICAgIGlmICh0ZXh0VHJhY2tbcHJvcE5hbWVdID09PSB0cnVlKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpIHtcclxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgIGlmIChtZWRpYSlcclxuICAgIHtcclxuICAgICAgcmV0dXJuIG1lZGlhLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcclxuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYURldGFjaGluZygpIHtcclxuICAgIGNsZWFyQ3VycmVudEN1ZXModGhpcy50ZXh0VHJhY2sxKTtcclxuICAgIGNsZWFyQ3VycmVudEN1ZXModGhpcy50ZXh0VHJhY2syKTtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RMb2FkaW5nKClcclxuICB7XHJcbiAgICB0aGlzLmxhc3RTbiA9IC0xOyAvLyBEZXRlY3QgZGlzY29udGlndWl0eSBpbiBmcmFnbWVudCBwYXJzaW5nXHJcbiAgICB0aGlzLnByZXZDQyA9IC0xO1xyXG4gICAgdGhpcy52dHRDQ3MgPSB7Y2NPZmZzZXQ6IDAsIHByZXNlbnRhdGlvbk9mZnNldDogMH07IC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHN1YnRpdGxlIG1hbmlmZXN0c1xyXG5cclxuICAgIC8vIGNsZWFyIG91dGRhdGVkIHN1YnRpdGxlc1xyXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgIGNvbnN0IHRleHRUcmFja3MgPSBtZWRpYS50ZXh0VHJhY2tzO1xyXG4gICAgICBpZiAodGV4dFRyYWNrcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0ZXh0VHJhY2tzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RMb2FkZWQoZGF0YSkge1xyXG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XHJcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgfHwgW107XHJcbiAgICB0aGlzLmluaXRQVFMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xyXG5cclxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQpIHtcclxuICAgICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlcyB8fCBbXTtcclxuICAgICAgY29uc3QgaW5Vc2VUcmFja3MgPSB0aGlzLm1lZGlhID8gdGhpcy5tZWRpYS50ZXh0VHJhY2tzIDogW107XHJcblxyXG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKCh0cmFjaywgaW5kZXgpID0+IHtcclxuICAgICAgICBsZXQgdGV4dFRyYWNrO1xyXG4gICAgICAgIGlmIChpbmRleCA8IGluVXNlVHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgY29uc3QgaW5Vc2VUcmFjayA9IGluVXNlVHJhY2tzW2luZGV4XTtcclxuICAgICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXHJcbiAgICAgICAgICBpZiAocmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFjaywgdHJhY2spKSB7XHJcbiAgICAgICAgICAgIHRleHRUcmFjayA9IGluVXNlVHJhY2s7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGV4dFRyYWNrKSB7XHJcbiAgICAgICAgICAgIHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKCdzdWJ0aXRsZXMnLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSB0cmFjay5kZWZhdWx0ID8gJ3Nob3dpbmcnIDogJ2hpZGRlbic7XHJcbiAgICAgICAgdGhpcy50ZXh0VHJhY2tzLnB1c2godGV4dFRyYWNrKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkxldmVsU3dpdGNoaW5nKCkge1xyXG4gICAgdGhpcy5lbmFibGVkID0gdGhpcy5obHMuY3VycmVudExldmVsLmNsb3NlZENhcHRpb25zICE9PSAnTk9ORSc7XHJcbiAgfVxyXG5cclxuICBvbkZyYWdMb2FkZWQoZGF0YSkge1xyXG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXHJcbiAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XHJcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcclxuICAgICAgdmFyIHNuID0gZnJhZy5zbjtcclxuICAgICAgLy8gaWYgdGhpcyBmcmFnIGlzbid0IGNvbnRpZ3VvdXMsIGNsZWFyIHRoZSBwYXJzZXIgc28gY3VlcyB3aXRoIGJhZCBzdGFydC9lbmQgdGltZXMgYXJlbid0IGFkZGVkIHRvIHRoZSB0ZXh0VHJhY2tcclxuICAgICAgaWYgKHNuICE9PSB0aGlzLmxhc3RTbiArIDEpIHtcclxuICAgICAgICBjb25zdCBjZWE2MDhQYXJzZXIgPSB0aGlzLmNlYTYwOFBhcnNlcjtcclxuICAgICAgICBpZiAoY2VhNjA4UGFyc2VyKSB7XHJcbiAgICAgICAgICBjZWE2MDhQYXJzZXIucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5sYXN0U24gPSBzbjtcclxuICAgIH1cclxuICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cclxuICAgIGVsc2UgaWYgKGZyYWcudHlwZSA9PT0gJ3N1YnRpdGxlJykge1xyXG4gICAgICBpZiAocGF5bG9hZC5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCBhbiBpbml0aWFsIHN5bmNocm9uaXNhdGlvbiBQVFMuIFN0b3JlIGZyYWdtZW50cyBhcyBsb25nIGFzIG5vbmUgaGFzIGFycml2ZWQuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmluaXRQVFMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHZ0dENDcyA9IHRoaXMudnR0Q0NzO1xyXG4gICAgICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XHJcbiAgICAgICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7IHN0YXJ0OiBmcmFnLnN0YXJ0LCBwcmV2Q0M6IHRoaXMucHJldkNDLCBuZXc6IHRydWUgfTtcclxuICAgICAgICAgIHRoaXMucHJldkNDID0gZnJhZy5jYztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRleHRUcmFja3MgPSB0aGlzLnRleHRUcmFja3MsXHJcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcclxuXHJcbiAgICAgICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxyXG4gICAgICAgIFdlYlZUVFBhcnNlci5wYXJzZShwYXlsb2FkLCB0aGlzLmluaXRQVFMsIHZ0dENDcywgZnJhZy5jYywgZnVuY3Rpb24gKGN1ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRyYWNrID0gdGV4dFRyYWNrc1tmcmFnLnRyYWNrSWRdO1xyXG4gICAgICAgICAgICAvLyBBZGQgY3VlcyBhbmQgdHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgdHJ1ZS5cclxuICAgICAgICAgICAgY3Vlcy5mb3JFYWNoKGN1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcclxuICAgICAgICAgICAgICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxyXG4gICAgICAgICAgICAgIC8vIFRoaXMgYXZvaWQgc2hvd2luZyBkdXBsaWNhdGVkIGN1ZXMgd2l0aCBzYW1lIHRpbWVjb2RlIGFuZCB0ZXh0LlxyXG4gICAgICAgICAgICAgIGlmICghY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2suYWRkQ3VlKGN1ZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtzdWNjZXNzOiB0cnVlLCBmcmFnOiBmcmFnfSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgcGFyc2luZy4gVHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgZmFsc2UuXHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiAke2V9YCk7XHJcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7c3VjY2VzczogZmFsc2UsIGZyYWc6IGZyYWd9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gcGF5bG9hZCwgZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LlxyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZyYWdQYXJzaW5nVXNlcmRhdGEoZGF0YSkge1xyXG4gICAgLy8gcHVzaCBhbGwgb2YgdGhlIENFQS03MDggbWVzc2FnZXMgaW50byB0aGUgaW50ZXJwcmV0ZXJcclxuICAgIC8vIGltbWVkaWF0ZWx5LiBJdCB3aWxsIGNyZWF0ZSB0aGUgcHJvcGVyIHRpbWVzdGFtcHMgYmFzZWQgb24gb3VyIFBUUyB2YWx1ZVxyXG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucykge1xyXG4gICAgICBmb3IgKHZhciBpPTA7IGk8ZGF0YS5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGRhdGEuc2FtcGxlc1tpXS5ieXRlcyk7XHJcbiAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIuYWRkRGF0YShkYXRhLnNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0cmFjdENlYTYwOERhdGEoYnl0ZUFycmF5KSB7XHJcbiAgICB2YXIgY291bnQgPSBieXRlQXJyYXlbMF0gJiAzMTtcclxuICAgIHZhciBwb3NpdGlvbiA9IDI7XHJcbiAgICB2YXIgdG1wQnl0ZSwgY2NieXRlMSwgY2NieXRlMiwgY2NWYWxpZCwgY2NUeXBlO1xyXG4gICAgdmFyIGFjdHVhbENDQnl0ZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcclxuICAgICAgdG1wQnl0ZSA9IGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcclxuICAgICAgY2NieXRlMSA9IDB4N0YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XHJcbiAgICAgIGNjYnl0ZTIgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xyXG4gICAgICBjY1ZhbGlkID0gKDQgJiB0bXBCeXRlKSAhPT0gMDtcclxuICAgICAgY2NUeXBlID0gMyAmIHRtcEJ5dGU7XHJcblxyXG4gICAgICBpZiAoY2NieXRlMSA9PT0gMCAmJiBjY2J5dGUyID09PSAwKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjY1ZhbGlkKSB7XHJcbiAgICAgICAgaWYgKGNjVHlwZSA9PT0gMCkgLy8gfHwgY2NUeXBlID09PSAxXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTEpO1xyXG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjdHVhbENDQnl0ZXM7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUaW1lbGluZUNvbnRyb2xsZXI7XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFFU0NyeXB0byB7XHJcbiAgY29uc3RydWN0b3Ioc3VidGxlLGl2KSB7XHJcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcclxuICAgIHRoaXMuYWVzSVYgPSBpdjtcclxuICB9XHJcblxyXG4gIGRlY3J5cHQoZGF0YSwga2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuZGVjcnlwdCh7bmFtZTogJ0FFUy1DQkMnLCBpdjogdGhpcy5hZXNJVn0sIGtleSwgZGF0YSk7XHJcbiAgfVxyXG59XHJcbiIsImNsYXNzIEFFU0RlY3J5cHRvciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvLyBTdGF0aWMgYWZ0ZXIgcnVubmluZyBpbml0VGFibGVcclxuICAgIHRoaXMucmNvbiA9IFsweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XHJcbiAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KV07XHJcbiAgICB0aGlzLmludlN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KV07XHJcbiAgICB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcclxuICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xyXG5cclxuICAgIC8vIENoYW5nZXMgZHVyaW5nIHJ1bnRpbWVcclxuICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xyXG5cclxuICAgIHRoaXMuaW5pdFRhYmxlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXHJcbiAgdWludDhBcnJheVRvVWludDMyQXJyYXlfKGFycmF5QnVmZmVyKSB7XHJcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XHJcbiAgICBsZXQgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdBcnJheTtcclxuICB9XHJcblxyXG4gIGluaXRUYWJsZSgpIHtcclxuICAgIGxldCBzQm94ID0gdGhpcy5zQm94O1xyXG4gICAgbGV0IGludlNCb3ggPSB0aGlzLmludlNCb3g7XHJcbiAgICBsZXQgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XHJcbiAgICBsZXQgc3ViTWl4MCA9IHN1Yk1peFswXTtcclxuICAgIGxldCBzdWJNaXgxID0gc3ViTWl4WzFdO1xyXG4gICAgbGV0IHN1Yk1peDIgPSBzdWJNaXhbMl07XHJcbiAgICBsZXQgc3ViTWl4MyA9IHN1Yk1peFszXTtcclxuICAgIGxldCBpbnZTdWJNaXggID0gdGhpcy5pbnZTdWJNaXg7XHJcbiAgICBsZXQgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcclxuICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xyXG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XHJcbiAgICBsZXQgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcclxuXHJcbiAgICBsZXQgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xyXG4gICAgbGV0IHggPSAwO1xyXG4gICAgbGV0IHhpID0gMDtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xyXG4gICAgICBpZiAoaSA8IDEyOCkge1xyXG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgbGV0IHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XHJcbiAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2MztcclxuICAgICAgc0JveFt4XSA9IHN4O1xyXG4gICAgICBpbnZTQm94W3N4XSA9IHg7XHJcblxyXG4gICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgIGxldCB4MiA9IGRbeF07XHJcbiAgICAgIGxldCB4NCA9IGRbeDJdO1xyXG4gICAgICBsZXQgeDggPSBkW3g0XTtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXHJcbiAgICAgIGxldCB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcclxuICAgICAgc3ViTWl4MFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcclxuICAgICAgc3ViTWl4MVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XHJcbiAgICAgIHN1Yk1peDJbeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XHJcbiAgICAgIHN1Yk1peDNbeF0gPSB0O1xyXG5cclxuICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXHJcbiAgICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XHJcbiAgICAgIGludlN1Yk1peDBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xyXG4gICAgICBpbnZTdWJNaXgxW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XHJcbiAgICAgIGludlN1Yk1peDJbc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xyXG4gICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7XHJcblxyXG4gICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxyXG4gICAgICBpZiAoIXgpIHtcclxuICAgICAgICB4ID0geGkgPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XHJcbiAgICAgICAgeGkgXj0gZFtkW3hpXV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4cGFuZEtleShrZXlCdWZmZXIpIHtcclxuICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XHJcbiAgICBsZXQga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcclxuICAgIGxldCBzYW1lS2V5ID0gdHJ1ZTtcclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG5cclxuICAgIHdoaWxlIChvZmZzZXQgPCBrZXkubGVuZ3RoICYmIHNhbWVLZXkpIHtcclxuICAgICAgc2FtZUtleSA9IChrZXlbb2Zmc2V0XSA9PT0gdGhpcy5rZXlbb2Zmc2V0XSk7XHJcbiAgICAgIG9mZnNldCsrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzYW1lS2V5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIGxldCBrZXlTaXplID0gdGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZT0nICsga2V5U2l6ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGtzUm93cyA9IHRoaXMua3NSb3dzID0gKGtleVNpemUgKyA2ICsgMSkgKiA0O1xyXG4gICAgbGV0IGtzUm93O1xyXG4gICAgbGV0IGludktzUm93O1xyXG5cclxuICAgIGxldCBrZXlTY2hlZHVsZSA9IHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcclxuICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcclxuICAgIGxldCBzYm94ID0gdGhpcy5zQm94O1xyXG4gICAgbGV0IHJjb24gPSB0aGlzLnJjb247XHJcblxyXG4gICAgbGV0IGludlN1Yk1peCAgPSB0aGlzLmludlN1Yk1peDtcclxuICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xyXG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XHJcbiAgICBsZXQgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcclxuICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xyXG5cclxuICAgIGxldCBwcmV2O1xyXG4gICAgbGV0IHQ7XHJcblxyXG4gICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XHJcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcclxuICAgICAgICBwcmV2ID0ga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5W2tzUm93XTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICB0ID0gcHJldjtcclxuXHJcbiAgICAgIGlmIChrc1JvdyAlIGtleVNpemUgPT09IDApIHtcclxuICAgICAgICAvLyBSb3Qgd29yZFxyXG4gICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XHJcblxyXG4gICAgICAgIC8vIFN1YiB3b3JkXHJcbiAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcclxuXHJcbiAgICAgICAgLy8gTWl4IFJjb25cclxuICAgICAgICB0IF49IHJjb25bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcclxuICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQpICB7XHJcbiAgICAgICAgLy8gU3ViIHdvcmRcclxuICAgICAgICB0ID0gKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94Wyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbdCAmIDB4ZmZdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBwcmV2ID0gKGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KSA+Pj4gMDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcclxuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcclxuICAgICAgaWYgKGludktzUm93ICYgMykge1xyXG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xyXG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXiBpbnZTdWJNaXgxW3Nib3hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFsodCA+Pj4gOCkgJiAweGZmXV0gXiBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cclxuICBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHdvcmQpIHtcclxuICAgIHJldHVybiAod29yZCA8PCAyNCkgfCAoKHdvcmQgJiAweGZmMDApIDw8IDgpIHwgKCh3b3JkICYgMHhmZjAwMDApID4+IDgpIHwgKHdvcmQgPj4+IDI0KTtcclxuICB9XHJcblxyXG4gIGRlY3J5cHQoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJVikge1xyXG4gICAgbGV0IG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xyXG4gICAgbGV0IGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZTtcclxuICAgIGxldCBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xyXG5cclxuICAgIGxldCBpbnZTdWJNaXggID0gdGhpcy5pbnZTdWJNaXg7XHJcbiAgICBsZXQgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcclxuICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xyXG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XHJcbiAgICBsZXQgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcclxuXHJcbiAgICBsZXQgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcclxuICAgIGxldCBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XHJcbiAgICBsZXQgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xyXG4gICAgbGV0IGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcclxuICAgIGxldCBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XHJcblxyXG4gICAgbGV0IGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcclxuICAgIGxldCBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcclxuXHJcbiAgICBsZXQgdDAsIHQxLCB0MiwgdDM7XHJcbiAgICBsZXQgczAsIHMxLCBzMiwgczM7XHJcbiAgICBsZXQgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XHJcblxyXG4gICAgdmFyIGtzUm93LCBpO1xyXG4gICAgbGV0IHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xyXG5cclxuICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dEludDMyLmxlbmd0aCkge1xyXG4gICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XHJcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XHJcbiAgICAgIGlucHV0V29yZHMyID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAyXSk7XHJcbiAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XHJcblxyXG4gICAgICBzMCA9IGlucHV0V29yZHMwIF4gaW52S2V5U2NoZWR1bGVbMF07XHJcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcclxuICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xyXG4gICAgICBzMyA9IGlucHV0V29yZHMxIF4gaW52S2V5U2NoZWR1bGVbM107XHJcblxyXG4gICAgICBrc1JvdyA9IDQ7XHJcblxyXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXHJcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcclxuICAgICAgICB0MCA9IGludlN1Yk1peDBbczAgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMxID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczIgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcclxuICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMyID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczMgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XHJcbiAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMyA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMwID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xyXG4gICAgICAgIHQzID0gaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczAgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMSA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcclxuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcclxuICAgICAgICBzMCA9IHQwO1xyXG4gICAgICAgIHMxID0gdDE7XHJcbiAgICAgICAgczIgPSB0MjtcclxuICAgICAgICBzMyA9IHQzO1xyXG5cclxuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XHJcbiAgICAgIHQwID0gKChpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMxID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMiA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMyAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcclxuICAgICAgdDEgPSAoKGludlNCT1hbczEgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczIgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMzID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MwICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcclxuICAgICAgdDIgPSAoKGludlNCT1hbczIgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczMgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMwID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MxICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcclxuICAgICAgdDMgPSAoKGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczAgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMxID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MyICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcclxuICAgICAga3NSb3cgPSBrc1JvdyArIDM7XHJcblxyXG4gICAgICAvLyBXcml0ZVxyXG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXRdID0gc3dhcFdvcmQodDAgXiBpbml0VmVjdG9yMCk7XHJcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XHJcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XHJcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDNdID0gc3dhcFdvcmQodDEgXiBpbml0VmVjdG9yMyk7XHJcblxyXG4gICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcclxuICAgICAgaW5pdFZlY3RvcjAgPSBpbnB1dFdvcmRzMDtcclxuICAgICAgaW5pdFZlY3RvcjEgPSBpbnB1dFdvcmRzMTtcclxuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcclxuICAgICAgaW5pdFZlY3RvcjMgPSBpbnB1dFdvcmRzMztcclxuXHJcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dEludDMyLmJ1ZmZlcjtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMua2V5U2l6ZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMua3NSb3dzID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMuc0JveCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaW52U0JveCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuc3ViTWl4ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5pbnZTdWJNaXggPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmtleVNjaGVkdWxlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB0aGlzLnJjb24gPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBRVNEZWNyeXB0b3I7XHJcbiIsImltcG9ydCBBRVNDcnlwdG8gZnJvbSAnLi9hZXMtY3J5cHRvJztcclxuaW1wb3J0IEZhc3RBRVNLZXkgZnJvbSAnLi9mYXN0LWFlcy1rZXknO1xyXG5pbXBvcnQgQUVTRGVjcnlwdG9yIGZyb20gJy4vYWVzLWRlY3J5cHRvcic7XHJcblxyXG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG4vKmdsb2JhbHMgc2VsZjogZmFsc2UgKi9cclxuXHJcbmNsYXNzIERlY3J5cHRlciB7XHJcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsY29uZmlnKSB7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBicm93c2VyQ3J5cHRvID0gY3J5cHRvID8gY3J5cHRvIDogc2VsZi5jcnlwdG87XHJcbiAgICAgIHRoaXMuc3VidGxlID0gYnJvd3NlckNyeXB0by5zdWJ0bGUgfHwgYnJvd3NlckNyeXB0by53ZWJraXRTdWJ0bGU7XHJcbiAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gIXRoaXMuc3VidGxlO1xyXG4gIH1cclxuXHJcbiAgaXNTeW5jKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmRpc2FibGVXZWJDcnlwdG8gJiYgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpO1xyXG4gIH1cclxuXHJcbiAgZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xyXG4gICAgICBpZiAodGhpcy5sb2dFbmFibGVkKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSlMgQUVTIGRlY3J5cHQnKTtcclxuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XHJcbiAgICAgIGlmICghZGVjcnlwdG9yKSB7XHJcbiAgICAgICAgdGhpcy5kZWNyeXB0b3IgPSBkZWNyeXB0b3IgPSBuZXcgQUVTRGVjcnlwdG9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgZGVjcnlwdG9yLmV4cGFuZEtleShrZXkpO1xyXG4gICAgICBjYWxsYmFjayhkZWNyeXB0b3IuZGVjcnlwdChkYXRhLCAwLCBpdikpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZWQpIHtcclxuICAgICAgICBsb2dnZXIubG9nKCdXZWJDcnlwdG8gQUVTIGRlY3J5cHQnKTtcclxuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzdWJ0bGUgPSB0aGlzLnN1YnRsZTtcclxuICAgICAgaWYgKHRoaXMua2V5ICE9PSBrZXkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleShzdWJ0bGUsa2V5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5mYXN0QWVzS2V5LmV4cGFuZEtleSgpLlxyXG4gICAgICAgIHRoZW4oKGFlc0tleSkgPT4ge1xyXG4gICAgICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXHJcbiAgICAgICAgICBsZXQgY3J5cHRvID0gbmV3IEFFU0NyeXB0byhzdWJ0bGUsaXYpO1xyXG4gICAgICAgICAgY3J5cHRvLmRlY3J5cHQoZGF0YSwgYWVzS2V5KS5cclxuICAgICAgICAgIGNhdGNoICgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcclxuICAgICAgICAgIH0pLlxyXG4gICAgICAgICAgdGhlbigocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5cclxuICAgICAgICBjYXRjaCAoKGVycikgPT4ge1xyXG4gICAgICAgICAgdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEknKTtcclxuICAgICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gdHJ1ZTtcclxuICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5kZWNyeXB0KGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoYGRlY3J5cHRpbmcgZXJyb3IgOiAke2Vyci5tZXNzYWdlfWApO1xyXG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlscyA6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsIGZhdGFsIDogdHJ1ZSwgcmVhc29uIDogZXJyLm1lc3NhZ2V9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBsZXQgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XHJcbiAgICBpZiAoZGVjcnlwdG9yKSB7XHJcbiAgICAgIGRlY3J5cHRvci5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMuZGVjcnlwdG9yID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGVjcnlwdGVyO1xyXG4iLCJjbGFzcyBGYXN0QUVTS2V5IHtcclxuICBjb25zdHJ1Y3RvcihzdWJ0bGUsa2V5KSB7XHJcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcclxuICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gIH1cclxuXHJcbiAgZXhwYW5kS2V5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmltcG9ydEtleSgncmF3JywgdGhpcy5rZXksIHtuYW1lOiAnQUVTLUNCQyd9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGYXN0QUVTS2V5O1xyXG4iLCIvKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cbmltcG9ydCBBRFRTIGZyb20gJy4vYWR0cyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcblxuIGNsYXNzIEFBQ0RlbXV4ZXIge1xuXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsYXVkaW9Db2RlYyx2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7Y29udGFpbmVyIDogJ2F1ZGlvL2FkdHMnLCB0eXBlOiAnYXVkaW8nLCBpZCA6LTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBpc0FBQyA6IHRydWUgLCBzYW1wbGVzIDogW10sIGxlbiA6IDAsIG1hbmlmZXN0Q29kZWMgOiBhdWRpb0NvZGVjLCBkdXJhdGlvbiA6IGR1cmF0aW9uLCBpbnB1dFRpbWVTY2FsZSA6IDkwMDAwfTtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wKCkge1xuICB9XG5cbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIEFEVFMgc3luYyB3b3JkXG4gICAgdmFyIGlkMyA9IG5ldyBJRDMoZGF0YSksIG9mZnNldCwgbGVuZ3RoO1xuICAgIHZhciBpZDNUYWcgPSBpZDMuZ2V0VGFnRGF0YShkYXRhLCAwKTtcbiAgICBpZihpZDNUYWcpIHtcbiAgICAgIHZhciB0aW1lU3RhbXAgPSBpZDMuZ2V0VGltZVN0YW1wKGlkM1RhZyk7XG4gICAgfVxuICAgIGlmKGlkMy5oYXNUaW1lU3RhbXApIHtcbiAgICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gICAgICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgICAgIGZvciAob2Zmc2V0ID0gaWQzLmxlbmd0aCwgbGVuZ3RoID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSAxLCBvZmZzZXQgKyAxMDApOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoZGF0YVtvZmZzZXQrMV0gJiAweGY2KSA9PT0gMHhmMCkge1xuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnQURUUyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBhcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICB2YXIgdHJhY2ssXG4gICAgICAgIGlkMyA9IG5ldyBJRDMoZGF0YSksXG4gICAgICAgIHB0cyA9IDkwKmlkMy50aW1lU3RhbXAsXG4gICAgICAgIGNvbmZpZywgZnJhbWVMZW5ndGgsIGZyYW1lRHVyYXRpb24sIGZyYW1lSW5kZXgsIG9mZnNldCwgaGVhZGVyTGVuZ3RoLCBzdGFtcCwgbGVuZ3RoLCBhYWNTYW1wbGU7XG5cbiAgICB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG5cbiAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlclxuICAgIGZvciAob2Zmc2V0ID0gaWQzLmxlbmd0aCwgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aCAtIDE7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKGRhdGFbb2Zmc2V0KzFdICYgMHhmNikgPT09IDB4ZjApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICBjb25maWcgPSBBRFRTLmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsZGF0YSwgb2Zmc2V0LCB0cmFjay5tYW5pZmVzdENvZGVjKTtcbiAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgY29kZWM6JHt0cmFjay5jb2RlY30scmF0ZToke2NvbmZpZy5zYW1wbGVyYXRlfSxuYiBjaGFubmVsOiR7Y29uZmlnLmNoYW5uZWxDb3VudH1gKTtcbiAgICB9XG4gICAgZnJhbWVJbmRleCA9IDA7XG4gICAgZnJhbWVEdXJhdGlvbiA9IDEwMjQgKiA5MDAwMCAvIHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgd2hpbGUgKChvZmZzZXQgKyA1KSA8IGxlbmd0aCkge1xuICAgICAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gICAgICBoZWFkZXJMZW5ndGggPSAoISEoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEpID8gNyA6IDkpO1xuICAgICAgLy8gcmV0cmlldmUgZnJhbWUgc2l6ZVxuICAgICAgZnJhbWVMZW5ndGggPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxuICAgICAgICAgICAgICAgICAgICAgKGRhdGFbb2Zmc2V0ICsgNF0gPDwgMykgfFxuICAgICAgICAgICAgICAgICAgICAoKGRhdGFbb2Zmc2V0ICsgNV0gJiAweEUwKSA+Pj4gNSk7XG4gICAgICBmcmFtZUxlbmd0aCAgLT0gaGVhZGVyTGVuZ3RoO1xuICAgICAgLy9zdGFtcCA9IHBlcy5wdHM7XG5cbiAgICAgIGlmICgoZnJhbWVMZW5ndGggPiAwKSAmJiAoKG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSA8PSBsZW5ndGgpKSB7XG4gICAgICAgIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICAgICAgYWFjU2FtcGxlID0ge3VuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCksIHB0czogc3RhbXAsIGR0czogc3RhbXB9O1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjU2FtcGxlKTtcbiAgICAgICAgdHJhY2subGVuICs9IGZyYW1lTGVuZ3RoO1xuICAgICAgICBvZmZzZXQgKz0gZnJhbWVMZW5ndGggKyBoZWFkZXJMZW5ndGg7XG4gICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICAgICAgZm9yICggOyBvZmZzZXQgPCAobGVuZ3RoIC0gMSk7IG9mZnNldCsrKSB7XG4gICAgICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmICgoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjYpID09PSAweGYwKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KHRyYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAge3NhbXBsZXMgOiBbXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7c2FtcGxlcyA6IFsgeyBwdHM6IHB0cywgZHRzIDogcHRzLCBkYXRhIDogaWQzLnBheWxvYWR9XSwgaW5wdXRUaW1lU2NhbGUgOiA5MDAwMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7c2FtcGxlcyA6IFtdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aWd1b3VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUNEZW11eGVyO1xuIiwiLyoqXHJcbiAqICBBRFRTIHBhcnNlciBoZWxwZXJcclxuICovXHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcclxuXHJcbiBjb25zdCBBRFRTID0ge1xyXG4gIGdldEF1ZGlvQ29uZmlnIDogZnVuY3Rpb24ob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xyXG4gICAgdmFyIGFkdHNPYmplY3RUeXBlLCAvLyA6aW50XHJcbiAgICAgICAgYWR0c1NhbXBsZWluZ0luZGV4LCAvLyA6aW50XHJcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4LCAvLyA6aW50XHJcbiAgICAgICAgYWR0c0NoYW5lbENvbmZpZywgLy8gOmludFxyXG4gICAgICAgIGNvbmZpZyxcclxuICAgICAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgbWFuaWZlc3RDb2RlYyA9IGF1ZGlvQ29kZWMsXHJcbiAgICAgICAgYWR0c1NhbXBsZWluZ1JhdGVzID0gW1xyXG4gICAgICAgICAgICA5NjAwMCwgODgyMDAsXHJcbiAgICAgICAgICAgIDY0MDAwLCA0ODAwMCxcclxuICAgICAgICAgICAgNDQxMDAsIDMyMDAwLFxyXG4gICAgICAgICAgICAyNDAwMCwgMjIwNTAsXHJcbiAgICAgICAgICAgIDE2MDAwLCAxMjAwMCxcclxuICAgICAgICAgICAgMTEwMjUsIDgwMDAsXHJcbiAgICAgICAgICAgIDczNTBdO1xyXG4gICAgLy8gYnl0ZSAyXHJcbiAgICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4QzApID4+PiA2KSArIDE7XHJcbiAgICBhZHRzU2FtcGxlaW5nSW5kZXggPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNDKSA+Pj4gMik7XHJcbiAgICBpZihhZHRzU2FtcGxlaW5nSW5kZXggPiBhZHRzU2FtcGxlaW5nUmF0ZXMubGVuZ3RoLTEpIHtcclxuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246IGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxlaW5nSW5kZXh9YH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBhZHRzQ2hhbmVsQ29uZmlnID0gKChkYXRhW29mZnNldCArIDJdICYgMHgwMSkgPDwgMik7XHJcbiAgICAvLyBieXRlIDNcclxuICAgIGFkdHNDaGFuZWxDb25maWcgfD0gKChkYXRhW29mZnNldCArIDNdICYgMHhDMCkgPj4+IDYpO1xyXG4gICAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgY29kZWM6JHthdWRpb0NvZGVjfSxBRFRTIGRhdGE6dHlwZToke2FkdHNPYmplY3RUeXBlfSxzYW1wbGVpbmdJbmRleDoke2FkdHNTYW1wbGVpbmdJbmRleH1bJHthZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XX1Iel0sY2hhbm5lbENvbmZpZzoke2FkdHNDaGFuZWxDb25maWd9YCk7XHJcbiAgICAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcclxuICAgIGlmICgvZmlyZWZveC9pLnRlc3QodXNlckFnZW50KSkge1xyXG4gICAgICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpIHtcclxuICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XHJcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xyXG4gICAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xyXG4gICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXHJcbiAgICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcclxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXggLSAzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcclxuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XHJcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEFuZHJvaWQgOiBhbHdheXMgdXNlIEFBQ1xyXG4gICAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xyXG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XHJcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcclxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLyogIGZvciBvdGhlciBicm93c2VycyAoQ2hyb21lL1ZpdmFsZGkvT3BlcmEgLi4uKVxyXG4gICAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcclxuICAgICAgKi9cclxuICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xyXG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBIRS1BQUMgb3IgSEUtQUFDdjIpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIEFORCBmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6KVxyXG4gICAgICBpZiAoKGF1ZGlvQ29kZWMgJiYgKChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMjknKSAhPT0gLTEpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkpIHx8XHJcbiAgICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpKSB7XHJcbiAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXHJcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcclxuICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxyXG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEFBQykgQU5EIChmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6IEFORCBuYiBjaGFubmVsIGlzIDEpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIGFuZCBtb25vIGF1ZGlvKVxyXG4gICAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXHJcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEgJiYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHx8XHJcbiAgICAgICAgICAgICghYXVkaW9Db2RlYyAmJiBhZHRzQ2hhbmVsQ29uZmlnID09PSAxKSkge1xyXG4gICAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xyXG4gICAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcclxuICAgICAgICBJU08gMTQ0OTYtMyAoQUFDKS5wZGYgLSBUYWJsZSAxLjEzIOKAlCBTeW50YXggb2YgQXVkaW9TcGVjaWZpY0NvbmZpZygpXHJcbiAgICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxyXG4gICAgICAwOiBOdWxsXHJcbiAgICAgIDE6IEFBQyBNYWluXHJcbiAgICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXHJcbiAgICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxyXG4gICAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcclxuICAgICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxyXG4gICAgICA2OiBBQUMgU2NhbGFibGVcclxuICAgICBzYW1wbGluZyBmcmVxXHJcbiAgICAgIDA6IDk2MDAwIEh6XHJcbiAgICAgIDE6IDg4MjAwIEh6XHJcbiAgICAgIDI6IDY0MDAwIEh6XHJcbiAgICAgIDM6IDQ4MDAwIEh6XHJcbiAgICAgIDQ6IDQ0MTAwIEh6XHJcbiAgICAgIDU6IDMyMDAwIEh6XHJcbiAgICAgIDY6IDI0MDAwIEh6XHJcbiAgICAgIDc6IDIyMDUwIEh6XHJcbiAgICAgIDg6IDE2MDAwIEh6XHJcbiAgICAgIDk6IDEyMDAwIEh6XHJcbiAgICAgIDEwOiAxMTAyNSBIelxyXG4gICAgICAxMTogODAwMCBIelxyXG4gICAgICAxMjogNzM1MCBIelxyXG4gICAgICAxMzogUmVzZXJ2ZWRcclxuICAgICAgMTQ6IFJlc2VydmVkXHJcbiAgICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcclxuICAgICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xyXG4gICAgICBUaGVzZSBhcmUgdGhlIGNoYW5uZWwgY29uZmlndXJhdGlvbnM6XHJcbiAgICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXHJcbiAgICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXHJcbiAgICAgIDI6IDIgY2hhbm5lbHM6IGZyb250LWxlZnQsIGZyb250LXJpZ2h0XHJcbiAgICAqL1xyXG4gICAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcclxuICAgIGNvbmZpZ1swXSA9IGFkdHNPYmplY3RUeXBlIDw8IDM7XHJcbiAgICAvLyBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4XHJcbiAgICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XHJcbiAgICBjb25maWdbMV0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XHJcbiAgICAvLyBjaGFubmVsQ29uZmlndXJhdGlvblxyXG4gICAgY29uZmlnWzFdIHw9IGFkdHNDaGFuZWxDb25maWcgPDwgMztcclxuICAgIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSkge1xyXG4gICAgICAvLyBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXhcclxuICAgICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xyXG4gICAgICBjb25maWdbMl0gPSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcclxuICAgICAgLy8gYWR0c09iamVjdFR5cGUgKGZvcmNlIHRvIDIsIGNocm9tZSBpcyBjaGVja2luZyB0aGF0IG9iamVjdCB0eXBlIGlzIGxlc3MgdGhhbiA1ID8/P1xyXG4gICAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcclxuICAgICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcclxuICAgICAgY29uZmlnWzNdID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiB7Y29uZmlnOiBjb25maWcsIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdLCBjaGFubmVsQ291bnQ6IGFkdHNDaGFuZWxDb25maWcsIGNvZGVjOiAoJ21wNGEuNDAuJyArIGFkdHNPYmplY3RUeXBlKSwgbWFuaWZlc3RDb2RlYyA6IG1hbmlmZXN0Q29kZWN9O1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQURUUztcclxuIiwiLyogIGlubGluZSBkZW11eGVyLlxyXG4gKiAgIHByb2JlIGZyYWdtZW50cyBhbmQgaW5zdGFudGlhdGUgYXBwcm9wcmlhdGUgZGVtdXhlciBkZXBlbmRpbmcgb24gY29udGVudCB0eXBlIChUU0RlbXV4ZXIsIEFBQ0RlbXV4ZXIsIC4uLilcclxuICovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcclxuaW1wb3J0IEFBQ0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvYWFjZGVtdXhlcic7XHJcbmltcG9ydCBNUDREZW11eGVyIGZyb20gJy4uL2RlbXV4L21wNGRlbXV4ZXInO1xyXG5pbXBvcnQgVFNEZW11eGVyIGZyb20gJy4uL2RlbXV4L3RzZGVtdXhlcic7XHJcbmltcG9ydCBNUDNEZW11eGVyIGZyb20gJy4uL2RlbXV4L21wM2RlbXV4ZXInO1xyXG5pbXBvcnQgTVA0UmVtdXhlciBmcm9tICcuLi9yZW11eC9tcDQtcmVtdXhlcic7XHJcbmltcG9ydCBQYXNzVGhyb3VnaFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlcic7XHJcblxyXG5jbGFzcyBEZW11eGVySW5saW5lIHtcclxuXHJcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xyXG4gICAgaWYgKGRlbXV4ZXIpIHtcclxuICAgICAgZGVtdXhlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XHJcbiAgICBpZiAoKGRhdGEuYnl0ZUxlbmd0aCA+IDApICYmIChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcclxuICAgICAgbGV0IGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyO1xyXG4gICAgICBpZiAoZGVjcnlwdGVyID09IG51bGwpIHtcclxuICAgICAgICBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xyXG4gICAgICAvLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcclxuICAgICAgdmFyIHN0YXJ0VGltZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgfSBjYXRjaChlcnJvcikge1xyXG4gICAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIH1cclxuICAgICAgZGVjcnlwdGVyLmRlY3J5cHQoZGF0YSwgZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdGRhdGEuaXYuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xyXG4gICAgICAgIHZhciBlbmRUaW1lO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgfSBjYXRjaChlcnJvcikge1xyXG4gICAgICAgICAgZW5kVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvY2FsdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfREVDUllQVEVELCB7IHN0YXRzOiB7IHRzdGFydDogc3RhcnRUaW1lLCB0ZGVjcnlwdDogZW5kVGltZSB9IH0pO1xyXG4gICAgICAgIGxvY2FsdGhpcy5wdXNoRGVjcnlwdGVkKG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpLCBkZWNyeXB0ZGF0YSwgbmV3IFVpbnQ4QXJyYXkoaW5pdFNlZ21lbnQpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCxkZWZhdWx0SW5pdFBUUyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wdXNoRGVjcnlwdGVkKG5ldyBVaW50OEFycmF5KGRhdGEpLCBkZWNyeXB0ZGF0YSwgbmV3IFVpbnQ4QXJyYXkoaW5pdFNlZ21lbnQpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1c2hEZWNyeXB0ZWQoZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKSB7XHJcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcclxuICAgIGlmICghZGVtdXhlciB8fMKgXHJcbiAgICAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyIGZvciBleGFtcGxlKVxyXG4gICAgICAgLy8gc28gbGV0J3MgY2hlY2sgdGhhdCBjdXJyZW50IGRlbXV4ZXIgaXMgc3RpbGwgdmFsaWRcclxuICAgICAgICAoZGlzY29udGludWl0eSAmJiAhdGhpcy5wcm9iZShkYXRhKSkpIHtcclxuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xyXG4gICAgICBjb25zdCB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkO1xyXG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgICAgY29uc3QgbXV4Q29uZmlnID0gWyB7ZGVtdXggOiBUU0RlbXV4ZXIsICByZW11eCA6IE1QNFJlbXV4ZXJ9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtkZW11eCA6IE1QM0RlbXV4ZXIsIHJlbXV4IDogTVA0UmVtdXhlcn0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAge2RlbXV4IDogQUFDRGVtdXhlciwgcmVtdXggOiBNUDRSZW11eGVyfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB7ZGVtdXggOiBNUDREZW11eGVyLCByZW11eCA6IFBhc3NUaHJvdWdoUmVtdXhlcn1dO1xyXG5cclxuICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxyXG4gICAgICBmb3IgKGxldCBpIGluIG11eENvbmZpZykge1xyXG4gICAgICAgIGNvbnN0IG11eCA9IG11eENvbmZpZ1tpXTtcclxuICAgICAgICBjb25zdCBwcm9iZSA9IG11eC5kZW11eC5wcm9iZTtcclxuICAgICAgICBpZihwcm9iZShkYXRhKSkge1xyXG4gICAgICAgICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlciA9IG5ldyBtdXgucmVtdXgob2JzZXJ2ZXIsY29uZmlnLHR5cGVTdXBwb3J0ZWQsIHRoaXMudmVuZG9yKTtcclxuICAgICAgICAgIGRlbXV4ZXIgPSBuZXcgbXV4LmRlbXV4KG9ic2VydmVyLHJlbXV4ZXIsY29uZmlnLHR5cGVTdXBwb3J0ZWQpO1xyXG4gICAgICAgICAgdGhpcy5wcm9iZSA9IHByb2JlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmKCFkZW11eGVyKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiAnbm8gZGVtdXggbWF0Y2hpbmcgd2l0aCBjb250ZW50IGZvdW5kJ30pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRlbXV4ZXIgPSBkZW11eGVyO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcclxuXHJcbiAgICBpZiAoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCkge1xyXG4gICAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsYXVkaW9Db2RlYyx2aWRlb0NvZGVjLGR1cmF0aW9uKTtcclxuICAgICAgcmVtdXhlci5yZXNldEluaXRTZWdtZW50KCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlzY29udGludWl0eSkge1xyXG4gICAgICBkZW11eGVyLnJlc2V0VGltZVN0YW1wKCk7XHJcbiAgICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBkZW11eGVyLnNldERlY3J5cHREYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGRlbXV4ZXIuc2V0RGVjcnlwdERhdGEoZGVjcnlwdGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZGVtdXhlci5hcHBlbmQoZGF0YSx0aW1lT2Zmc2V0LGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXJJbmxpbmU7XHJcbiIsIi8qIGRlbXV4ZXIgd2ViIHdvcmtlci5cclxuICogIC0gbGlzdGVuIHRvIHdvcmtlciBtZXNzYWdlLCBhbmQgdHJpZ2dlciBEZW11eGVySW5saW5lIHVwb24gcmVjZXB0aW9uIG9mIEZyYWdtZW50cy5cclxuICogIC0gcHJvdmlkZXMgTVA0IEJveGVzIGJhY2sgdG8gbWFpbiB0aHJlYWQgdXNpbmcgW3RyYW5zZmVyYWJsZSBvYmplY3RzXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDExLzEyL1RyYW5zZmVyYWJsZS1PYmplY3RzLUxpZ2h0bmluZy1GYXN0KSBpbiBvcmRlciB0byBtaW5pbWl6ZSBtZXNzYWdlIHBhc3Npbmcgb3ZlcmhlYWQuXHJcbiAqL1xyXG5cclxuIGltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcclxuIGltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG4gaW1wb3J0IHtlbmFibGVMb2dzfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG4gaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xyXG5cclxudmFyIERlbXV4ZXJXb3JrZXIgPSBmdW5jdGlvbiAoc2VsZikge1xyXG4gIC8vIG9ic2VydmVyIHNldHVwXHJcbiAgdmFyIG9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xyXG4gICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xyXG4gIH07XHJcblxyXG4gIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIC4uLmRhdGEpIHtcclxuICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcclxuICB9O1xyXG5cclxuICB2YXIgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbihldixkYXRhKSB7XHJcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtldmVudDogZXYsIGRhdGE6ZGF0YSB9KTtcclxuICB9O1xyXG5cclxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgIHZhciBkYXRhID0gZXYuZGF0YTtcclxuICAgIC8vY29uc29sZS5sb2coJ2RlbXV4ZXIgY21kOicgKyBkYXRhLmNtZCk7XHJcbiAgICBzd2l0Y2ggKGRhdGEuY21kKSB7XHJcbiAgICAgIGNhc2UgJ2luaXQnOlxyXG4gICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEuY29uZmlnKTtcclxuICAgICAgICBzZWxmLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlciwgZGF0YS50eXBlU3VwcG9ydGVkLCBjb25maWcsIGRhdGEudmVuZG9yKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZW5hYmxlTG9ncyhjb25maWcuZGVidWcgPT09IHRydWUpO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2RlbXV4ZXJXb3JrZXI6IHVuYWJsZSB0byBlbmFibGUgbG9ncycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzaWduYWwgZW5kIG9mIHdvcmtlciBpbml0XHJcbiAgICAgICAgZm9yd2FyZE1lc3NhZ2UoJ2luaXQnLG51bGwpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdkZW11eCc6XHJcbiAgICAgICAgc2VsZi5kZW11eGVyLnB1c2goZGF0YS5kYXRhLCBkYXRhLmRlY3J5cHRkYXRhLCBkYXRhLmluaXRTZWdtZW50LCBkYXRhLmF1ZGlvQ29kZWMsIGRhdGEudmlkZW9Db2RlYywgZGF0YS50aW1lT2Zmc2V0LGRhdGEuZGlzY29udGludWl0eSwgZGF0YS50cmFja1N3aXRjaCxkYXRhLmNvbnRpZ3VvdXMsZGF0YS5kdXJhdGlvbixkYXRhLmFjY3VyYXRlVGltZU9mZnNldCxkYXRhLmRlZmF1bHRJbml0UFRTKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcclxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcclxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNFRCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gIG9ic2VydmVyLm9uKEV2ZW50LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgb2JzZXJ2ZXIub24oRXZlbnQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcclxuXHJcbiAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogcGFzcyBkYXRhMS9kYXRhMiBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0IChubyBjb3B5KVxyXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBmdW5jdGlvbihldiwgZGF0YSkge1xyXG4gICAgbGV0IHRyYW5zZmVyYWJsZSA9IFtdO1xyXG4gICAgbGV0IG1lc3NhZ2UgPSB7ZXZlbnQ6IGV2LCBkYXRhOmRhdGF9O1xyXG4gICAgaWYgKGRhdGEuZGF0YTEpIHtcclxuICAgICAgbWVzc2FnZS5kYXRhMSA9IGRhdGEuZGF0YTEuYnVmZmVyO1xyXG4gICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGExLmJ1ZmZlcik7XHJcbiAgICAgIGRlbGV0ZSBkYXRhLmRhdGExO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEuZGF0YTIpIHtcclxuICAgICAgbWVzc2FnZS5kYXRhMiA9IGRhdGEuZGF0YTIuYnVmZmVyO1xyXG4gICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGEyLmJ1ZmZlcik7XHJcbiAgICAgIGRlbGV0ZSBkYXRhLmRhdGEyO1xyXG4gICAgfVxyXG4gICAgc2VsZi5wb3N0TWVzc2FnZShtZXNzYWdlLHRyYW5zZmVyYWJsZSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyV29ya2VyO1xyXG5cclxuIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcclxuaW1wb3J0IERlbXV4ZXJXb3JrZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlci13b3JrZXInO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcclxuXHJcbmNsYXNzIERlbXV4ZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMsIGlkKSB7XHJcbiAgICB0aGlzLmhscyA9IGhscztcclxuICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIC8vIG9ic2VydmVyIHNldHVwXHJcbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xyXG4gICAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2ZW50LCAuLi5kYXRhKSB7XHJcbiAgICAgIG9ic2VydmVyLmVtaXQoZXZlbnQsIGV2ZW50LCAuLi5kYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgb2JzZXJ2ZXIub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudCwgLi4uZGF0YSkge1xyXG4gICAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgLi4uZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uKGV2LGRhdGEpIHtcclxuICAgICAgZGF0YSA9IGRhdGEgfHwge307XHJcbiAgICAgIGRhdGEuZnJhZyA9IHRoaXMuZnJhZztcclxuICAgICAgZGF0YS5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgIGhscy50cmlnZ2VyKGV2LGRhdGEpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXHJcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZvcndhcmRNZXNzYWdlKTtcclxuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgICBvYnNlcnZlci5vbihFdmVudC5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcclxuICAgIG9ic2VydmVyLm9uKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCBmb3J3YXJkTWVzc2FnZSk7XHJcblxyXG4gICAgY29uc3QgdHlwZVN1cHBvcnRlZCA9IHtcclxuICAgICAgbXA0IDogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQnKSxcclxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXHJcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJylcclxuICAgIH07XHJcbiAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcclxuICAgIC8vIHJlZmVyIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Xb3JrZXJHbG9iYWxTY29wZS9uYXZpZ2F0b3JcclxuICAgIGNvbnN0IHZlbmRvciA9IG5hdmlnYXRvci52ZW5kb3I7XHJcbiAgICBpZiAoY29uZmlnLmVuYWJsZVdvcmtlciAmJiAodHlwZW9mKFdvcmtlcikgIT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ2RlbXV4aW5nIGluIHdlYndvcmtlcicpO1xyXG4gICAgICAgIGxldCB3O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsZXQgd29yayA9IHJlcXVpcmUoJ3dlYndvcmtpZnknKTtcclxuICAgICAgICAgIHcgPSB0aGlzLncgPSB3b3JrKERlbXV4ZXJXb3JrZXIpO1xyXG4gICAgICAgICAgdGhpcy5vbndtc2cgPSB0aGlzLm9uV29ya2VyTWVzc2FnZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xyXG4gICAgICAgICAgdy5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHsgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogdHJ1ZSwgZXZlbnQgOiAnZGVtdXhlcldvcmtlcicsIGVyciA6IHsgbWVzc2FnZSA6IGV2ZW50Lm1lc3NhZ2UgKyAnICgnICsgZXZlbnQuZmlsZW5hbWUgKyAnOicgKyBldmVudC5saW5lbm8gKyAnKScgfX0pO307XHJcbiAgICAgICAgICB3LnBvc3RNZXNzYWdlKHtjbWQ6ICdpbml0JywgdHlwZVN1cHBvcnRlZCA6IHR5cGVTdXBwb3J0ZWQsIHZlbmRvciA6IHZlbmRvciwgaWQgOiBpZCwgY29uZmlnOiBKU09OLnN0cmluZ2lmeShjb25maWcpfSk7XHJcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgIGxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIG9uIERlbXV4ZXJJbmxpbmUnKTtcclxuICAgICAgICAgIGlmICh3KSB7XHJcbiAgICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSBkZW11eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh3Lm9iamVjdFVSTCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlcix0eXBlU3VwcG9ydGVkLGNvbmZpZyx2ZW5kb3IpO1xyXG4gICAgICAgICAgdGhpcy53ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlcix0eXBlU3VwcG9ydGVkLGNvbmZpZywgdmVuZG9yKTtcclxuICAgICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGxldCB3ID0gdGhpcy53O1xyXG4gICAgaWYgKHcpIHtcclxuICAgICAgdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xyXG4gICAgICB3LnRlcm1pbmF0ZSgpO1xyXG4gICAgICB0aGlzLncgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XHJcbiAgICAgIGlmIChkZW11eGVyKSB7XHJcbiAgICAgICAgZGVtdXhlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcclxuICAgIGlmIChvYnNlcnZlcikge1xyXG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdXNoKGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBkdXJhdGlvbixhY2N1cmF0ZVRpbWVPZmZzZXQsZGVmYXVsdEluaXRQVFMpIHtcclxuICAgIGNvbnN0IHcgPSB0aGlzLnc7XHJcbiAgICBjb25zdCB0aW1lT2Zmc2V0ID0gIWlzTmFOKGZyYWcuc3RhcnREVFMpID8gZnJhZy5zdGFydERUUyAgOiBmcmFnLnN0YXJ0O1xyXG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xyXG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XHJcbiAgICBjb25zdCBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiAoZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpKTtcclxuICAgIGNvbnN0IHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiAoZnJhZy5sZXZlbCA9PT0gbGFzdEZyYWcubGV2ZWwpKTtcclxuICAgIGNvbnN0IG5leHRTTiA9IGxhc3RGcmFnICYmIChmcmFnLnNuID09PSAobGFzdEZyYWcuc24rMSkpO1xyXG4gICAgY29uc3QgY29udGlndW91cyA9ICF0cmFja1N3aXRjaCAmJiBuZXh0U047XHJcbiAgICBpZiAoZGlzY29udGludWl0eSkge1xyXG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OmRpc2NvbnRpbnVpdHkgZGV0ZWN0ZWRgKTtcclxuICAgIH1cclxuICAgIGlmICh0cmFja1N3aXRjaCkge1xyXG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OnN3aXRjaCBkZXRlY3RlZGApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5mcmFnID0gZnJhZztcclxuICAgIGlmICh3KSB7XHJcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyAobm8gY29weSlcclxuICAgICAgdy5wb3N0TWVzc2FnZSh7Y21kOiAnZGVtdXgnLCBkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTfSwgW2RhdGFdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xyXG4gICAgICBpZiAoZGVtdXhlcikge1xyXG4gICAgICAgIGRlbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25Xb3JrZXJNZXNzYWdlKGV2KSB7XHJcbiAgICBsZXQgZGF0YSA9IGV2LmRhdGEsXHJcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdvbldvcmtlck1lc3NhZ2U6JyArIGRhdGEuZXZlbnQpO1xyXG4gICAgc3dpdGNoKGRhdGEuZXZlbnQpIHtcclxuICAgICAgY2FzZSAnaW5pdCc6XHJcbiAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGRlbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxyXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53Lm9iamVjdFVSTCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IGRhdGExIGFuZCBkYXRhMiBhcmUgdHJhbnNmZXJhYmxlIG9iamVjdHNcclxuICAgICAgY2FzZSBFdmVudC5GUkFHX1BBUlNJTkdfREFUQTpcclxuICAgICAgICBkYXRhLmRhdGEuZGF0YTEgPSBuZXcgVWludDhBcnJheShkYXRhLmRhdGExKTtcclxuICAgICAgICBpZiAoZGF0YS5kYXRhMikge1xyXG4gICAgICAgICAgZGF0YS5kYXRhLmRhdGEyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XHJcbiAgICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XHJcbiAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcclxuICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcjtcclxuXHJcbiIsIi8qKlxyXG4gKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cclxuKi9cclxuXHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuY2xhc3MgRXhwR29sb21iIHtcclxuXHJcbiAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBleGFtaW5lIGluIHRoaXMuZGF0YVxyXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcclxuICAgIHRoaXMud29yZCA9IDA7IC8vIDp1aW50XHJcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcclxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XHJcbiAgfVxyXG5cclxuICAvLyAoKTp2b2lkXHJcbiAgbG9hZFdvcmQoKSB7XHJcbiAgICB2YXJcclxuICAgICAgZGF0YSA9IHRoaXMuZGF0YSxcclxuICAgICAgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlLFxyXG4gICAgICBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlLFxyXG4gICAgICB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSxcclxuICAgICAgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XHJcbiAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcclxuICAgIH1cclxuICAgIHdvcmtpbmdCeXRlcy5zZXQoZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xyXG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcclxuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXHJcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XHJcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xyXG4gIH1cclxuXHJcbiAgLy8gKGNvdW50OmludCk6dm9pZFxyXG4gIHNraXBCaXRzKGNvdW50KSB7XHJcbiAgICB2YXIgc2tpcEJ5dGVzOyAvLyA6aW50XHJcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcclxuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcclxuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xyXG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xyXG4gICAgICBjb3VudCAtPSAoc2tpcEJ5dGVzID4+IDMpO1xyXG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcclxuICAgICAgdGhpcy5sb2FkV29yZCgpO1xyXG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xyXG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyAoc2l6ZTppbnQpOnVpbnRcclxuICByZWFkQml0cyhzaXplKSB7XHJcbiAgICB2YXJcclxuICAgICAgYml0cyA9IE1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSwgc2l6ZSksIC8vIDp1aW50XHJcbiAgICAgIHZhbHUgPSB0aGlzLndvcmQgPj4+ICgzMiAtIGJpdHMpOyAvLyA6dWludFxyXG4gICAgaWYgKHNpemUgPiAzMikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XHJcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xyXG4gICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XHJcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcclxuICAgIH1cclxuICAgIGJpdHMgPSBzaXplIC0gYml0cztcclxuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcclxuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdmFsdTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vICgpOnVpbnRcclxuICBza2lwTFooKSB7XHJcbiAgICB2YXIgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcclxuICAgIGZvciAobGVhZGluZ1plcm9Db3VudCA9IDA7IGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xyXG4gICAgICBpZiAoMCAhPT0gKHRoaXMud29yZCAmICgweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSkpIHtcclxuICAgICAgICAvLyB0aGUgZmlyc3QgYml0IG9mIHdvcmtpbmcgd29yZCBpcyAxXHJcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xyXG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xyXG4gICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXHJcbiAgICB0aGlzLmxvYWRXb3JkKCk7XHJcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XHJcbiAgfVxyXG5cclxuICAvLyAoKTp2b2lkXHJcbiAgc2tpcFVFRygpIHtcclxuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xyXG4gIH1cclxuXHJcbiAgLy8gKCk6dm9pZFxyXG4gIHNraXBFRygpIHtcclxuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xyXG4gIH1cclxuXHJcbiAgLy8gKCk6dWludFxyXG4gIHJlYWRVRUcoKSB7XHJcbiAgICB2YXIgY2x6ID0gdGhpcy5za2lwTFooKTsgLy8gOnVpbnRcclxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcclxuICB9XHJcblxyXG4gIC8vICgpOmludFxyXG4gIHJlYWRFRygpIHtcclxuICAgIHZhciB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcclxuICAgIGlmICgweDAxICYgdmFsdSkge1xyXG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcclxuICAgICAgcmV0dXJuICgxICsgdmFsdSkgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xyXG4gIC8vIDpCb29sZWFuXHJcbiAgcmVhZEJvb2xlYW4oKSB7XHJcbiAgICByZXR1cm4gMSA9PT0gdGhpcy5yZWFkQml0cygxKTtcclxuICB9XHJcblxyXG4gIC8vICgpOmludFxyXG4gIHJlYWRVQnl0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xyXG4gIH1cclxuXHJcbiAgLy8gKCk6aW50XHJcbiAgcmVhZFVTaG9ydCgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcclxuICB9XHJcbiAgICAvLyAoKTppbnRcclxuICByZWFkVUludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXHJcbiAgICogbGlzdCBpcyBvcHRpb25hbGx5IHRyYW5zbWl0dGVkIGFzIHBhcnQgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXJcclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cclxuICAgKiBAcGFyYW0gY291bnQge251bWJlcn0gdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XHJcbiAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxyXG4gICAqL1xyXG4gIHNraXBTY2FsaW5nTGlzdChjb3VudCkge1xyXG4gICAgdmFyXHJcbiAgICAgIGxhc3RTY2FsZSA9IDgsXHJcbiAgICAgIG5leHRTY2FsZSA9IDgsXHJcbiAgICAgIGosXHJcbiAgICAgIGRlbHRhU2NhbGU7XHJcbiAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xyXG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XHJcbiAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMucmVhZEVHKCk7XHJcbiAgICAgICAgbmV4dFNjYWxlID0gKGxhc3RTY2FsZSArIGRlbHRhU2NhbGUgKyAyNTYpICUgMjU2O1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RTY2FsZSA9IChuZXh0U2NhbGUgPT09IDApID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXHJcbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcclxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxyXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxyXG4gICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcclxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cclxuICAgKi9cclxuICByZWFkU1BTKCkge1xyXG4gICAgdmFyXHJcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwLFxyXG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IDAsXHJcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IDAsXHJcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDAsXHJcbiAgICAgIHByb2ZpbGVJZGMscHJvZmlsZUNvbXBhdCxsZXZlbElkYyxcclxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlLCBwaWNXaWR0aEluTWJzTWludXMxLFxyXG4gICAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLFxyXG4gICAgICBmcmFtZU1ic09ubHlGbGFnLFxyXG4gICAgICBzY2FsaW5nTGlzdENvdW50LFxyXG4gICAgICBpLFxyXG4gICAgICByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpLFxyXG4gICAgICByZWFkQml0cyA9IHRoaXMucmVhZEJpdHMuYmluZCh0aGlzKSxcclxuICAgICAgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpLFxyXG4gICAgICByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKSxcclxuICAgICAgc2tpcEJpdHMgPSB0aGlzLnNraXBCaXRzLmJpbmQodGhpcyksXHJcbiAgICAgIHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyksXHJcbiAgICAgIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKSxcclxuICAgICAgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcclxuXHJcbiAgICByZWFkVUJ5dGUoKTtcclxuICAgIHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcclxuICAgIHByb2ZpbGVDb21wYXQgPSByZWFkQml0cyg1KTsgLy8gY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXHJcbiAgICBza2lwQml0cygzKTsgLy8gcmVzZXJ2ZWRfemVyb18zYml0cyB1KDMpLFxyXG4gICAgbGV2ZWxJZGMgPSByZWFkVUJ5dGUoKTsgLy9sZXZlbF9pZGMgdSg4KVxyXG4gICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxyXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXHJcbiAgICBpZiAocHJvZmlsZUlkYyA9PT0gMTAwIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTEwIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTIyIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gNDQgIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODMgIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODYgIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTE4IHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XHJcbiAgICAgIHZhciBjaHJvbWFGb3JtYXRJZGMgPSByZWFkVUVHKCk7XHJcbiAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcclxuICAgICAgICBza2lwQml0cygxKTsgLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcclxuICAgICAgfVxyXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxyXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XHJcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcclxuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xyXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSAoY2hyb21hRm9ybWF0SWRjICE9PSAzKSA/IDggOiAxMjtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXHJcbiAgICAgICAgICAgIGlmIChpIDwgNikge1xyXG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDY0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2tpcFVFRygpOyAvLyBsb2cyX21heF9mcmFtZV9udW1fbWludXM0XHJcbiAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xyXG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xyXG4gICAgICByZWFkVUVHKCk7IC8vbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XHJcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xyXG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcclxuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcclxuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxyXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XHJcbiAgICAgIGZvcihpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XHJcbiAgICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2tpcFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcclxuICAgIHNraXBCaXRzKDEpOyAvLyBnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWdcclxuICAgIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XHJcbiAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gcmVhZFVFRygpO1xyXG4gICAgZnJhbWVNYnNPbmx5RmxhZyA9IHJlYWRCaXRzKDEpO1xyXG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcclxuICAgICAgc2tpcEJpdHMoMSk7IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcclxuICAgIH1cclxuICAgIHNraXBCaXRzKDEpOyAvLyBkaXJlY3RfOHg4X2luZmVyZW5jZV9mbGFnXHJcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXHJcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSByZWFkVUVHKCk7XHJcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xyXG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XHJcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IHJlYWRVRUcoKTtcclxuICAgIH1cclxuICAgIGxldCBwaXhlbFJhdGlvID0gWzEsMV07XHJcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xyXG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcclxuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcclxuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcclxuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xyXG4gICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcclxuICAgICAgICAgIGNhc2UgMTogcGl4ZWxSYXRpbyA9IFsxLDFdOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgMjogcGl4ZWxSYXRpbyA9IFsxMiwxMV07IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAzOiBwaXhlbFJhdGlvID0gWzEwLDExXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDQ6IHBpeGVsUmF0aW8gPSBbMTYsMTFdOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgNTogcGl4ZWxSYXRpbyA9IFs0MCwzM107IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSA2OiBwaXhlbFJhdGlvID0gWzI0LDExXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDc6IHBpeGVsUmF0aW8gPSBbMjAsMTFdOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgODogcGl4ZWxSYXRpbyA9IFszMiwxMV07IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSA5OiBwaXhlbFJhdGlvID0gWzgwLDMzXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDEwOiBwaXhlbFJhdGlvID0gWzE4LDExXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDExOiBwaXhlbFJhdGlvID0gWzE1LDExXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDEyOiBwaXhlbFJhdGlvID0gWzY0LDMzXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDEzOiBwaXhlbFJhdGlvID0gWzE2MCw5OV07IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAxNDogcGl4ZWxSYXRpbyA9IFs0LDNdOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgMTU6IHBpeGVsUmF0aW8gPSBbMywyXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDE2OiBwaXhlbFJhdGlvID0gWzIsMV07IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAyNTU6IHtcclxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFtyZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCksIHJlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKV07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IE1hdGguY2VpbCgoKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNikgLSBmcmFtZUNyb3BMZWZ0T2Zmc2V0ICogMiAtIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMikpLFxyXG4gICAgICBoZWlnaHQ6ICgoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2KSAtICgoZnJhbWVNYnNPbmx5RmxhZz8gMiA6IDQpICogKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCkpLFxyXG4gICAgICBwaXhlbFJhdGlvIDogcGl4ZWxSYXRpb1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJlYWRTbGljZVR5cGUoKSB7XHJcbiAgICAvLyBza2lwIE5BTHUgdHlwZVxyXG4gICAgdGhpcy5yZWFkVUJ5dGUoKTtcclxuICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcclxuICAgIHRoaXMucmVhZFVFRygpO1xyXG4gICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcclxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEV4cEdvbG9tYjtcclxuIiwiLyoqXG4gKiBJRDMgcGFyc2VyXG4gKi9cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuLy9pbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG5cbiBjbGFzcyBJRDMge1xuXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLl9oYXNUaW1lU3RhbXAgPSBmYWxzZTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwLCBieXRlMSxieXRlMixieXRlMyxieXRlNCx0YWdTaXplLGVuZFBvcyxoZWFkZXIsbGVuO1xuICAgICAgZG8ge1xuICAgICAgICBoZWFkZXIgPSB0aGlzLnJlYWRVVEYoZGF0YSxvZmZzZXQsMyk7XG4gICAgICAgIG9mZnNldCs9MztcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgSUQzIGhlYWRlclxuICAgICAgICAgIGlmIChoZWFkZXIgPT09ICdJRDMnKSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgMjQgYml0c1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgLy8gcmV0cmlldmUgdGFnKHMpIGxlbmd0aFxuICAgICAgICAgICAgICBieXRlMSA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgYnl0ZTIgPSBkYXRhW29mZnNldCsrXSAmIDB4N2Y7XG4gICAgICAgICAgICAgIGJ5dGUzID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICAgICAgICBieXRlNCA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgdGFnU2l6ZSA9IChieXRlMSA8PCAyMSkgKyAoYnl0ZTIgPDwgMTQpICsgKGJ5dGUzIDw8IDcpICsgYnl0ZTQ7XG4gICAgICAgICAgICAgIGVuZFBvcyA9IG9mZnNldCArIHRhZ1NpemU7XG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgSUQzIHRhZyBmb3VuZCwgc2l6ZS9lbmQ6ICR7dGFnU2l6ZX0vJHtlbmRQb3N9YCk7XG5cbiAgICAgICAgICAgICAgLy8gcmVhZCBJRDMgdGFnc1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlEM0ZyYW1lcyhkYXRhLCBvZmZzZXQsZW5kUG9zKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gZW5kUG9zO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyID09PSAnM0RJJykge1xuICAgICAgICAgICAgICAvLyBodHRwOi8vaWQzLm9yZy9pZDN2Mi40LjAtc3RydWN0dXJlIGNoYXB0ZXIgMy40LiAgIElEM3YyIGZvb3RlclxuICAgICAgICAgICAgICBvZmZzZXQgKz0gNztcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYDNESSBmb290ZXIgZm91bmQsIGVuZDogJHtvZmZzZXR9YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2Zmc2V0IC09IDM7XG4gICAgICAgICAgICAgIGxlbiA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYElEMyBsZW46ICR7bGVufWApO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNUaW1lU3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0lEMyB0YWcgZm91bmQsIGJ1dCBubyB0aW1lc3RhbXAnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BheWxvYWQgPSBkYXRhLnN1YmFycmF5KDAsbGVuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG5cbiAgc3RhdGljIGlzSUQzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAgIC8qXG4gICAgKiBBbiBJRDN2MiB0YWcgY2FuIGJlIGRldGVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgICogICQ0OSA0NCAzMyB5eSB5eSB4eCB6eiB6eiB6eiB6elxuICAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxuICAgICovXG4gICAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvL2xvb2sgZm9yICdJRDMnIGlkZW50aWZpZXJcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQrMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQrMl0gPT09IDB4MzMpIHtcbiAgICAgICAgLy9jaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQrM10gPCAweEZGICYmIGRhdGFbb2Zmc2V0KzRdIDwgMHhGRikge1xuICAgICAgICAgIC8vY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQrNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0KzddIDwgMHg4MCAmJiBkYXRhW29mZnNldCs4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQrOV0gPCAweDgwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgaXNJRDNGb290ZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLypcbiAgICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICAqL1xuICAgIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgLy9sb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDMzICYmIGRhdGFbb2Zmc2V0KzFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0KzJdID09PSAweDQ5KSB7XG4gICAgICAgIC8vY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0KzNdIDwgMHhGRiAmJiBkYXRhW29mZnNldCs0XSA8IDB4RkYpIHtcbiAgICAgICAgICAvL2NoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0KzZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCs3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQrOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0KzldIDwgMHg4MCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0VGFnRGF0YShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoSUQzLmlzSUQzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIGxldCB0YWdMZW5ndGggPSAxMDtcblxuICAgICAgLy9za2lwIElEM1xuICAgICAgLy9vZmZzZXQgKz0gMztcblxuICAgICAgLy9za2lwIHZlcnNpb24gYW5kIGZsYWdzXG4gICAgICAvL29mZnNldCArPSAzO1xuXG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICAvL3NpemUgID0gKChkYXRhW29mZnNldCsrXSAmIDB4N2YpIDw8IDIxKTtcbiAgICAgIC8vc2l6ZSB8PSAoKGRhdGFbb2Zmc2V0KytdICYgMHg3ZikgPDwgMTQpO1xuICAgICAgLy9zaXplIHw9ICgoZGF0YVtvZmZzZXQrK10gJiAweDdmKSA8PCA3KTtcbiAgICAgIC8vc2l6ZSB8PSAgKGRhdGFbb2Zmc2V0KytdICYgMHg3Zik7XG5cbiAgICAgIC8vY29uc3QgZnJhbWVEYXRhID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpO1xuXG4gICAgICAvL29mZnNldCArPSBzaXplO1xuICAgICAgdGFnTGVuZ3RoICs9IHNpemU7XG5cbiAgICAgIGlmIChJRDMuaXNJRDNGb290ZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAvL29mZnNldCArPSAxMDtcbiAgICAgICAgdGFnTGVuZ3RoICs9IDEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHRhZ0xlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIF9yZWFkU2l6ZShkYXRhLCBvZmZzZXQpIHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgc2l6ZSAgPSAoKGRhdGFbb2Zmc2V0XSAgICYgMHg3ZikgPDwgMjEpO1xuICAgIHNpemUgfD0gKChkYXRhW29mZnNldCsxXSAmIDB4N2YpIDw8IDE0KTtcbiAgICBzaXplIHw9ICgoZGF0YVtvZmZzZXQrMl0gJiAweDdmKSA8PCA3KTtcbiAgICBzaXplIHw9ICAoZGF0YVtvZmZzZXQrM10gJiAweDdmKTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIGdldFRpbWVTdGFtcCh0YWdEYXRhKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgaWYgKElEMy5pc0lEM0hlYWRlcih0YWdEYXRhLCBvZmZzZXQpKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fcmVhZFNpemUodGFnRGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICAvL3NpemUgb2YgdGltZXN0YW1wIGZyYW1lIGlzIDYzIGJ5dGVzIChpbmNsdWRpbmcgZnJhbWUgaGVhZGVyKVxuICAgICAgaWYgKHNpemUgPj0gNjMpIHtcbiAgICAgICAgb2Zmc2V0ID0gMTA7XG4gICAgICAgIC8vZnJhbWUgaGVhZGVyIGlzIDEwIGJ5dGVzXG4gICAgICAgIHdoaWxlIChvZmZzZXQgKyAxMCA8IHRhZ0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLmdldEZyYW1lSW5mbyh0YWdEYXRhLnN1YmFycmF5KG9mZnNldCkpO1xuICAgICAgICAgIGlmIChmcmFtZS50eXBlID09PSAnUFJJVicgJiYgZnJhbWUuc2l6ZSA9PT0gNTMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRoaXMuZGVjb2RlVGltZVN0YW1wRnJhbWUoZnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLnNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldEZyYW1lSW5mbyhkYXRhKSB7XG4gICAgLypcbiAgICBGcmFtZSBJRCAgICAgICAkeHggeHggeHggeHggKGZvdXIgY2hhcmFjdGVycylcbiAgICBTaXplICAgICAgICAgICAkeHggeHggeHggeHhcbiAgICBGbGFncyAgICAgICAgICAkeHggeHhcbiAgICAqL1xuICAgIGNvbnN0IHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10pO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9yZWFkU2l6ZShkYXRhLCA0KTtcblxuICAgIC8vc2tpcCBmcmFtZSBpZCwgc2l6ZSwgYW5kIGZsYWdzXG4gICAgbGV0IG9mZnNldCA9IDEwO1xuXG4gICAgcmV0dXJuIHsgdHlwZSwgc2l6ZSwgZGF0YTogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpIH07XG4gIH1cblxuICByZWFkRnJhbWVEYXRhKGRhdGEpIHtcbiAgICAvKlxuICAgIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxuICAgIFNpemUgICAgICAgICAgICR4eCB4eCB4eCB4eFxuICAgIEZsYWdzICAgICAgICAgICR4eCB4eFxuICAgICovXG4gICAgY29uc3QgdHlwZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3JlYWRTaXplKGRhdGEsIDQpO1xuXG4gICAgLy9za2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgICBsZXQgb2Zmc2V0ID0gMTA7XG5cbiAgICByZXR1cm4gdGhpcy5kZWNvZGVJRDNGcmFtZSh7IHR5cGUsIHNpemUsIGRhdGE6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKSB9KTtcbiAgfVxuXG4gIGRlY29kZUZyYW1lKGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdUJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlVGV4dEZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlVVJMRnJhbWUoZnJhbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBkZWNvZGVUaW1lU3RhbXBGcmFtZShmcmFtZSkge1xuICAgIGNvbnN0IHByaXZGcmFtZSA9IHRoaXMuZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgICBpZiAocHJpdkZyYW1lLmRhdGEuYnl0ZUxlbmd0aCA9PT0gOCAmJiBwcml2RnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJykge1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHByaXZGcmFtZS5kYXRhKTtcbiAgICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsXG4gICAgICAvLyB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgICAgY29uc3QgcHRzMzNCaXQgPSBkYXRhWzNdICYgMHgxO1xuICAgICAgbGV0IHRpbWVzdGFtcCA9IChkYXRhWzRdIDw8IDIzKSArXG4gICAgICAgICAgICAgICAgICAgICAgKGRhdGFbNV0gPDwgMTUpICtcbiAgICAgICAgICAgICAgICAgICAgICAoZGF0YVs2XSA8PCAgNykgK1xuICAgICAgICAgICAgICAgICAgICAgICBkYXRhWzddO1xuICAgICAgdGltZXN0YW1wIC89IDQ1O1xuXG4gICAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgICAgdGltZXN0YW1wICs9IDQ3NzIxODU4Ljg0OyAvLyAyXjMyIC8gOTBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGgucm91bmQodGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZGVjb2RlUHJpdkZyYW1lKGZyYW1lKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgb3duZXIgPSB0aGlzLnV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICAgIGNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZnJhbWUuZGF0YS5zdWJhcnJheShvd25lci5sZW5ndGggKyAxKSk7XG5cbiAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IG93bmVyLCBkYXRhOiBwcml2YXRlRGF0YS5idWZmZXIgfTtcbiAgfVxuXG4gIGRlY29kZVRleHRGcmFtZShmcmFtZSkge1xuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZnJhbWUuZGF0YVswXSAhPT0gMykge1xuICAgICAgLy9vbmx5IHN1cHBvcnQgVVRGLThcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xuICAgICAgLypcbiAgICAgIEZvcm1hdDpcbiAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VmFsdWV9XG4gICAgICAqL1xuICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy51dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG5cbiAgICAgIGluZGV4ICs9IGRlc2NyaXB0aW9uLmxlbmd0aCArIDE7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IGRlc2NyaXB0aW9uLCBkYXRhOiB2YWx1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKlxuICAgICAgRm9ybWF0OlxuICAgICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICAgIFsxLT9dID0ge1ZhbHVlfVxuICAgICAgKi9cbiAgICAgIGNvbnN0IHRleHQgPSB0aGlzLnV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB0ZXh0IH07XG4gICAgfVxuICB9XG5cbiAgZGVjb2RlVVJMRnJhbWUoZnJhbWUpIHtcblxuICB9XG5cbiAgcmVhZFVURihkYXRhLHN0YXJ0LGxlbikge1xuXG4gICAgdmFyIHJlc3VsdCA9ICcnLG9mZnNldCA9IHN0YXJ0LCBlbmQgPSBzdGFydCArIGxlbjtcbiAgICBkbyB7XG4gICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW29mZnNldCsrXSk7XG4gICAgfSB3aGlsZShvZmZzZXQgPCBlbmQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfcGFyc2VJRDNGcmFtZXMoZGF0YSxvZmZzZXQsZW5kUG9zKSB7XG4gICAgdmFyIHRhZ0lkLHRhZ0xlbix0YWdTdGFydCx0YWdGbGFncyx0aW1lc3RhbXA7XG4gICAgd2hpbGUob2Zmc2V0ICsgOCA8PSBlbmRQb3MpIHtcbiAgICAgIHRhZ0lkID0gdGhpcy5yZWFkVVRGKGRhdGEsb2Zmc2V0LDQpO1xuICAgICAgb2Zmc2V0ICs9NDtcblxuICAgICAgdGFnTGVuID0gZGF0YVtvZmZzZXQrK10gPDwgMjQgK1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdIDw8IDE2ICtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXSA8PCA4ICtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXTtcblxuICAgICAgdGFnRmxhZ3MgPSBkYXRhW29mZnNldCsrXSA8PCA4ICtcbiAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdO1xuXG4gICAgICB0YWdTdGFydCA9IG9mZnNldDtcbiAgICAgIC8vbG9nZ2VyLmxvZyhcIklEMyB0YWcgaWQ6XCIgKyB0YWdJZCk7XG4gICAgICBzd2l0Y2godGFnSWQpIHtcbiAgICAgICAgY2FzZSAnUFJJVic6XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ3BhcnNlIGZyYW1lOicgKyBIZXguaGV4RHVtcChkYXRhLnN1YmFycmF5KG9mZnNldCxlbmRQb3MpKSk7XG4gICAgICAgICAgICAvLyBvd25lciBzaG91bGQgYmUgXCJjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcFwiXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkVVRGKGRhdGEsb2Zmc2V0LDQ0KSA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIG9mZnNldCs9NDQ7XG4gICAgICAgICAgICAgICAgLy8gc21lbGxpbmcgZXZlbiBiZXR0ZXIgISB3ZSBmb3VuZCB0aGUgcmlnaHQgZGVzY3JpcHRvclxuICAgICAgICAgICAgICAgIC8vIHNraXAgbnVsbCBjaGFyYWN0ZXIgKHN0cmluZyBlbmQpICsgMyBmaXJzdCBieXRlc1xuICAgICAgICAgICAgICAgIG9mZnNldCs9IDQ7XG5cbiAgICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLCB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgICAgICAgICAgICAgIHZhciBwdHMzM0JpdCAgPSBkYXRhW29mZnNldCsrXSAmIDB4MTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUaW1lU3RhbXAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gKChkYXRhW29mZnNldCsrXSA8PCAyMykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQrK10gPDwgMTUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGFbb2Zmc2V0KytdIDw8ICA3KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdKSAvNDU7XG5cbiAgICAgICAgICAgICAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wICAgKz0gNDc3MjE4NTguODQ7IC8vIDJeMzIgLyA5MFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKGBJRDMgdGltZXN0YW1wIGZvdW5kOiAke3RpbWVzdGFtcH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBoYXNUaW1lU3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc1RpbWVTdGFtcDtcbiAgfVxuXG4gIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVTdGFtcDtcbiAgfVxuXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgfVxuXG4gIGdldCBwYXlsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXlsb2FkO1xuICB9XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcbiAgLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbiAgLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gICAqXG4gICAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gICAqIFZlcnNpb246IDEuMFxuICAgKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XG4gICAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAgICovXG4gIHV0ZjhBcnJheVRvU3RyKGFycmF5KSB7XG5cbiAgICBsZXQgY2hhcjI7XG4gICAgbGV0IGNoYXIzO1xuICAgIGxldCBvdXQgPSAnJztcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICBsZXQgYyA9IGFycmF5W2krK107XG4gICAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgY2FzZSAxOiBjYXNlIDI6IGNhc2UgMzogY2FzZSA0OiBjYXNlIDU6IGNhc2UgNjogY2FzZSA3OlxuICAgICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6IGNhc2UgMTM6XG4gICAgICAgICAgLy8gMTEweCB4eHh4ICAgMTB4eCB4eHh4XG4gICAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MUYpIDw8IDYpIHwgKGNoYXIyICYgMHgzRikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIC8vIDExMTAgeHh4eCAgMTB4eCB4eHh4ICAxMHh4IHh4eHhcbiAgICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MEYpIDw8IDEyKSB8XG4gICAgICAgICAgICAoKGNoYXIyICYgMHgzRikgPDwgNikgfFxuICAgICAgICAgICAgKChjaGFyMyAmIDB4M0YpIDw8IDApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElEMztcblxuIiwiLyoqXHJcbiAqIE1QMyBkZW11eGVyXHJcbiAqL1xyXG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XHJcbmltcG9ydCBNcGVnQXVkaW8gZnJvbSAnLi9tcGVnYXVkaW8nO1xyXG5cclxuIGNsYXNzIE1QM0RlbXV4ZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XHJcbiAgfVxyXG5cclxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LGF1ZGlvQ29kZWMsdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcclxuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7Y29udGFpbmVyIDogJ2F1ZGlvL21wZWcnLCB0eXBlOiAnYXVkaW8nLCBpZCA6LTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBpc0FBQyA6IGZhbHNlICwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwLCBtYW5pZmVzdENvZGVjIDogYXVkaW9Db2RlYywgZHVyYXRpb24gOiBkdXJhdGlvbiwgaW5wdXRUaW1lU2NhbGUgOiA5MDAwMH07XHJcbiAgfVxyXG5cclxuICByZXNldFRpbWVTdGFtcCgpIHtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XHJcbiAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXHJcbiAgICB2YXIgaWQzID0gbmV3IElEMyhkYXRhKSwgb2Zmc2V0LCBsZW5ndGg7XHJcbiAgICBpZiAoaWQzLmhhc1RpbWVTdGFtcCkge1xyXG4gICAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxyXG4gICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxyXG4gICAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxyXG4gICAgICBmb3IgKG9mZnNldCA9IGlkMy5sZW5ndGgsIGxlbmd0aCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMSwgb2Zmc2V0ICsgMTAwKTsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xyXG4gICAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoZGF0YVtvZmZzZXQrMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQrMV0gJiAweDA2KSAhPT0gMHgwMCkge1xyXG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdNUEVHIHN5bmMgd29yZCBmb3VuZCAhJyk7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG5cclxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXHJcbiAgYXBwZW5kKGRhdGEsIHRpbWVPZmZzZXQsY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcclxuICAgIHZhciBpZDMgPSBuZXcgSUQzKGRhdGEpO1xyXG4gICAgdmFyIHB0cyA9IDkwKmlkMy50aW1lU3RhbXA7XHJcbiAgICB2YXIgYWZ0ZXJJRDMgPSBpZDMubGVuZ3RoO1xyXG4gICAgdmFyIG9mZnNldCwgbGVuZ3RoO1xyXG5cclxuICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyXHJcbiAgICBmb3IgKG9mZnNldCA9IGFmdGVySUQzLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoIC0gMTsgb2Zmc2V0KyspIHtcclxuICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmIChkYXRhW29mZnNldCsxXSAmIDB4ZTApID09PSAweGUwICYmIChkYXRhW29mZnNldCsxXSAmIDB4MDYpICE9PSAweDAwKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBNcGVnQXVkaW8ucGFyc2UodGhpcy5fYXVkaW9UcmFjaywgZGF0YSwgaWQzLmxlbmd0aCwgcHRzKTtcclxuXHJcbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgodGhpcy5fYXVkaW9UcmFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAge3NhbXBsZXMgOiBbXX0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzYW1wbGVzIDogWyB7IHB0czogcHRzLCBkdHMgOiBwdHMsIGRhdGEgOiBpZDMucGF5bG9hZH1dLCBpbnB1dFRpbWVTY2FsZSA6IDkwMDAwfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAge3NhbXBsZXMgOiBbXX0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpZ3VvdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTVAzRGVtdXhlcjtcclxuIiwiLyoqXHJcbiAqIE1QNCBkZW11eGVyXHJcbiAqL1xyXG4vL2ltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuXHJcblxyXG4gY2xhc3MgTVA0RGVtdXhlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCByZW11eGVyKSB7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRUaW1lU3RhbXAoKSB7XHJcblxyXG4gIH1cclxuXHJcbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCxhdWRpb0NvZGVjLHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XHJcbiAgICAvL2pzaGludCB1bnVzZWQ6ZmFsc2VcclxuICAgIGNvbnN0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YSA9IE1QNERlbXV4ZXIucGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XHJcbiAgICB2YXIgdHJhY2tzID0ge307XHJcbiAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcclxuICAgICAgdHJhY2tzLmF1ZGlvID0geyBjb250YWluZXIgOiAnYXVkaW8vbXA0JywgY29kZWMgOiBhdWRpb0NvZGVjLCBpbml0U2VnbWVudCA6IGluaXRTZWdtZW50fTtcclxuICAgIH1cclxuICAgIGlmIChpbml0RGF0YS52aWRlbykge1xyXG4gICAgICB0cmFja3MudmlkZW8gPSB7IGNvbnRhaW5lciA6ICd2aWRlby9tcDQnLCBjb2RlYyA6IHZpZGVvQ29kZWMsIGluaXRTZWdtZW50IDogaW5pdFNlZ21lbnR9O1xyXG4gICAgfVxyXG4gICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQseyB0cmFja3MgOiB0cmFja3MgfSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDgpIHtcclxuICAgICAgY29uc3QgZGF0YVR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoZGF0YS5zdWJhcnJheSg0LDgpKTtcclxuICAgICAgcmV0dXJuIChbJ21vb2YnLCdmdHlwJywnc3R5cCddLmluZGV4T2YoZGF0YVR5cGUpID49IDApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcblxyXG4gIHN0YXRpYyBiaW4yc3RyKGJ1ZmZlcikge1xyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmZmVyKTtcclxuICB9XHJcblxyXG4gIC8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxyXG4gIHN0YXRpYyBmaW5kQm94KGRhdGEsIHBhdGgpIHtcclxuICAgIHZhciByZXN1bHRzID0gW10sXHJcbiAgICAgICAgaSwgc2l6ZSwgdHlwZSwgZW5kLCBzdWJyZXN1bHRzO1xyXG5cclxuICAgIGlmICghcGF0aC5sZW5ndGgpIHtcclxuICAgICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5ieXRlTGVuZ3RoOykge1xyXG4gICAgICBzaXplICA9IGRhdGFbaV0gICAgIDw8IDI0O1xyXG4gICAgICBzaXplIHw9IGRhdGFbaSArIDFdIDw8IDE2O1xyXG4gICAgICBzaXplIHw9IGRhdGFbaSArIDJdIDw8IDg7XHJcbiAgICAgIHNpemUgfD0gZGF0YVtpICsgM107XHJcblxyXG4gICAgICB0eXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGRhdGEuc3ViYXJyYXkoaSArIDQsIGkgKyA4KSk7XHJcblxyXG4gICAgICBlbmQgPSBzaXplID4gMSA/IGkgKyBzaXplIDogZGF0YS5ieXRlTGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXHJcbiAgICAgICAgICAvLyBsb29raW5nIGZvclxyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxyXG4gICAgICAgICAgc3VicmVzdWx0cyA9IE1QNERlbXV4ZXIuZmluZEJveChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmQpLCBwYXRoLnNsaWNlKDEpKTtcclxuICAgICAgICAgIGlmIChzdWJyZXN1bHRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoc3VicmVzdWx0cyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGkgPSBlbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2UndmUgZmluaXNoZWQgc2VhcmNoaW5nIGFsbCBvZiBkYXRhXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgYW4gTVA0IGluaXRpYWxpemF0aW9uIHNlZ21lbnQgYW5kIGV4dHJhY3RzIHN0cmVhbSB0eXBlIGFuZFxyXG4gKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxyXG4gKiBudW1iZXIgb2YgY2xvY2sgdGlja3MgcGVyIHNlY29uZCB0byBhc3N1bWUgZm9yIHRpbWUtYmFzZWQgdmFsdWVzXHJcbiAqIGVsc2V3aGVyZSBpbiB0aGUgTVA0LlxyXG4gKlxyXG4gKiBUbyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWUgb2YgYW4gTVA0LCB5b3UgbmVlZCB0d28gcGllY2VzIG9mXHJcbiAqIGluZm9ybWF0aW9uOiB0aGUgdGltZXNjYWxlIHVuaXQgYW5kIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZVxyXG4gKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXHJcbiAqIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiB0aGUgdGltZXNjYWxlIGZyb21cclxuICogdGhlIG1lZGlhIGhlYWRlciBib3ggZm9yIHRoZSB0cmFjazpcclxuICogYGBgXHJcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IG1kaGQudGltZXNjYWxlXHJcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IGhkbHJcclxuICogYGBgXHJcbiAqIEBwYXJhbSBpbml0IHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgdGhlIGluaXQgc2VnbWVudFxyXG4gKiBAcmV0dXJuIHtvYmplY3R9IGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXMgb3IgbnVsbCBpZlxyXG4gKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cclxuICovXHJcbiAgc3RhdGljIHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIHZhciB0cmFrcyA9IE1QNERlbXV4ZXIuZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XHJcblxyXG4gICAgdHJha3MuZm9yRWFjaCh0cmFrID0+IHtcclxuICAgICAgY29uc3QgdGtoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XHJcbiAgICAgIGlmICh0a2hkKSB7XHJcbiAgICAgICAgbGV0IHZlcnNpb24gPSB0a2hkWzBdO1xyXG4gICAgICAgIGxldCBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xyXG4gICAgICAgIGxldCB0cmFja0lkID0gdGtoZFtpbmRleF0gICAgIDw8IDI0IHxcclxuICAgICAgICAgICAgICAgICAgICAgIHRraGRbaW5kZXggKyAxXSA8PCAxNiB8XHJcbiAgICAgICAgICAgICAgICAgICAgICB0a2hkW2luZGV4ICsgMl0gPDwgIDggfFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGtoZFtpbmRleCArIDNdO1xyXG5cclxuICAgICAgICB0cmFja0lkID0gdHJhY2tJZCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdHJhY2tJZCA6IHRyYWNrSWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IG1kaGQgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XHJcbiAgICAgICAgaWYgKG1kaGQpIHtcclxuICAgICAgICAgIHZlcnNpb24gPSBtZGhkWzBdO1xyXG4gICAgICAgICAgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcclxuICAgICAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IG1kaGRbaW5kZXhdICAgICA8PCAyNCB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZGhkW2luZGV4ICsgMV0gPDwgMTYgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWRoZFtpbmRleCArIDJdIDw8ICA4IHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1kaGRbaW5kZXggKyAzXTtcclxuXHJcbiAgICAgICAgICBjb25zdCBoZGxyID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdoZGxyJ10pWzBdO1xyXG4gICAgICAgICAgaWYgKGhkbHIpIHtcclxuICAgICAgICAgICAgY29uc3QgaGRsclR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoaGRsci5zdWJhcnJheSg4LCAxMikpO1xyXG4gICAgICAgICAgICBsZXQgdHlwZSA9IHsgJ3NvdW4nIDogJ2F1ZGlvJywgJ3ZpZGUnIDogJ3ZpZGVvJ31baGRsclR5cGVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdFt0cmFja0lkXSA9IHsgdGltZXNjYWxlIDogdGltZXNjYWxlICwgdHlwZSA6IHR5cGV9O1xyXG4gICAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IHsgdGltZXNjYWxlIDogdGltZXNjYWxlICwgaWQgOiB0cmFja0lkfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XHJcbiAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcclxuICogcmV0dXJuZWQuXHJcbiAqXHJcbiAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxyXG4gKiBtZXRhZGF0YTpcclxuICogYGBgXHJcbiAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXHJcbiAqIGBgYFxyXG4gKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxyXG4gKlxyXG4gKiBAcGFyYW0gdGltZXNjYWxlIHtvYmplY3R9IGEgaGFzaCBvZiB0cmFjayBpZHMgdG8gdGltZXNjYWxlIHZhbHVlcy5cclxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXHJcbiAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXHJcbiAqL1xyXG5zdGF0aWMgc3RhcnREVFMoaW5pdERhdGEsIGZyYWdtZW50KSB7XHJcbiAgdmFyIHRyYWZzLCBiYXNlVGltZXMsIHJlc3VsdDtcclxuXHJcbiAgLy8gd2UgbmVlZCBpbmZvIGZyb20gdHdvIGNoaWxkcmVuZCBvZiBlYWNoIHRyYWNrIGZyYWdtZW50IGJveFxyXG4gIHRyYWZzID0gTVA0RGVtdXhlci5maW5kQm94KGZyYWdtZW50LCBbJ21vb2YnLCAndHJhZiddKTtcclxuXHJcbiAgLy8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lcyBmb3IgZWFjaCB0cmFja1xyXG4gIGJhc2VUaW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgdHJhZnMubWFwKGZ1bmN0aW9uKHRyYWYpIHtcclxuICAgIHJldHVybiBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLm1hcChmdW5jdGlvbih0ZmhkKSB7XHJcbiAgICAgIHZhciBpZCwgc2NhbGUsIGJhc2VUaW1lO1xyXG5cclxuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXHJcbiAgICAgIGlkID0gdGZoZFs0XSA8PCAyNCB8XHJcbiAgICAgICAgICAgdGZoZFs1XSA8PCAxNiB8XHJcbiAgICAgICAgICAgdGZoZFs2XSA8PCA4IHxcclxuICAgICAgICAgICB0ZmhkWzddO1xyXG4gICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxyXG4gICAgICBzY2FsZSA9IGluaXREYXRhW2lkXS50aW1lc2NhbGUgfHwgOTBlMztcclxuXHJcbiAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XHJcbiAgICAgIGJhc2VUaW1lID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAoZnVuY3Rpb24odGZkdCkge1xyXG4gICAgICAgIHZhciB2ZXJzaW9uLCByZXN1bHQ7XHJcblxyXG4gICAgICAgIHZlcnNpb24gPSB0ZmR0WzBdO1xyXG4gICAgICAgIHJlc3VsdCA9IHRmZHRbNF0gPDwgMjQgfFxyXG4gICAgICAgICAgICAgICAgIHRmZHRbNV0gPDwgMTYgfFxyXG4gICAgICAgICAgICAgICAgIHRmZHRbNl0gPDwgIDggfFxyXG4gICAgICAgICAgICAgICAgIHRmZHRbN107XHJcbiAgICAgICAgaWYgKHZlcnNpb24gPT09ICAxKSB7XHJcbiAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xyXG4gICAgICAgICAgcmVzdWx0ICs9IHRmZHRbOF0gIDw8IDI0IHxcclxuICAgICAgICAgICAgICAgICAgICB0ZmR0WzldICA8PCAxNiB8XHJcbiAgICAgICAgICAgICAgICAgICAgdGZkdFsxMF0gPDwgIDggfFxyXG4gICAgICAgICAgICAgICAgICAgIHRmZHRbMTFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9KVswXTtcclxuICAgICAgYmFzZVRpbWUgPSBiYXNlVGltZSB8fCBJbmZpbml0eTtcclxuXHJcbiAgICAgIC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcclxuICAgICAgcmV0dXJuIGJhc2VUaW1lIC8gc2NhbGU7XHJcbiAgICB9KTtcclxuICB9KSk7XHJcblxyXG4gIC8vIHJldHVybiB0aGUgbWluaW11bVxyXG4gIHJlc3VsdCA9IE1hdGgubWluLmFwcGx5KG51bGwsIGJhc2VUaW1lcyk7XHJcbiAgcmV0dXJuIGlzRmluaXRlKHJlc3VsdCkgPyByZXN1bHQgOiAwO1xyXG59XHJcblxyXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcclxuICBhcHBlbmQoZGF0YSwgdGltZU9mZnNldCxjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCkge1xyXG4gICAgY29uc3QgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xyXG4gICAgY29uc3Qgc3RhcnREVFMgPSBNUDREZW11eGVyLnN0YXJ0RFRTKGluaXREYXRhLGRhdGEpO1xyXG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KGluaXREYXRhLmF1ZGlvLCBpbml0RGF0YS52aWRlbywgbnVsbCwgbnVsbCwgc3RhcnREVFMsIGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0LGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNUDREZW11eGVyO1xyXG4iLCIvKipcclxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxyXG4gKi9cclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5jb25zdCBNcGVnQXVkaW8gPSB7XHJcblxyXG4gIG9uRnJhbWU6IGZ1bmN0aW9uKHRyYWNrLCBkYXRhLCBiaXRSYXRlLCBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQsIGZyYW1lSW5kZXgsIHB0cykge1xyXG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSAxMTUyICogOTAwMDAgLyBzYW1wbGVSYXRlO1xyXG4gICAgdmFyIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XHJcblxyXG4gICAgdHJhY2suY29uZmlnID0gW107XHJcbiAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjaGFubmVsQ291bnQ7XHJcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gc2FtcGxlUmF0ZTtcclxuICAgIHRyYWNrLnNhbXBsZXMucHVzaCh7dW5pdDogZGF0YSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcH0pO1xyXG4gICAgdHJhY2subGVuICs9IGRhdGEubGVuZ3RoO1xyXG4gIH0sXHJcblxyXG4gIG9uTm9pc2U6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIGxvZ2dlci53YXJuKCdtcGVnIGF1ZGlvIGhhcyBub2lzZTogJyArIGRhdGEubGVuZ3RoICsgJyBieXRlcycpO1xyXG4gIH0sXHJcblxyXG4gIHBhcnNlRnJhbWVzOiBmdW5jdGlvbih0cmFjaywgZGF0YSwgc3RhcnQsIGVuZCwgZnJhbWVJbmRleCwgcHRzKSB7XHJcbiAgICB2YXIgQml0cmF0ZXNNYXAgPSBbXHJcbiAgICAgICAgMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsXHJcbiAgICAgICAgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzODQsXHJcbiAgICAgICAgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCxcclxuICAgICAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NixcclxuICAgICAgICA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjBdO1xyXG4gICAgdmFyIFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xyXG5cclxuICAgIGlmIChzdGFydCArIDIgPiBlbmQpIHtcclxuICAgICAgICByZXR1cm4gLTE7IC8vIHdlIG5lZWQgYXQgbGVhc3QgMiBieXRlcyB0byBkZXRlY3Qgc3luYyBwYXR0ZXJuXHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YVtzdGFydF0gPT09IDB4RkYgfHwgKGRhdGFbc3RhcnQgKyAxXSAmIDB4RTApID09PSAweEUwKSB7XHJcbiAgICAgICAgLy8gVXNpbmcgaHR0cDovL3d3dy5kYXRhdm95YWdlLmNvbS9tcGdzY3JpcHQvbXBlZ2hkci5odG0gYXMgYSByZWZlcmVuY2VcclxuICAgICAgICBpZiAoc3RhcnQgKyAyNCA+IGVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoZWFkZXJCID0gKGRhdGFbc3RhcnQgKyAxXSA+PiAzKSAmIDM7XHJcbiAgICAgICAgdmFyIGhlYWRlckMgPSAoZGF0YVtzdGFydCArIDFdID4+IDEpICYgMztcclxuICAgICAgICB2YXIgaGVhZGVyRSA9IChkYXRhW3N0YXJ0ICsgMl0gPj4gNCkgJiAxNTtcclxuICAgICAgICB2YXIgaGVhZGVyRiA9IChkYXRhW3N0YXJ0ICsgMl0gPj4gMikgJiAzO1xyXG4gICAgICAgIHZhciBoZWFkZXJHID0gISEoZGF0YVtzdGFydCArIDJdICYgMik7XHJcbiAgICAgICAgaWYgKGhlYWRlckIgIT09IDEgJiYgaGVhZGVyRSAhPT0gMCAmJiBoZWFkZXJFICE9PSAxNSAmJiBoZWFkZXJGICE9PSAzKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbkJpdHJhdGVzID0gaGVhZGVyQiA9PT0gMyA/ICgzIC0gaGVhZGVyQykgOiAoaGVhZGVyQyA9PT0gMyA/IDMgOiA0KTtcclxuICAgICAgICAgICAgdmFyIGJpdFJhdGUgPSBCaXRyYXRlc01hcFtjb2x1bW5JbkJpdHJhdGVzICogMTQgKyBoZWFkZXJFIC0gMV0gKiAxMDAwO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uSW5TYW1wbGVSYXRlcyA9IGhlYWRlckIgPT09IDMgPyAwIDogaGVhZGVyQiA9PT0gMiA/IDEgOiAyO1xyXG4gICAgICAgICAgICB2YXIgc2FtcGxlUmF0ZSA9IFNhbXBsaW5nUmF0ZU1hcFtjb2x1bW5JblNhbXBsZVJhdGVzICogMyArIGhlYWRlckZdO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IGhlYWRlckcgPyAxIDogMDtcclxuICAgICAgICAgICAgdmFyIGNoYW5uZWxDb3VudCA9IGRhdGFbc3RhcnQgKyAzXSA+PiA2ID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcclxuICAgICAgICAgICAgdmFyIGZyYW1lTGVuZ3RoID0gaGVhZGVyQyA9PT0gMyA/XHJcbiAgICAgICAgICAgICAgICAoKGhlYWRlckIgPT09IDMgPyAxMiA6IDYpICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nKSA8PCAyIDpcclxuICAgICAgICAgICAgICAgICgoaGVhZGVyQiA9PT0gMyA/IDE0NCA6IDcyKSAqIGJpdFJhdGUgLyBzYW1wbGVSYXRlICsgcGFkZGluZykgfCAwO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQgKyBmcmFtZUxlbmd0aCA+IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLm9uRnJhbWUodHJhY2ssIGRhdGEuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgZnJhbWVMZW5ndGgpLCBiaXRSYXRlLCBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQsIGZyYW1lSW5kZXgsIHB0cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnJhbWVMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbm9pc2Ugb3IgSUQzLCB0cnlpbmcgdG8gc2tpcFxyXG4gICAgdmFyIG9mZnNldCA9IHN0YXJ0ICsgMjtcclxuICAgIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcclxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgLSAxXSA9PT0gMHhGRiAmJiAoZGF0YVtvZmZzZXRdICYgMHhFMCkgPT09IDB4RTApIHtcclxuICAgICAgICAgICAgLy8gc3luYyBwYXR0ZXJuIGlzIGZvdW5kXHJcbiAgICAgICAgICAgIHRoaXMub25Ob2lzZShkYXRhLnN1YmFycmF5KHN0YXJ0LCBvZmZzZXQgLSAxKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQrKztcclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9LFxyXG5cclxuICBwYXJzZTogZnVuY3Rpb24odHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICB2YXIgZnJhbWVJbmRleCA9IDA7XHJcbiAgICB2YXIgcGFyc2VkO1xyXG5cclxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGggJiZcclxuICAgICAgICAocGFyc2VkID0gdGhpcy5wYXJzZUZyYW1lcyh0cmFjaywgZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIGZyYW1lSW5kZXgrKywgcHRzKSkgPiAwKSB7XHJcbiAgICAgICAgb2Zmc2V0ICs9IHBhcnNlZDtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1wZWdBdWRpbztcclxuIiwiLyoqXHJcbiAqIFNBTVBMRS1BRVMgZGVjcnlwdGVyXHJcbiovXHJcblxyXG4gaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xyXG5cclxuIGNsYXNzIFNhbXBsZUFlc0RlY3J5cHRlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcsIGRlY3J5cHRkYXRhLCBkaXNjYXJkRVBCKSB7XHJcbiAgICB0aGlzLmRlY3J5cHRkYXRhID0gZGVjcnlwdGRhdGE7XHJcbiAgICB0aGlzLmRpc2NhcmRFUEIgPSBkaXNjYXJkRVBCO1xyXG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKG9ic2VydmVyLCBjb25maWcpO1xyXG4gIH1cclxuXHJcbiAgZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChlbmNyeXB0ZWREYXRhLCB0aGlzLmRlY3J5cHRkYXRhLmtleS5idWZmZXIsIHRoaXMuZGVjcnlwdGRhdGEuaXYuYnVmZmVyLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxyXG4gIGRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrLCBzeW5jKSB7XHJcbiAgICBsZXQgY3VyVW5pdCA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQ7XHJcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XHJcbiAgICBsZXQgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoXHJcbiAgICAgICBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQsXHJcbiAgICAgICBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XHJcblxyXG4gICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XHJcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xyXG4gICAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XHJcbiAgICAgIGN1clVuaXQuc2V0KGRlY3J5cHRlZERhdGEsIDE2KTtcclxuXHJcbiAgICAgIGlmICghc3luYykge1xyXG4gICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCArIDEsIGNhbGxiYWNrKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spIHtcclxuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKykge1xyXG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQubGVuZ3RoIDwgMzIpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcclxuXHJcbiAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpO1xyXG5cclxuICAgICAgaWYgKCFzeW5jKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxyXG4gIGdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpIHtcclxuICAgIGxldCBlbmNyeXB0ZWREYXRhTGVuID0gTWF0aC5mbG9vcigoZGVjb2RlZERhdGEubGVuZ3RoIC0gNDgpIC8gMTYwKSAqIDE2ICsgMTY7XHJcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XHJcbiAgICBsZXQgb3V0cHV0UG9zID0gMDtcclxuICAgIGZvciAobGV0IGlucHV0UG9zID0gMzI7IGlucHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBpbnB1dFBvcyArPSAxNjAsIG91dHB1dFBvcyArPSAxNikge1xyXG4gICAgICBlbmNyeXB0ZWREYXRhLnNldChkZWNvZGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5jcnlwdGVkRGF0YTtcclxuICB9XHJcblxyXG4gIGdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpIHtcclxuICAgIGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcclxuICAgIGxldCBpbnB1dFBvcyA9IDA7XHJcbiAgICBmb3IgKGxldCBvdXRwdXRQb3MgPSAzMjsgb3V0cHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNikge1xyXG4gICAgICBkZWNvZGVkRGF0YS5zZXQoZGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVjb2RlZERhdGE7XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKSB7XHJcbiAgICBsZXQgZGVjb2RlZERhdGEgPSB0aGlzLmRpc2NhcmRFUEIoY3VyVW5pdC5kYXRhKTtcclxuICAgIGxldCBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcclxuICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhLmJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcclxuICAgICAgY3VyVW5pdC5kYXRhID0gbG9jYWx0aGlzLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpO1xyXG5cclxuICAgICAgaWYgKCFzeW5jKSB7XHJcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2spIHtcclxuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xyXG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGN1clVuaXRzID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdHM7XHJcbiAgICAgIGZvciAoOzsgdW5pdEluZGV4KyspIHtcclxuICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY3VyVW5pdCA9IGN1clVuaXRzW3VuaXRJbmRleF07XHJcbiAgICAgICAgaWYgKGN1clVuaXQubGVuZ3RoIDw9IDQ4IHx8IChjdXJVbml0LnR5cGUgIT09IDEgJiYgY3VyVW5pdC50eXBlICE9PSA1KSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xyXG5cclxuICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQsIHN5bmMpO1xyXG5cclxuICAgICAgICBpZiAoIXN5bmMpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiB9XHJcblxyXG4gZXhwb3J0IGRlZmF1bHQgU2FtcGxlQWVzRGVjcnlwdGVyO1xyXG4iLCIvKipcclxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxyXG4gKiBwYXJzZSBQQVQsIFBNVFxyXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xyXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcclxuICogdHJpZ2dlciB0aGUgcmVtdXhlciB1cG9uIHBhcnNpbmcgY29tcGxldGlvblxyXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXHJcbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxyXG4gKiB1cG9uIGRpc2NvbnRpbnVpdHkgb3IgbGV2ZWwgc3dpdGNoIGRldGVjdGlvbiwgaXQgd2lsbCBhbHNvIG5vdGlmaWVzIHRoZSByZW11eGVyIHNvIHRoYXQgaXQgY2FuIHJlc2V0IGl0cyBzdGF0ZS5cclxuKi9cclxuXHJcbiBpbXBvcnQgQURUUyBmcm9tICcuL2FkdHMnO1xyXG4gaW1wb3J0IE1wZWdBdWRpbyBmcm9tICcuL21wZWdhdWRpbyc7XHJcbiBpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuIGltcG9ydCBFeHBHb2xvbWIgZnJvbSAnLi9leHAtZ29sb21iJztcclxuIGltcG9ydCBTYW1wbGVBZXNEZWNyeXB0ZXIgZnJvbSAnLi9zYW1wbGUtYWVzJztcclxuLy8gaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xyXG4gaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbiBpbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcclxuXHJcbiBjbGFzcyBUU0RlbXV4ZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XHJcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xyXG4gICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgc2V0RGVjcnlwdERhdGEoZGVjcnlwdGRhdGEpIHtcclxuICAgIGlmICgoZGVjcnlwdGRhdGEgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLmtleSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEubWV0aG9kID09PSAnU0FNUExFLUFFUycpKSB7XHJcbiAgICAgIHRoaXMuc2FtcGxlQWVzID0gbmV3IFNhbXBsZUFlc0RlY3J5cHRlcih0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZywgZGVjcnlwdGRhdGEsIHRoaXMuZGlzY2FyZEVQQik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xyXG4gICAgLy8gYSBUUyBmcmFnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAzIFRTIHBhY2tldHMsIGEgUEFULCBhIFBNVCwgYW5kIG9uZSBQSUQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XHJcbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gMyoxODggJiYgZGF0YVswXSA9PT0gMHg0NyAmJiBkYXRhWzE4OF0gPT09IDB4NDcgJiYgZGF0YVsyKjE4OF0gPT09IDB4NDcpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LGF1ZGlvQ29kZWMsdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcclxuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xyXG4gICAgdGhpcy5fYXZjVHJhY2sgPSB7Y29udGFpbmVyIDogJ3ZpZGVvL21wMnQnLCB0eXBlOiAndmlkZW8nLCBpZCA6LTEsIGlucHV0VGltZVNjYWxlIDogOTAwMDAsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzIDogW10sIGxlbiA6IDAsIGRyb3BwZWQgOiAwfTtcclxuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7Y29udGFpbmVyIDogJ3ZpZGVvL21wMnQnLCB0eXBlOiAnYXVkaW8nLCBpZCA6LTEsIGlucHV0VGltZVNjYWxlIDogOTAwMDAsIGR1cmF0aW9uOiBkdXJhdGlvbiwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMCwgaXNBQUM6IHRydWV9O1xyXG4gICAgdGhpcy5faWQzVHJhY2sgPSB7dHlwZTogJ2lkMycsIGlkIDotMSwgaW5wdXRUaW1lU2NhbGUgOiA5MDAwMCwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMH07XHJcbiAgICB0aGlzLl90eHRUcmFjayA9IHt0eXBlOiAndGV4dCcsIGlkOiAtMSwgaW5wdXRUaW1lU2NhbGUgOiA5MDAwMCwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMH07XHJcbiAgICAvLyBmbHVzaCBhbnkgcGFydGlhbCBjb250ZW50XHJcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcclxuICAgIHRoaXMuYWFjTGFzdFBUUyA9IG51bGw7XHJcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XHJcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xyXG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcclxuICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgfVxyXG5cclxuICByZXNldFRpbWVTdGFtcCgpIHtcclxuICB9XHJcblxyXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcclxuICBhcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCwgbGVuID0gZGF0YS5sZW5ndGgsIHN0dCwgcGlkLCBhdGYsIG9mZnNldCxwZXMsXHJcbiAgICAgICAgdW5rbm93blBJRHMgPSBmYWxzZTtcclxuICAgIHRoaXMuY29udGlndW91cyA9IGNvbnRpZ3VvdXM7XHJcbiAgICB2YXIgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQsXHJcbiAgICAgICAgYXZjVHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcclxuICAgICAgICBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcclxuICAgICAgICBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrLFxyXG4gICAgICAgIGF2Y0lkID0gYXZjVHJhY2suaWQsXHJcbiAgICAgICAgYXVkaW9JZCA9IGF1ZGlvVHJhY2suaWQsXHJcbiAgICAgICAgaWQzSWQgPSBpZDNUcmFjay5pZCxcclxuICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkLFxyXG4gICAgICAgIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhLFxyXG4gICAgICAgIGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YSxcclxuICAgICAgICBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YSxcclxuICAgICAgICBwYXJzZVBBVCA9IHRoaXMuX3BhcnNlUEFULFxyXG4gICAgICAgIHBhcnNlUE1UID0gdGhpcy5fcGFyc2VQTVQsXHJcbiAgICAgICAgcGFyc2VQRVMgPSB0aGlzLl9wYXJzZVBFUyxcclxuICAgICAgICBwYXJzZUFWQ1BFUyA9IHRoaXMuX3BhcnNlQVZDUEVTLmJpbmQodGhpcyksXHJcbiAgICAgICAgcGFyc2VBQUNQRVMgPSB0aGlzLl9wYXJzZUFBQ1BFUy5iaW5kKHRoaXMpLFxyXG4gICAgICAgIHBhcnNlTVBFR1BFUyA9IHRoaXMuX3BhcnNlTVBFR1BFUy5iaW5kKHRoaXMpLFxyXG4gICAgICAgIHBhcnNlSUQzUEVTICA9IHRoaXMuX3BhcnNlSUQzUEVTLmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy8gZG9uJ3QgcGFyc2UgbGFzdCBUUyBwYWNrZXQgaWYgaW5jb21wbGV0ZVxyXG4gICAgbGVuIC09IGxlbiAlIDE4ODtcclxuICAgIC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXHJcbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IDE4OCkge1xyXG4gICAgICBpZiAoZGF0YVtzdGFydF0gPT09IDB4NDcpIHtcclxuICAgICAgICBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcclxuICAgICAgICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXHJcbiAgICAgICAgcGlkID0gKChkYXRhW3N0YXJ0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbc3RhcnQgKyAyXTtcclxuICAgICAgICBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcclxuICAgICAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cclxuICAgICAgICBpZiAoYXRmID4gMSkge1xyXG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xyXG4gICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXHJcbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSAoc3RhcnQgKyAxODgpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaChwaWQpIHtcclxuICAgICAgICAgIGNhc2UgYXZjSWQ6XHJcbiAgICAgICAgICAgIGlmIChzdHQpIHtcclxuICAgICAgICAgICAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZUFWQ1BFUyhwZXMsZmFsc2UpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBhdmNEYXRhID0ge2RhdGE6IFtdLCBzaXplOiAwfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXZjRGF0YSkge1xyXG4gICAgICAgICAgICAgIGF2Y0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xyXG4gICAgICAgICAgICAgIGF2Y0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgYXVkaW9JZDpcclxuICAgICAgICAgICAgaWYgKHN0dCkge1xyXG4gICAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9UcmFjay5pc0FBQykge1xyXG4gICAgICAgICAgICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcGFyc2VNUEVHUEVTKHBlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHtkYXRhOiBbXSwgc2l6ZTogMH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xyXG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XHJcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIGlkM0lkOlxyXG4gICAgICAgICAgICBpZiAoc3R0KSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VJRDNQRVMocGVzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWQzRGF0YSA9IHtkYXRhOiBbXSwgc2l6ZTogMH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcclxuICAgICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcclxuICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIGlmIChzdHQpIHtcclxuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkID0gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIHBtdElkOlxyXG4gICAgICAgICAgICBpZiAoc3R0KSB7XHJcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHBhcnNlZFBJRHMgPSBwYXJzZVBNVChkYXRhLCBvZmZzZXQsIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnID09PSB0cnVlIHx8IHRoaXMudHlwZVN1cHBvcnRlZC5tcDMgPT09IHRydWUsIHRoaXMuc2FtcGxlQWVzICE9IG51bGwpO1xyXG5cclxuICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVzZXR0aW5nIHRoZSBQSUQgdG8gLTEgaW4gY2FzZVxyXG4gICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cclxuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXHJcbiAgICAgICAgICAgIGF2Y0lkID0gcGFyc2VkUElEcy5hdmM7XHJcbiAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcclxuICAgICAgICAgICAgICBhdmNUcmFjay5pZCA9IGF2Y0lkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xyXG4gICAgICAgICAgICBpZiAoYXVkaW9JZCA+IDApIHtcclxuICAgICAgICAgICAgICBhdWRpb1RyYWNrLmlkID0gYXVkaW9JZDtcclxuICAgICAgICAgICAgICBhdWRpb1RyYWNrLmlzQUFDID0gcGFyc2VkUElEcy5pc0FBQztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZDNJZCA9IHBhcnNlZFBJRHMuaWQzO1xyXG4gICAgICAgICAgICBpZiAoaWQzSWQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWQzVHJhY2suaWQgPSBpZDNJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5rbm93blBJRHMgJiYgIXBtdFBhcnNlZCkge1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coJ3JlcGFyc2UgZnJvbSBiZWdpbm5pbmcnKTtcclxuICAgICAgICAgICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIC8vIHdlIHNldCBpdCB0byAtMTg4LCB0aGUgKz0gMTg4IGluIHRoZSBmb3IgbG9vcCB3aWxsIHJlc2V0IHN0YXJ0IHRvIDBcclxuICAgICAgICAgICAgICBzdGFydCA9IC0xODg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMTc6XHJcbiAgICAgICAgICBjYXNlIDB4MWZmZjpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB1bmtub3duUElEcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdUUyBwYWNrZXQgZGlkIG5vdCBzdGFydCB3aXRoIDB4NDcnfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHRyeSB0byBwYXJzZSBsYXN0IFBFUyBwYWNrZXRzXHJcbiAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XHJcbiAgICAgIHBhcnNlQVZDUEVTKHBlcyx0cnVlKTtcclxuICAgICAgYXZjVHJhY2sucGVzRGF0YSA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXHJcbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBhdmNEYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XHJcbiAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XHJcbiAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJzZU1QRUdQRVMocGVzKTtcclxuICAgICAgfVxyXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGF1ZGlvRGF0YSAmJiBhdWRpb0RhdGEuc2l6ZSkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ2xhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHMnKTtcclxuICAgICAgfVxyXG4gICAgIC8vIGVpdGhlciBhdWRpb0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xyXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xyXG4gICAgICBwYXJzZUlEM1BFUyhwZXMpO1xyXG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGVpdGhlciBpZDNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcclxuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc2FtcGxlQWVzID09IG51bGwpIHtcclxuICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIGF2Y1RyYWNrLCBpZDNUcmFjaywgdGhpcy5fdHh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRlY3J5cHRBbmRSZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVjcnlwdEFuZFJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xyXG4gICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcyAmJiBhdWRpb1RyYWNrLmlzQUFDKSB7XHJcbiAgICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xyXG4gICAgICB0aGlzLnNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QW5kUmVtdXhBdmMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVjcnlwdEFuZFJlbXV4QXZjKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xyXG4gICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xyXG4gICAgICBsZXQgbG9jYWx0aGlzID0gdGhpcztcclxuICAgICAgdGhpcy5zYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbG9jYWx0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcclxuICB9XHJcblxyXG4gIF9wYXJzZVBBVChkYXRhLCBvZmZzZXQpIHtcclxuICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcclxuICAgIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XHJcbiAgICAvL2xvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XHJcbiAgfVxyXG5cclxuICBfcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCBtcGVnU3VwcG9ydGVkLCBpc1NhbXBsZUFlcykge1xyXG4gICAgdmFyIHNlY3Rpb25MZW5ndGgsIHRhYmxlRW5kLCBwcm9ncmFtSW5mb0xlbmd0aCwgcGlkLCByZXN1bHQgPSB7IGF1ZGlvIDogLTEsIGF2YyA6IC0xLCBpZDMgOiAtMSwgaXNBQUMgOiB0cnVlfTtcclxuICAgIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xyXG4gICAgdGFibGVFbmQgPSBvZmZzZXQgKyAzICsgc2VjdGlvbkxlbmd0aCAtIDQ7XHJcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XHJcbiAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXHJcbiAgICBwcm9ncmFtSW5mb0xlbmd0aCA9IChkYXRhW29mZnNldCArIDEwXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcclxuICAgIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcclxuICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xyXG4gICAgd2hpbGUgKG9mZnNldCA8IHRhYmxlRW5kKSB7XHJcbiAgICAgIHBpZCA9IChkYXRhW29mZnNldCArIDFdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XHJcbiAgICAgIHN3aXRjaChkYXRhW29mZnNldF0pIHtcclxuICAgICAgICBjYXNlIDB4Y2Y6ICAgICAvLyBTQU1QTEUtQUVTIEFBQ1xyXG4gICAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyAgKyBkYXRhW29mZnNldF0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuXHJcbiAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXHJcbiAgICAgICAgY2FzZSAweDBmOlxyXG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdBQUMgUElEOicgICsgcGlkKTtcclxuICAgICAgICAgIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXHJcbiAgICAgICAgY2FzZSAweDE1OlxyXG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcclxuICAgICAgICAgIGlmIChyZXN1bHQuaWQzID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMHhkYjogICAgIC8vIFNBTVBMRS1BRVMgQVZDXHJcbiAgICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3Vua293biBzdHJlYW0gdHlwZTonICArIGRhdGFbb2Zmc2V0XSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG5cclxuICAgICAgICAvLyBJVFUtVCBSZWMuIEguMjY0IGFuZCBJU08vSUVDIDE0NDk2LTEwIChsb3dlciBiaXQtcmF0ZSB2aWRlbylcclxuICAgICAgICBjYXNlIDB4MWI6XHJcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xyXG4gICAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hdmMgPSBwaWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXHJcbiAgICAgICAgLy8gb3IgSVNPL0lFQyAxMzgxOC0zIChNUEVHLTIgaGFsdmVkIHNhbXBsZSByYXRlIGF1ZGlvKVxyXG4gICAgICAgIGNhc2UgMHgwMzpcclxuICAgICAgICBjYXNlIDB4MDQ6XHJcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ01QRUcgUElEOicgICsgcGlkKTtcclxuICAgICAgICAgIGlmICghbXBlZ1N1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdNUEVHIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciBmb3Igbm93Jyk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xyXG4gICAgICAgICAgICByZXN1bHQuaXNBQUMgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDB4MjQ6XHJcbiAgICAgICAgICBsb2dnZXIud2FybignSEVWQyBzdHJlYW0gdHlwZSBmb3VuZCwgbm90IHN1cHBvcnRlZCBmb3Igbm93Jyk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ3Vua293biBzdHJlYW0gdHlwZTonICArIGRhdGFbb2Zmc2V0XSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XHJcbiAgICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcclxuICAgICAgb2Zmc2V0ICs9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBkYXRhW29mZnNldCArIDRdKSArIDU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgX3BhcnNlUEVTKHN0cmVhbSkge1xyXG4gICAgdmFyIGkgPSAwLCBmcmFnLCBwZXNGbGFncywgcGVzUHJlZml4LCBwZXNMZW4sIHBlc0hkckxlbiwgcGVzRGF0YSwgcGVzUHRzLCBwZXNEdHMsIHBheWxvYWRTdGFydE9mZnNldCwgZGF0YSA9IHN0cmVhbS5kYXRhO1xyXG4gICAgLy8gc2FmZXR5IGNoZWNrXHJcbiAgICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxyXG4gICAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXHJcbiAgICAvLyB1c3VhbGx5IG9ubHkgb25lIG1lcmdlIGlzIG5lZWRlZCAoYW5kIHRoaXMgaXMgcmFyZSAuLi4pXHJcbiAgICB3aGlsZShkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xyXG4gICAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFbMF0ubGVuZ3RoICsgZGF0YVsxXS5sZW5ndGgpO1xyXG4gICAgICBuZXdEYXRhLnNldChkYXRhWzBdKTtcclxuICAgICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xyXG4gICAgICBkYXRhWzBdID0gbmV3RGF0YTtcclxuICAgICAgZGF0YS5zcGxpY2UoMSwxKTtcclxuICAgIH1cclxuICAgIC8vcmV0cmlldmUgUFRTL0RUUyBmcm9tIGZpcnN0IGZyYWdtZW50XHJcbiAgICBmcmFnID0gZGF0YVswXTtcclxuICAgIHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcclxuICAgIGlmIChwZXNQcmVmaXggPT09IDEpIHtcclxuICAgICAgcGVzTGVuID0gKGZyYWdbNF0gPDwgOCkgKyBmcmFnWzVdO1xyXG4gICAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXHJcbiAgICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcclxuICAgICAgaWYgKHBlc0xlbiAmJiBwZXNMZW4gPiBzdHJlYW0uc2l6ZSAtIDYpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBwZXNGbGFncyA9IGZyYWdbN107XHJcbiAgICAgIGlmIChwZXNGbGFncyAmIDB4QzApIHtcclxuICAgICAgICAvKiBQRVMgaGVhZGVyIGRlc2NyaWJlZCBoZXJlIDogaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcclxuICAgICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXHJcbiAgICAgICAgICAgIGFzIEJpdHdpc2Ugb3BlcmF0b3JzIHRyZWF0IHRoZWlyIG9wZXJhbmRzIGFzIGEgc2VxdWVuY2Ugb2YgMzIgYml0cyAqL1xyXG4gICAgICAgIHBlc1B0cyA9IChmcmFnWzldICYgMHgwRSkgKiA1MzY4NzA5MTIgKy8vIDEgPDwgMjlcclxuICAgICAgICAgIChmcmFnWzEwXSAmIDB4RkYpICogNDE5NDMwNCArLy8gMSA8PCAyMlxyXG4gICAgICAgICAgKGZyYWdbMTFdICYgMHhGRSkgKiAxNjM4NCArLy8gMSA8PCAxNFxyXG4gICAgICAgICAgKGZyYWdbMTJdICYgMHhGRikgKiAxMjggKy8vIDEgPDwgN1xyXG4gICAgICAgICAgKGZyYWdbMTNdICYgMHhGRSkgLyAyO1xyXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcclxuICAgICAgICAgIGlmIChwZXNQdHMgPiA0Mjk0OTY3Mjk1KSB7XHJcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCAyXjMzXHJcbiAgICAgICAgICAgIHBlc1B0cyAtPSA4NTg5OTM0NTkyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGlmIChwZXNGbGFncyAmIDB4NDApIHtcclxuICAgICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MEUgKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxyXG4gICAgICAgICAgICAoZnJhZ1sxNV0gJiAweEZGICkgKiA0MTk0MzA0ICsvLyAxIDw8IDIyXHJcbiAgICAgICAgICAgIChmcmFnWzE2XSAmIDB4RkUgKSAqIDE2Mzg0ICsvLyAxIDw8IDE0XHJcbiAgICAgICAgICAgIChmcmFnWzE3XSAmIDB4RkYgKSAqIDEyOCArLy8gMSA8PCA3XHJcbiAgICAgICAgICAgIChmcmFnWzE4XSAmIDB4RkUgKSAvIDI7XHJcbiAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxyXG4gICAgICAgICAgaWYgKHBlc0R0cyA+IDQyOTQ5NjcyOTUpIHtcclxuICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcclxuICAgICAgICAgICAgcGVzRHRzIC09IDg1ODk5MzQ1OTI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGVzUHRzIC0gcGVzRHRzID4gNjAqOTAwMDApIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYCR7TWF0aC5yb3VuZCgocGVzUHRzIC0gcGVzRHRzKS85MDAwMCl9cyBkZWx0YSBiZXR3ZWVuIFBUUyBhbmQgRFRTLCBhbGlnbiB0aGVtYCk7XHJcbiAgICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xyXG4gICAgICAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cclxuICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gcGVzSGRyTGVuICsgOTtcclxuXHJcbiAgICAgIHN0cmVhbS5zaXplIC09IHBheWxvYWRTdGFydE9mZnNldDtcclxuICAgICAgLy9yZWFzc2VtYmxlIFBFUyBwYWNrZXRcclxuICAgICAgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcclxuICAgICAgZm9yKCBsZXQgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW4gOyBqKyspIHtcclxuICAgICAgICBmcmFnID0gZGF0YVtqXTtcclxuICAgICAgICBsZXQgbGVuID0gZnJhZy5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcclxuICAgICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQgPiBsZW4pIHtcclxuICAgICAgICAgICAgLy8gdHJpbSBmdWxsIGZyYWcgaWYgUEVTIGhlYWRlciBiaWdnZXIgdGhhbiBmcmFnXHJcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldC09bGVuO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcclxuICAgICAgICAgICAgZnJhZyA9IGZyYWcuc3ViYXJyYXkocGF5bG9hZFN0YXJ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgbGVuLT1wYXlsb2FkU3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xyXG4gICAgICAgIGkrPWxlbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAocGVzTGVuKSB7XHJcbiAgICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXHJcbiAgICAgICAgcGVzTGVuIC09IHBlc0hkckxlbiszO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7ZGF0YTogcGVzRGF0YSwgcHRzOiBwZXNQdHMsIGR0czogcGVzRHRzLCBsZW46IHBlc0xlbn07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLGF2Y1RyYWNrKSB7XHJcbiAgICBpZiAoYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCAmJiBhdmNTYW1wbGUuZnJhbWUpIHtcclxuICAgICAgY29uc3Qgc2FtcGxlcyA9IGF2Y1RyYWNrLnNhbXBsZXM7XHJcbiAgICAgIGNvbnN0IG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xyXG4gICAgICAvLyBvbmx5IHB1c2ggQVZDIHNhbXBsZSBpZiBzdGFydGluZyB3aXRoIGEga2V5ZnJhbWUgaXMgbm90IG1hbmRhdG9yeSBPUlxyXG4gICAgICAvLyAgICBpZiBrZXlmcmFtZSBhbHJlYWR5IGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgT1JcclxuICAgICAgLy8gICAgICAga2V5ZnJhbWUgZm91bmQgaW4gbGFzdCBmcmFnbWVudCAodHJhY2suc3BzKSBBTkRcclxuICAgICAgLy8gICAgICAgICAgc2FtcGxlcyBhbHJlYWR5IGFwcGVuZGVkICh3ZSBhbHJlYWR5IGZvdW5kIGEga2V5ZnJhbWUgaW4gdGhpcyBmcmFnbWVudCkgT1IgZnJhZ21lbnQgaXMgY29udGlndW91c1xyXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkgfHxcclxuICAgICAgICAgIGF2Y1NhbXBsZS5rZXkgPT09IHRydWUgfHxcclxuICAgICAgICAgIChhdmNUcmFjay5zcHMgJiYgKG5iU2FtcGxlcyB8fCB0aGlzLmNvbnRpZ3VvdXMpKSkge1xyXG4gICAgICAgIGF2Y1NhbXBsZS5pZCA9IG5iU2FtcGxlcztcclxuICAgICAgICBzYW1wbGVzLnB1c2goYXZjU2FtcGxlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBkcm9wcGVkIHNhbXBsZXMsIHRyYWNrIGl0XHJcbiAgICAgICAgYXZjVHJhY2suZHJvcHBlZCsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihhdmNTYW1wbGUuZGVidWcubGVuZ3RoKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYXZjU2FtcGxlLnB0cyArICcvJyArIGF2Y1NhbXBsZS5kdHMgKyAnOicgKyBhdmNTYW1wbGUuZGVidWcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3BhcnNlQVZDUEVTKHBlcyxsYXN0KSB7XHJcbiAgICAvL2xvZ2dlci5sb2coJ3BhcnNlIG5ldyBQRVMnKTtcclxuICAgIHZhciB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxyXG4gICAgICAgIHVuaXRzID0gdGhpcy5fcGFyc2VBVkNOQUx1KHBlcy5kYXRhKSxcclxuICAgICAgICBkZWJ1ZyA9IGZhbHNlLFxyXG4gICAgICAgIGV4cEdvbG9tYkRlY29kZXIsXHJcbiAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsXHJcbiAgICAgICAgcHVzaCxcclxuICAgICAgICBpO1xyXG4gICAgLy9mcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcclxuICAgIHBlcy5kYXRhID0gbnVsbDtcclxuXHJcbiAgICB1bml0cy5mb3JFYWNoKHVuaXQgPT4ge1xyXG4gICAgICBzd2l0Y2godW5pdC50eXBlKSB7XHJcbiAgICAgICAgLy9ORFJcclxuICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgIHB1c2ggPSB0cnVlO1xyXG4gICAgICAgICAgIGlmKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xyXG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ05EUiAnO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xyXG4gICAgICAgICAgIC8vIHJldHJpZXZlIHNsaWNlIHR5cGUgYnkgcGFyc2luZyBiZWdpbm5pbmcgb2YgTkFMIHVuaXQgKGZvbGxvdyBIMjY0IHNwZWMsIHNsaWNlX2hlYWRlciBkZWZpbml0aW9uKSB0byBkZXRlY3Qga2V5ZnJhbWUgZW1iZWRkZWQgaW4gTkRSXHJcbiAgICAgICAgICAgbGV0IGRhdGEgPSB1bml0LmRhdGE7XHJcbiAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICAgbGV0IHNsaWNlVHlwZSA9IG5ldyBFeHBHb2xvbWIoZGF0YSkucmVhZFNsaWNlVHlwZSgpO1xyXG4gICAgICAgICAgICAgLy8gMiA6IEkgc2xpY2UsIDQgOiBTSSBzbGljZSwgNyA6IEkgc2xpY2UsIDk6IFNJIHNsaWNlXHJcbiAgICAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxyXG4gICAgICAgICAgICAgLy8gQW4gU0kgc2xpY2UgY2FuIGJlIGNvZGVkIHN1Y2ggdGhhdCBpdHMgZGVjb2RlZCBzYW1wbGVzIGNhbiBiZSBjb25zdHJ1Y3RlZCBpZGVudGljYWxseSB0byBhbiBTUCBzbGljZS5cclxuICAgICAgICAgICAgIC8vIEkgc2xpY2U6IEEgc2xpY2UgdGhhdCBpcyBub3QgYW4gU0kgc2xpY2UgdGhhdCBpcyBkZWNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seS5cclxuICAgICAgICAgICAgIC8vaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcclxuICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcclxuICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5rZXkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvL0lEUlxyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xyXG4gICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcclxuICAgICAgICAgIGlmICghYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gdGhpcy5fY3JlYXRlQVZDU2FtcGxlKHRydWUscGVzLnB0cyxwZXMuZHRzLCcnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKGRlYnVnKSB7XHJcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnSURSICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcclxuICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvL1NFSVxyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xyXG4gICAgICAgICAgaWYoZGVidWcgJiYgYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU0VJICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih0aGlzLmRpc2NhcmRFUEIodW5pdC5kYXRhKSk7XHJcblxyXG4gICAgICAgICAgLy8gc2tpcCBmcmFtZVR5cGVcclxuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcblxyXG4gICAgICAgICAgdmFyIHBheWxvYWRUeXBlID0gMDtcclxuICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IDA7XHJcbiAgICAgICAgICB2YXIgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xyXG4gICAgICAgICAgdmFyIGIgPSAwO1xyXG5cclxuICAgICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xyXG4gICAgICAgICAgICBwYXlsb2FkVHlwZSA9IDA7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcclxuICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XHJcblxyXG4gICAgICAgICAgICAvLyBQYXJzZSBwYXlsb2FkIHNpemUuXHJcbiAgICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIHBheWxvYWQgaW4gYW4gU0VJIHBhY2tldC4uLlxyXG4gICAgICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHJlYWQgdHlwZSBhbmQgc2l6ZSBpbiBhIHdoaWxlIGxvb3AgdG8gZ2V0IHRoZW0gYWxsXHJcbiAgICAgICAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlICE9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyQ29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVTaG9ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB1c2VyU3RydWN0dXJlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFUeXBlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbENDcyA9IDMxICYgZmlyc3RCeXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVBcnJheSA9IFtmaXJzdEJ5dGUsIHNlY29uZEJ5dGVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENDczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0U2FtcGxlSW5PcmRlcih0aGlzLl90eHRUcmFjay5zYW1wbGVzLCB7IHR5cGU6IDMsIHB0czogcGVzLnB0cywgYnl0ZXM6IGJ5dGVBcnJheSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF5bG9hZFNpemUgPCBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaTxwYXlsb2FkU2l6ZTsgaSsrKVxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvL1NQU1xyXG4gICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xyXG4gICAgICAgICAgaWYoZGVidWcgJiYgYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU1BTICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZighdHJhY2suc3BzKSB7XHJcbiAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHVuaXQuZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcclxuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XHJcbiAgICAgICAgICAgIHRyYWNrLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRyYWNrLnBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XHJcbiAgICAgICAgICAgIHRyYWNrLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XHJcbiAgICAgICAgICAgIHZhciBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xyXG4gICAgICAgICAgICB2YXIgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy9QUFNcclxuICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcclxuICAgICAgICAgIGlmKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xyXG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1BQUyAnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcclxuICAgICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBBVURcclxuICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XHJcbiAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsdHJhY2spO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSB0aGlzLl9jcmVhdGVBVkNTYW1wbGUoZmFsc2UscGVzLnB0cyxwZXMuZHRzLGRlYnVnID8gJ0FVRCAnOiAnJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBGaWxsZXIgRGF0YVxyXG4gICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xyXG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ3Vua25vd24gTkFMICcgKyB1bml0LnR5cGUgKyAnICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZihhdmNTYW1wbGUgJiYgcHVzaCkge1xyXG4gICAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcclxuICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXHJcbiAgICBpZiAobGFzdCAmJiBhdmNTYW1wbGUpIHtcclxuICAgICAgdGhpcy5wdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSx0cmFjayk7XHJcbiAgICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jcmVhdGVBVkNTYW1wbGUoa2V5LHB0cyxkdHMsZGVidWcpIHtcclxuICAgIHJldHVybiB7IGtleSA6IGtleSwgcHRzIDogcHRzLCBkdHMgOiBkdHMsIHVuaXRzIDogW10sIGRlYnVnIDogZGVidWd9O1xyXG4gIH1cclxuXHJcbiAgX2luc2VydFNhbXBsZUluT3JkZXIoYXJyLCBkYXRhKSB7XHJcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGlmIChsZW4gPiAwKSB7XHJcbiAgICAgIGlmIChkYXRhLnB0cyA+PSBhcnJbbGVuLTFdLnB0cylcclxuICAgICAge1xyXG4gICAgICAgIGFyci5wdXNoKGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAodmFyIHBvcyA9IGxlbiAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xyXG4gICAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XHJcbiAgICAgICAgICAgIGFyci5zcGxpY2UocG9zLCAwLCBkYXRhKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgYXJyLnB1c2goZGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZ2V0TGFzdE5hbFVuaXQoKSB7XHJcbiAgICBsZXQgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsIGxhc3RVbml0O1xyXG4gICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxyXG4gICAgaWYgKCFhdmNTYW1wbGUgfHwgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XHJcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGgtMV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXZjU2FtcGxlKSB7XHJcbiAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcclxuICAgICAgbGFzdFVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBsYXN0VW5pdDtcclxuICB9XHJcblxyXG4gIF9wYXJzZUFWQ05BTHUoYXJyYXkpIHtcclxuICAgIHZhciBpID0gMCwgbGVuID0gYXJyYXkuYnl0ZUxlbmd0aCwgdmFsdWUsIG92ZXJmbG93LCB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBzdGF0ZSA9IHRyYWNrLm5hbHVTdGF0ZSB8fCAwLCBsYXN0U3RhdGUgPSBzdGF0ZTtcclxuICAgIHZhciB1bml0cyA9IFtdLCB1bml0LCB1bml0VHlwZSwgbGFzdFVuaXRTdGFydCA9IC0xLCBsYXN0VW5pdFR5cGU7XHJcbiAgICAvL2xvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcclxuXHJcbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XHJcbiAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XHJcbiAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xyXG4gICAgICAvLyBOQUx1IHR5cGUgaXMgdmFsdWUgcmVhZCBmcm9tIG9mZnNldCAwXHJcbiAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcclxuICAgICAgc3RhdGUgPSAwO1xyXG4gICAgICBpID0gMTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XHJcbiAgICAgIC8vIG9wdGltaXphdGlvbi4gc3RhdGUgMCBhbmQgMSBhcmUgdGhlIHByZWRvbWluYW50IGNhc2UuIGxldCdzIGhhbmRsZSB0aGVtIG91dHNpZGUgb2YgdGhlIHN3aXRjaC9jYXNlXHJcbiAgICAgIGlmICghc3RhdGUpIHtcclxuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XHJcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAyO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGhlcmUgd2UgaGF2ZSBzdGF0ZSBlaXRoZXIgZXF1YWwgdG8gMiBvciAzXHJcbiAgICAgIGlmKCF2YWx1ZSkge1xyXG4gICAgICAgIHN0YXRlID0gMztcclxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49MCkge1xyXG4gICAgICAgICAgdW5pdCA9IHtkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBpIC0gc3RhdGUgLSAxKSwgdHlwZTogbGFzdFVuaXRUeXBlfTtcclxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGxhc3RVbml0U3RhcnQgaXMgdW5kZWZpbmVkID0+IHRoaXMgaXMgdGhlIGZpcnN0IHN0YXJ0IGNvZGUgZm91bmQgaW4gdGhpcyBQRVMgcGFja2V0XHJcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXHJcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXHJcbiAgICAgICAgICAvLyBhbmQgZW5kZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIFBFUyBwYWNrZXQgKGkgPD0gNCAtIGxhc3RTdGF0ZSlcclxuICAgICAgICAgIGxldCBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XHJcbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcclxuICAgICAgICAgICAgaWYobGFzdFN0YXRlICYmICAoaSA8PSA0IC0gbGFzdFN0YXRlKSkge1xyXG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXHJcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXHJcbiAgICAgICAgICAgICAgaWYgKGxhc3RVbml0LnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsYXN0IGJ5dGVzXHJcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cclxuICAgICAgICAgICAgb3ZlcmZsb3cgID0gaSAtIHN0YXRlIC0gMTtcclxuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xyXG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XHJcbiAgICAgICAgICAgICAgbGV0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIG92ZXJmbG93KTtcclxuICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xyXG4gICAgICAgICAgICAgIHRtcC5zZXQoYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXHJcbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgIHVuaXRUeXBlID0gYXJyYXlbaV0gJiAweDFmO1xyXG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcclxuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xyXG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XHJcbiAgICAgICAgICBzdGF0ZSA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXHJcbiAgICAgICAgICBzdGF0ZSA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdGF0ZSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49MCAmJiBzdGF0ZSA+PTApIHtcclxuICAgICAgdW5pdCA9IHtkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLCB0eXBlOiBsYXN0VW5pdFR5cGUsIHN0YXRlIDogc3RhdGV9O1xyXG4gICAgICB1bml0cy5wdXNoKHVuaXQpO1xyXG4gICAgICAvL2xvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcclxuICAgIH1cclxuICAgIC8vIG5vIE5BTHUgZm91bmRcclxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XHJcbiAgICAgIGxldCAgbGFzdFVuaXQgPSB0aGlzLl9nZXRMYXN0TmFsVW5pdCgpO1xyXG4gICAgICBpZiAobGFzdFVuaXQpIHtcclxuICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgYXJyYXkuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcclxuICAgICAgICB0bXAuc2V0KGFycmF5LCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xyXG4gICAgcmV0dXJuIHVuaXRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXHJcbiAgICovXHJcbiAgZGlzY2FyZEVQQihkYXRhKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoLFxyXG4gICAgICAgIEVQQlBvc2l0aW9ucyA9IFtdLFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIG5ld0xlbmd0aCwgbmV3RGF0YTtcclxuXHJcbiAgICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXHJcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcclxuICAgICAgaWYgKGRhdGFbaV0gPT09IDAgJiZcclxuICAgICAgICAgIGRhdGFbaSArIDFdID09PSAwICYmXHJcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xyXG4gICAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcclxuICAgICAgICBpICs9IDI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcclxuICAgIC8vIGFycmF5XHJcbiAgICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxyXG4gICAgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcclxuICAgIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xyXG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcclxuICAgICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcclxuICAgICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxyXG4gICAgICAgIHNvdXJjZUluZGV4Kys7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcclxuICAgICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcclxuICAgICAgfVxyXG4gICAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3RGF0YTtcclxuICB9XHJcblxyXG4gIF9wYXJzZUFBQ1BFUyhwZXMpIHtcclxuICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssXHJcbiAgICAgICAgZGF0YSA9IHBlcy5kYXRhLFxyXG4gICAgICAgIHB0cyA9IHBlcy5wdHMsXHJcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwLFxyXG4gICAgICAgIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdyxcclxuICAgICAgICBhYWNMYXN0UFRTID0gdGhpcy5hYWNMYXN0UFRTLFxyXG4gICAgICAgIGNvbmZpZywgZnJhbWVMZW5ndGgsIGZyYW1lRHVyYXRpb24sIGZyYW1lSW5kZXgsIG9mZnNldCwgaGVhZGVyTGVuZ3RoLCBzdGFtcCwgbGVuLCBhYWNTYW1wbGU7XHJcbiAgICBpZiAoYWFjT3ZlckZsb3cpIHtcclxuICAgICAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KGFhY092ZXJGbG93LmJ5dGVMZW5ndGggKyBkYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICB0bXAuc2V0KGFhY092ZXJGbG93LCAwKTtcclxuICAgICAgdG1wLnNldChkYXRhLCBhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoKTtcclxuICAgICAgLy9sb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke2FhY092ZXJGbG93LmJ5dGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XHJcbiAgICAgIGRhdGEgPSB0bXA7XHJcbiAgICB9XHJcbiAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxyXG4gICAgZm9yIChvZmZzZXQgPSBzdGFydE9mZnNldCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XHJcbiAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoZGF0YVtvZmZzZXQrMV0gJiAweGYwKSA9PT0gMHhmMCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxyXG4gICAgaWYgKG9mZnNldCkge1xyXG4gICAgICB2YXIgcmVhc29uLCBmYXRhbDtcclxuICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcclxuICAgICAgICByZWFzb24gPSBgQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OiR7b2Zmc2V0fWA7XHJcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWFzb24gPSAnbm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XHJcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZ2dlci53YXJuKGBwYXJzaW5nIGVycm9yOiR7cmVhc29ufWApO1xyXG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmF0YWwsIHJlYXNvbjogcmVhc29ufSk7XHJcbiAgICAgIGlmIChmYXRhbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XHJcbiAgICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSB0aGlzLmF1ZGlvQ29kZWM7XHJcbiAgICAgIGNvbmZpZyA9IEFEVFMuZ2V0QXVkaW9Db25maWcodGhpcy5vYnNlcnZlcixkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xyXG4gICAgICB0cmFjay5jb25maWcgPSBjb25maWcuY29uZmlnO1xyXG4gICAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XHJcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XHJcbiAgICAgIHRyYWNrLmNvZGVjID0gY29uZmlnLmNvZGVjO1xyXG4gICAgICB0cmFjay5tYW5pZmVzdENvZGVjID0gY29uZmlnLm1hbmlmZXN0Q29kZWM7XHJcbiAgICAgIGxvZ2dlci5sb2coYHBhcnNlZCBjb2RlYzoke3RyYWNrLmNvZGVjfSxyYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LG5iIGNoYW5uZWw6JHtjb25maWcuY2hhbm5lbENvdW50fWApO1xyXG4gICAgfVxyXG4gICAgZnJhbWVJbmRleCA9IDA7XHJcbiAgICBmcmFtZUR1cmF0aW9uID0gMTAyNCAqIDkwMDAwIC8gdHJhY2suc2FtcGxlcmF0ZTtcclxuXHJcbiAgICAvLyBpZiBsYXN0IEFBQyBmcmFtZSBpcyBvdmVyZmxvd2luZywgd2Ugc2hvdWxkIGVuc3VyZSB0aW1lc3RhbXBzIGFyZSBjb250aWd1b3VzOlxyXG4gICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxyXG4gICAgaWYoYWFjT3ZlckZsb3cgJiYgYWFjTGFzdFBUUykge1xyXG4gICAgICB2YXIgbmV3UFRTID0gYWFjTGFzdFBUUytmcmFtZUR1cmF0aW9uO1xyXG4gICAgICBpZihNYXRoLmFicyhuZXdQVFMtcHRzKSA+IDEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBBQUM6IGFsaWduIFBUUyBmb3Igb3ZlcmxhcHBpbmcgZnJhbWVzIGJ5ICR7TWF0aC5yb3VuZCgobmV3UFRTLXB0cykvOTApfWApO1xyXG4gICAgICAgIHB0cz1uZXdQVFM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoKG9mZnNldCArIDUpIDwgbGVuKSB7XHJcbiAgICAgIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxyXG4gICAgICBoZWFkZXJMZW5ndGggPSAoISEoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEpID8gNyA6IDkpO1xyXG4gICAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXHJcbiAgICAgIGZyYW1lTGVuZ3RoID0gKChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEpIHxcclxuICAgICAgICAgICAgICAgICAgICAgKGRhdGFbb2Zmc2V0ICsgNF0gPDwgMykgfFxyXG4gICAgICAgICAgICAgICAgICAgICgoZGF0YVtvZmZzZXQgKyA1XSAmIDB4RTApID4+PiA1KTtcclxuICAgICAgZnJhbWVMZW5ndGggIC09IGhlYWRlckxlbmd0aDtcclxuICAgICAgLy9zdGFtcCA9IHBlcy5wdHM7XHJcblxyXG4gICAgICBpZiAoKGZyYW1lTGVuZ3RoID4gMCkgJiYgKChvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCkgPD0gbGVuKSkge1xyXG4gICAgICAgIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgLy9sb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xyXG4gICAgICAgIGFhY1NhbXBsZSA9IHt1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wfTtcclxuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjU2FtcGxlKTtcclxuICAgICAgICB0cmFjay5sZW4gKz0gZnJhbWVMZW5ndGg7XHJcbiAgICAgICAgb2Zmc2V0ICs9IGZyYW1lTGVuZ3RoICsgaGVhZGVyTGVuZ3RoO1xyXG4gICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxyXG4gICAgICAgIGZvciAoIDsgb2Zmc2V0IDwgKGxlbiAtIDEpOyBvZmZzZXQrKykge1xyXG4gICAgICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmICgoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjApID09PSAweGYwKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcclxuICAgICAgYWFjT3ZlckZsb3cgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgbGVuKTtcclxuICAgICAgLy9sb2dnZXIubG9nKGBBQUM6IG92ZXJmbG93IGRldGVjdGVkOiR7bGVuLW9mZnNldH1gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFhY092ZXJGbG93ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBhYWNPdmVyRmxvdztcclxuICAgIHRoaXMuYWFjTGFzdFBUUyA9IHN0YW1wO1xyXG4gIH1cclxuXHJcbiAgX3BhcnNlTVBFR1BFUyhwZXMpIHtcclxuICAgIE1wZWdBdWRpby5wYXJzZSh0aGlzLl9hdWRpb1RyYWNrLCBwZXMuZGF0YSwgMCwgcGVzLnB0cyk7XHJcbiAgfVxyXG5cclxuICBfcGFyc2VJRDNQRVMocGVzKSB7XHJcbiAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRTRGVtdXhlcjtcclxuIiwiZXhwb3J0IGNvbnN0IEVycm9yVHlwZXMgPSB7XHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBuZXR3b3JrIGVycm9yIChsb2FkaW5nIGVycm9yIC8gdGltZW91dCAuLi4pXHJcbiAgTkVUV09SS19FUlJPUjogJ25ldHdvcmtFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcclxuICBNRURJQV9FUlJPUjogJ21lZGlhRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbXV4IEVycm9yIChkZW11eGluZy9yZW11eGluZylcclxuICBNVVhfRVJST1I6ICdtdXhFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYWxsIG90aGVyIGVycm9yc1xyXG4gIE9USEVSX0VSUk9SOiAnb3RoZXJFcnJvcidcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBFcnJvckRldGFpbHMgPSB7XHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIE1BTklGRVNUX0xPQURfRVJST1I6ICdtYW5pZmVzdExvYWRFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XHJcbiAgTUFOSUZFU1RfTE9BRF9USU1FT1VUOiAnbWFuaWZlc3RMb2FkVGltZU91dCcsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XHJcbiAgTUFOSUZFU1RfUEFSU0lOR19FUlJPUjogJ21hbmlmZXN0UGFyc2luZ0Vycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHdpdGggb25seSBpbmNvbXBhdGlibGUgY29kZWNzIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XHJcbiAgTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUjogJ21hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cclxuICBMRVZFTF9MT0FEX0VSUk9SOiAnbGV2ZWxMb2FkRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIExFVkVMX0xPQURfVElNRU9VVDogJ2xldmVsTG9hZFRpbWVPdXQnLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgc3dpdGNoIGVycm9yIC0gZGF0YTogeyBsZXZlbCA6IGZhdWx0eSBsZXZlbCBJZCwgZXZlbnQgOiBlcnJvciBkZXNjcmlwdGlvbn1cclxuICBMRVZFTF9TV0lUQ0hfRVJST1I6ICdsZXZlbFN3aXRjaEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIEFVRElPX1RSQUNLX0xPQURfRVJST1I6ICdhdWRpb1RyYWNrTG9hZEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XHJcbiAgQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOiAnYXVkaW9UcmFja0xvYWRUaW1lT3V0JyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIEZSQUdfTE9BRF9FUlJPUjogJ2ZyYWdMb2FkRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cclxuICBGUkFHX0xPT1BfTE9BRElOR19FUlJPUjogJ2ZyYWdMb29wTG9hZGluZ0Vycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XHJcbiAgRlJBR19MT0FEX1RJTUVPVVQ6ICdmcmFnTG9hZFRpbWVPdXQnLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgZGVjcnlwdGlvbiBlcnJvciBldmVudCAtIGRhdGE6IHtpZCA6IGRlbXV4ZXIgSWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0LCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cclxuICBGUkFHX0RFQ1JZUFRfRVJST1I6ICdmcmFnRGVjcnlwdEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XHJcbiAgLy8gd2lsbCBiZSByZW5hbWVkIERFTVVYX1BBUlNJTkdfRVJST1IgYW5kIHN3aXRjaGVkIHRvIE1VWF9FUlJPUiBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXHJcbiAgRlJBR19QQVJTSU5HX0VSUk9SOiAnZnJhZ1BhcnNpbmdFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSByZW11eCBhbGxvYyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBieXRlcyA6IG5iIG9mIGJ5dGVzIG9uIHdoaWNoIGFsbG9jYXRpb24gZmFpbGVkICwgcmVhc29uIDogZXJyb3IgdGV4dCB9XHJcbiAgUkVNVVhfQUxMT0NfRVJST1IgOiAncmVtdXhBbGxvY0Vycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIEtFWV9MT0FEX0VSUk9SOiAna2V5TG9hZEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XHJcbiAgS0VZX0xPQURfVElNRU9VVDogJ2tleUxvYWRUaW1lT3V0JyxcclxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBleGNlcHRpb24gb2NjdXJzIHdoaWxlIGFkZGluZyBhIHNvdXJjZUJ1ZmZlciB0byBNZWRpYVNvdXJjZSAtIGRhdGEgOiB7ICBlcnIgOiBleGNlcHRpb24gLCBtaW1lVHlwZSA6IG1pbWVUeXBlIH1cclxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SOiAnYnVmZmVyQWRkQ29kZWNFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kIGVycm9yIC0gZGF0YTogYXBwZW5kIGVycm9yIGRlc2NyaXB0aW9uXHJcbiAgQlVGRkVSX0FQUEVORF9FUlJPUjogJ2J1ZmZlckFwcGVuZEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmRpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBhcHBlbmRpbmcgZXJyb3IgZGVzY3JpcHRpb25cclxuICBCVUZGRVJfQVBQRU5ESU5HX0VSUk9SOiAnYnVmZmVyQXBwZW5kaW5nRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHN0YWxsZWQgZXJyb3IgZXZlbnRcclxuICBCVUZGRVJfU1RBTExFRF9FUlJPUjogJ2J1ZmZlclN0YWxsZWRFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgZnVsbCBldmVudFxyXG4gIEJVRkZFUl9GVUxMX0VSUk9SOiAnYnVmZmVyRnVsbEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzZWVrIG92ZXIgaG9sZSBldmVudFxyXG4gIEJVRkZFUl9TRUVLX09WRVJfSE9MRTogJ2J1ZmZlclNlZWtPdmVySG9sZScsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgbnVkZ2Ugb24gc3RhbGwgKHBsYXliYWNrIGlzIHN0dWNrIGFsdGhvdWdoIGN1cnJlbnRUaW1lIGlzIGluIGEgYnVmZmVyZWQgYXJlYSlcclxuICBCVUZGRVJfTlVER0VfT05fU1RBTEwgOiAnYnVmZmVyTnVkZ2VPblN0YWxsJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcclxuICBJTlRFUk5BTF9FWENFUFRJT046ICdpbnRlcm5hbEV4Y2VwdGlvbicsXHJcbiAgLy8gTWFsZm9ybWVkIFdlYlZUVCBjb250ZW50c1xyXG4gIFdFQlZUVF9FWENFUFRJT046ICd3ZWJWVFRFeGNlcHRpb24nXHJcbn07XHJcbiIsIi8qXHJcbipcclxuKiBBbGwgb2JqZWN0cyBpbiB0aGUgZXZlbnQgaGFuZGxpbmcgY2hhaW4gc2hvdWxkIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzXHJcbipcclxuKi9cclxuXHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuL2Vycm9ycyc7XHJcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cyc7XHJcblxyXG5jbGFzcyBFdmVudEhhbmRsZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMsIC4uLmV2ZW50cykge1xyXG4gICAgdGhpcy5obHMgPSBobHM7XHJcbiAgICB0aGlzLm9uRXZlbnQgPSB0aGlzLm9uRXZlbnQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuaGFuZGxlZEV2ZW50cyA9IGV2ZW50cztcclxuICAgIHRoaXMudXNlR2VuZXJpY0hhbmRsZXIgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGlzRXZlbnRIYW5kbGVyKCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmhhbmRsZWRFdmVudHMgPT09ICdvYmplY3QnICYmIHRoaXMuaGFuZGxlZEV2ZW50cy5sZW5ndGggJiYgdHlwZW9mIHRoaXMub25FdmVudCA9PT0gJ2Z1bmN0aW9uJztcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNFdmVudEhhbmRsZXIoKSkge1xyXG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudCA9PT0gJ2hsc0V2ZW50R2VuZXJpYycpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yYmlkZGVuIGV2ZW50IG5hbWU6ICcgKyBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGxzLm9uKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xyXG4gICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcclxuICAgIGlmICh0aGlzLmlzRXZlbnRIYW5kbGVyKCkpIHtcclxuICAgICAgdGhpcy5oYW5kbGVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmhscy5vZmYoZXZlbnQsIHRoaXMub25FdmVudCk7XHJcbiAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBhcmd1bWVudHM6IGV2ZW50IChzdHJpbmcpLCBkYXRhIChhbnkpXHJcbiAgICovXHJcbiAgb25FdmVudChldmVudCwgZGF0YSkge1xyXG4gICAgdGhpcy5vbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSk7XHJcbiAgfVxyXG5cclxuICBvbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSkge1xyXG4gICAgdmFyIGV2ZW50VG9GdW5jdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgIHZhciBmdW5jTmFtZSA9ICdvbicgKyBldmVudC5yZXBsYWNlKCdobHMnLCAnJyk7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tmdW5jTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50ICR7ZXZlbnR9IGhhcyBubyBnZW5lcmljIGhhbmRsZXIgaW4gdGhpcyAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY2xhc3MgKHRyaWVkICR7ZnVuY05hbWV9KWApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzW2Z1bmNOYW1lXS5iaW5kKHRoaXMsIGRhdGEpO1xyXG4gICAgfTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGV2ZW50VG9GdW5jdGlvbi5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKS5jYWxsKCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKGBpbnRlcm5hbCBlcnJvciBoYXBwZW5lZCB3aGlsZSBwcm9jZXNzaW5nICR7ZXZlbnR9OiR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogZmFsc2UsIGV2ZW50IDogZXZlbnQsIGVyciA6IGVycn0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRXZlbnRIYW5kbGVyO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAvLyBmaXJlZCBiZWZvcmUgTWVkaWFTb3VyY2UgaXMgYXR0YWNoaW5nIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IG1lZGlhIH1cclxuICBNRURJQV9BVFRBQ0hJTkc6ICdobHNNZWRpYUF0dGFjaGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBzdWNjZXNmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XHJcbiAgTUVESUFfQVRUQUNIRUQ6ICdobHNNZWRpYUF0dGFjaGVkJyxcclxuICAvLyBmaXJlZCBiZWZvcmUgZGV0YWNoaW5nIE1lZGlhU291cmNlIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxyXG4gIE1FRElBX0RFVEFDSElORzogJ2hsc01lZGlhRGV0YWNoaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxyXG4gIE1FRElBX0RFVEFDSEVEOiAnaGxzTWVkaWFEZXRhY2hlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiB3ZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXQgLSBkYXRhOiB7IH1cclxuICBCVUZGRVJfUkVTRVQ6ICdobHNCdWZmZXJSZXNldCcsXHJcbiAgLy8gZmlyZWQgd2hlbiB3ZSBrbm93IGFib3V0IHRoZSBjb2RlY3MgdGhhdCB3ZSBuZWVkIGJ1ZmZlcnMgZm9yIHRvIHB1c2ggaW50byAtIGRhdGE6IHt0cmFja3MgOiB7IGNvbnRhaW5lciwgY29kZWMsIGxldmVsQ29kZWMsIGluaXRTZWdtZW50LCBtZXRhZGF0YSB9fVxyXG4gIEJVRkZFUl9DT0RFQ1M6ICdobHNCdWZmZXJDb2RlY3MnLFxyXG4gIC8vIGZpcmVkIHdoZW4gc291cmNlYnVmZmVycyBoYXZlIGJlZW4gY3JlYXRlZCAtIGRhdGE6IHsgdHJhY2tzIDogdHJhY2tzIH1cclxuICBCVUZGRVJfQ1JFQVRFRDogJ2hsc0J1ZmZlckNyZWF0ZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XHJcbiAgQlVGRkVSX0FQUEVORElORzogJ2hsc0J1ZmZlckFwcGVuZGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcmUgZG9uZSB3aXRoIGFwcGVuZGluZyBhIG1lZGlhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcsIHBlbmRpbmcgOiBuYiBvZiBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgZm9yIHRoaXMgc2VnbWVudCBwYXJlbnR9XHJcbiAgQlVGRkVSX0FQUEVOREVEOiAnaGxzQnVmZmVyQXBwZW5kZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhIC0gZGF0YTogeyB9XHJcbiAgQlVGRkVSX0VPUzogJ2hsc0J1ZmZlckVvcycsXHJcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIHNob3VsZCBiZSBmbHVzaGVkIC0gZGF0YSB7IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQgfVxyXG4gIEJVRkZFUl9GTFVTSElORzogJ2hsc0J1ZmZlckZsdXNoaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgaGFzIGJlZW4gZmx1c2hlZCAtIGRhdGE6IHsgfVxyXG4gIEJVRkZFUl9GTFVTSEVEOiAnaGxzQnVmZmVyRmx1c2hlZCcsXHJcbiAgLy8gZmlyZWQgdG8gc2lnbmFsIHRoYXQgYSBtYW5pZmVzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbWFuaWZlc3RVUkx9XHJcbiAgTUFOSUZFU1RfTE9BRElORzogJ2hsc01hbmlmZXN0TG9hZGluZycsXHJcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3NdLCB1cmwgOiBtYW5pZmVzdFVSTCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX19XHJcbiAgTUFOSUZFU1RfTE9BREVEOiAnaGxzTWFuaWZlc3RMb2FkZWQnLFxyXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cclxuICBNQU5JRkVTVF9QQVJTRUQ6ICdobHNNYW5pZmVzdFBhcnNlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH0gLy8gZGVwcmVjYXRlZCBpbiBmYXZvciBMRVZFTF9TV0lUQ0hJTkdcclxuICBMRVZFTF9TV0lUQ0g6ICdobHNMZXZlbFN3aXRjaCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cclxuICBMRVZFTF9TV0lUQ0hJTkc6ICdobHNMZXZlbFN3aXRjaGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyBlZmZlY3RpdmUgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cclxuICBMRVZFTF9TV0lUQ0hFRDogJ2hsc0xldmVsU3dpdGNoZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbGV2ZWwgVVJMLCBsZXZlbCA6IGlkIG9mIGxldmVsIGJlaW5nIGxvYWRlZH1cclxuICBMRVZFTF9MT0FESU5HOiAnaGxzTGV2ZWxMb2FkaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgbG9hZGVkIGxldmVsLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XHJcbiAgTEVWRUxfTE9BREVEOiAnaGxzTGV2ZWxMb2FkZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsIH1cclxuICBMRVZFTF9VUERBVEVEOiAnaGxzTGV2ZWxVcGRhdGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxyXG4gIExFVkVMX1BUU19VUERBVEVEOiAnaGxzTGV2ZWxQdHNVcGRhdGVkJyxcclxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBhdWRpbyB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzIH1cclxuICBBVURJT19UUkFDS1NfVVBEQVRFRDogJ2hsc0F1ZGlvVHJhY2tzVXBkYXRlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggb2NjdXJzIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH0gLy8gZGVwcmVjYXRlZCBpbiBmYXZvciBBVURJT19UUkFDS19TV0lUQ0hJTkdcclxuICBBVURJT19UUkFDS19TV0lUQ0g6ICdobHNBdWRpb1RyYWNrU3dpdGNoJyxcclxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaGluZyBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxyXG4gIEFVRElPX1RSQUNLX1NXSVRDSElORzogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoIGFjdHVhbGx5IG9jY3VycyAtIGRhdGE6IHsgaWQgOiBhdWRpbyB0cmFjayBpZCB9XHJcbiAgQVVESU9fVFJBQ0tfU1dJVENIRUQ6ICdobHNBdWRpb1RyYWNrU3dpdGNoZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGF1ZGlvIHRyYWNrIFVSTCwgaWQgOiBhdWRpbyB0cmFjayBpZCB9XHJcbiAgQVVESU9fVFJBQ0tfTE9BRElORzogJ2hsc0F1ZGlvVHJhY2tMb2FkaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IGF1ZGlvIHRyYWNrIGlkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lIH0gfVxyXG4gIEFVRElPX1RSQUNLX0xPQURFRDogJ2hsc0F1ZGlvVHJhY2tMb2FkZWQnLFxyXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IHN1YnRpdGxlIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgLSBkYXRhOiB7IHN1YnRpdGxlVHJhY2tzIDogc3VidGl0bGVUcmFja3MgfVxyXG4gIFNVQlRJVExFX1RSQUNLU19VUERBVEVEOiAnaGxzU3VidGl0bGVUcmFja3NVcGRhdGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7IGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxyXG4gIFNVQlRJVExFX1RSQUNLX1NXSVRDSDogJ2hsc1N1YnRpdGxlVHJhY2tTd2l0Y2gnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogc3VidGl0bGUgdHJhY2sgVVJMLCBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkIH1cclxuICBTVUJUSVRMRV9UUkFDS19MT0FESU5HOiAnaGxzU3VidGl0bGVUcmFja0xvYWRpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZSB9IH1cclxuICBTVUJUSVRMRV9UUkFDS19MT0FERUQ6ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgZnJhZ21lbnQgaGFzIGJlZW4gcHJvY2Vzc2VkIC0gZGF0YTogeyBzdWNjZXNzIDogYm9vbGVhbiwgZnJhZyA6IHRoZSBwcm9jZXNzZWQgZnJhZyB9XHJcbiAgU1VCVElUTEVfRlJBR19QUk9DRVNTRUQ6ICdobHNTdWJ0aXRsZUZyYWdQcm9jZXNzZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gdGhlIGZpcnN0IHRpbWVzdGFtcCBpcyBmb3VuZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBpbml0UFRTOiBpbml0UFRTLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cclxuICBJTklUX1BUU19GT1VORDogJ2hsc0luaXRQdHNGb3VuZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cclxuICBGUkFHX0xPQURJTkc6ICdobHNGcmFnTG9hZGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgcHJvZ3Jlc3NpbmcgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHsgdHJlcXVlc3QsIHRmaXJzdCwgbG9hZGVkIH0gfVxyXG4gIEZSQUdfTE9BRF9QUk9HUkVTUzogJ2hsc0ZyYWdMb2FkUHJvZ3Jlc3MnLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgYWJvcnRpbmcgZm9yIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XHJcbiAgRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEOiAnaGxzRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aCB9IH1cclxuICBGUkFHX0xPQURFRDogJ2hsc0ZyYWdMb2FkZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBoYXMgZmluaXNoZWQgZGVjcnlwdGluZyAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHN0YXRzIDogeyB0c3RhcnQsIHRkZWNyeXB0IH0gfVxyXG4gIEZSQUdfREVDUllQVEVEOiAnaGxzRnJhZ0RlY3J5cHRlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBJbml0IFNlZ21lbnQgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudCB9XHJcbiAgRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVDogJ2hsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBzZWkgdGV4dCBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBzZWkgc2FtcGxlcyBwZXMgXSB9XHJcbiAgRlJBR19QQVJTSU5HX1VTRVJEQVRBOiAnaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YScsXHJcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIGlkMyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBpZDMgc2FtcGxlcyBwZXMgXSB9XHJcbiAgRlJBR19QQVJTSU5HX01FVEFEQVRBOiAnaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YScsXHJcbiAgLy8gZmlyZWQgd2hlbiBkYXRhIGhhdmUgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cclxuICBGUkFHX1BBUlNJTkdfREFUQTogJ2hsc0ZyYWdQYXJzaW5nRGF0YScsXHJcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBwYXJzaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QgfVxyXG4gIEZSQUdfUEFSU0VEOiAnaGxzRnJhZ1BhcnNlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCByZW11eGVkIE1QNCBib3hlcyBoYXZlIGFsbCBiZWVuIGFwcGVuZGVkIGludG8gU291cmNlQnVmZmVyIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgdHBhcnNlZCwgdGJ1ZmZlcmVkLCBsZW5ndGgsIGJ3RXN0aW1hdGUgfSB9XHJcbiAgRlJBR19CVUZGRVJFRDogJ2hsc0ZyYWdCdWZmZXJlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBtYXRjaGluZyB3aXRoIGN1cnJlbnQgbWVkaWEgcG9zaXRpb24gaXMgY2hhbmdpbmcgLSBkYXRhIDogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxyXG4gIEZSQUdfQ0hBTkdFRDogJ2hsc0ZyYWdDaGFuZ2VkJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIEZQUyBkcm9wIGV2ZW50IC0gZGF0YTogeyBjdXJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzIH1cclxuICBGUFNfRFJPUDogJ2hsc0Zwc0Ryb3AnLFxyXG4gIC8vdHJpZ2dlcmVkIHdoZW4gRlBTIGRyb3AgdHJpZ2dlcnMgYXV0byBsZXZlbCBjYXBwaW5nIC0gZGF0YTogeyBsZXZlbCwgZHJvcHBlZGxldmVsIH1cclxuICBGUFNfRFJPUF9MRVZFTF9DQVBQSU5HOiAnaGxzRnBzRHJvcExldmVsQ2FwcGluZycsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gZXJyb3IgZXZlbnQgLSBkYXRhOiB7IHR5cGUgOiBlcnJvciB0eXBlLCBkZXRhaWxzIDogZXJyb3IgZGV0YWlscywgZmF0YWwgOiBpZiB0cnVlLCBobHMuanMgY2Fubm90L3dpbGwgbm90IHRyeSB0byByZWNvdmVyLCBpZiBmYWxzZSwgaGxzLmpzIHdpbGwgdHJ5IHRvIHJlY292ZXIsb3RoZXIgZXJyb3Igc3BlY2lmaWMgZGF0YSB9XHJcbiAgRVJST1I6ICdobHNFcnJvcicsXHJcbiAgLy8gZmlyZWQgd2hlbiBobHMuanMgaW5zdGFuY2Ugc3RhcnRzIGRlc3Ryb3lpbmcuIERpZmZlcmVudCBmcm9tIE1FRElBX0RFVEFDSEVEIGFzIG9uZSBjb3VsZCB3YW50IHRvIGRldGFjaCBhbmQgcmVhdHRhY2ggYSBtZWRpYSB0byB0aGUgaW5zdGFuY2Ugb2YgaGxzLmpzIHRvIGhhbmRsZSBtaWQtcm9sbHMgZm9yIGV4YW1wbGUgLSBkYXRhOiB7IH1cclxuICBERVNUUk9ZSU5HOiAnaGxzRGVzdHJveWluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cclxuICBLRVlfTE9BRElORzogJ2hsc0tleUxvYWRpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGtleSBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aCB9IH1cclxuICBLRVlfTE9BREVEOiAnaGxzS2V5TG9hZGVkJyxcclxuICAvLyBmaXJlZCB1cG9uIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRyYW5zaXRpb25zIC0gZGF0YTogeyBwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGUgfVxyXG4gIFNUUkVBTV9TVEFURV9UUkFOU0lUSU9OOiAnaGxzU3RyZWFtU3RhdGVUcmFuc2l0aW9uJ1xyXG59O1xyXG4iLCIvKipcclxuICogIEFBQyBoZWxwZXJcclxuICovXHJcblxyXG5jbGFzcyBBQUMge1xyXG4gIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShjb2RlYyxjaGFubmVsQ291bnQpIHtcclxuICAgIHN3aXRjaChjb2RlYykge1xyXG4gICAgICBjYXNlICdtcDRhLjQwLjInOlxyXG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsMHg0MCwweDIyLDB4ODAsMHhhMywweDRlLDB4ZTYsMHg4MCwweGJhLDB4OCwweDAsMHgwLDB4MCwweDFjLDB4NiwweGYxLDB4YzEsMHhhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1ZV0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XHJcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXHJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwweDQwLDB4MjIsMHg4MCwweGEzLDB4NWUsMHhlNiwweDgwLDB4YmEsMHg4LDB4MCwweDAsMHgwLDB4MCwweDk1LDB4MCwweDYsMHhmMSwweGExLDB4YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1ZV0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XHJcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcclxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLDB4NDAsMHgyMiwweDgwLDB4YTMsMHg1ZSwweGU2LDB4ODAsMHhiYSwweDgsMHgwLDB4MCwweDAsMHgwLDB4OTUsMHgwLDB4NiwweGYxLDB4YTEsMHhhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBQUM7XHJcbiIsIi8qKlxyXG4gKiBCdWZmZXIgSGVscGVyIHV0aWxzLCBwcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIGJ1ZmZlciBsZW5ndGggcmV0cmlldmFsXHJcbiovXHJcblxyXG5jb25zdCBCdWZmZXJIZWxwZXIgPSB7XHJcbiAgaXNCdWZmZXJlZCA6IGZ1bmN0aW9uKG1lZGlhLHBvc2l0aW9uKSB7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgbGV0IGJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQ7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyZWQuc3RhcnQoaSkgJiYgcG9zaXRpb24gPD0gYnVmZmVyZWQuZW5kKGkpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICBidWZmZXJJbmZvIDogZnVuY3Rpb24obWVkaWEsIHBvcyxtYXhIb2xlRHVyYXRpb24pIHtcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICB2YXIgdmJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQsIGJ1ZmZlcmVkID0gW10saTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGJ1ZmZlcmVkLnB1c2goe3N0YXJ0OiB2YnVmZmVyZWQuc3RhcnQoaSksIGVuZDogdmJ1ZmZlcmVkLmVuZChpKX0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCxwb3MsbWF4SG9sZUR1cmF0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB7bGVuOiAwLCBzdGFydDogcG9zLCBlbmQ6IHBvcywgbmV4dFN0YXJ0IDogdW5kZWZpbmVkfSA7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgYnVmZmVyZWRJbmZvIDogZnVuY3Rpb24oYnVmZmVyZWQscG9zLG1heEhvbGVEdXJhdGlvbikge1xyXG4gICAgdmFyIGJ1ZmZlcmVkMiA9IFtdLFxyXG4gICAgICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXHJcbiAgICAgICAgYnVmZmVyTGVuLGJ1ZmZlclN0YXJ0LCBidWZmZXJFbmQsYnVmZmVyU3RhcnROZXh0LGk7XHJcbiAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXHJcbiAgICBidWZmZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHZhciBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XHJcbiAgICAgIGlmIChkaWZmKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpZmY7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGIuZW5kIC0gYS5lbmQ7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXHJcbiAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcclxuICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xyXG4gICAgICBpZihidWYybGVuKSB7XHJcbiAgICAgICAgdmFyIGJ1ZjJlbmQgPSBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZDtcclxuICAgICAgICAvLyBpZiBzbWFsbCBob2xlICh2YWx1ZSBiZXR3ZWVuIDAgb3IgbWF4SG9sZUR1cmF0aW9uICkgb3Igb3ZlcmxhcHBpbmcgKG5lZ2F0aXZlKVxyXG4gICAgICAgIGlmKChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQpIDwgbWF4SG9sZUR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xyXG4gICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcclxuICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxyXG4gICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxyXG4gICAgICAgICAgaWYoYnVmZmVyZWRbaV0uZW5kID4gYnVmMmVuZCkge1xyXG4gICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gYmlnIGhvbGVcclxuICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZmlyc3QgdmFsdWVcclxuICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoaSA9IDAsIGJ1ZmZlckxlbiA9IDAsIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyRW5kID0gcG9zOyBpIDwgYnVmZmVyZWQyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBzdGFydCA9ICBidWZmZXJlZDJbaV0uc3RhcnQsXHJcbiAgICAgICAgICBlbmQgPSBidWZmZXJlZDJbaV0uZW5kO1xyXG4gICAgICAvL2xvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcclxuICAgICAgaWYgKChwb3MgKyBtYXhIb2xlRHVyYXRpb24pID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xyXG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxyXG4gICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xyXG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcclxuICAgICAgfSBlbHNlIGlmICgocG9zICsgbWF4SG9sZUR1cmF0aW9uKSA8IHN0YXJ0KSB7XHJcbiAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7bGVuOiBidWZmZXJMZW4sIHN0YXJ0OiBidWZmZXJTdGFydCwgZW5kOiBidWZmZXJFbmQsIG5leHRTdGFydCA6IGJ1ZmZlclN0YXJ0TmV4dH07XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJIZWxwZXI7XHJcbiIsIi8qKlxyXG4gKiBMZXZlbCBIZWxwZXIgY2xhc3MsIHByb3ZpZGluZyBtZXRob2RzIGRlYWxpbmcgd2l0aCBwbGF5bGlzdCBzbGlkaW5nIGFuZCBkcmlmdFxyXG4qL1xyXG5cclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5jb25zdCBMZXZlbEhlbHBlciA9IHtcclxuXHJcbiAgbWVyZ2VEZXRhaWxzIDogZnVuY3Rpb24ob2xkRGV0YWlscyxuZXdEZXRhaWxzKSB7XHJcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sbmV3RGV0YWlscy5zdGFydFNOKS1uZXdEZXRhaWxzLnN0YXJ0U04sXHJcbiAgICAgICAgZW5kID0gTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTixuZXdEZXRhaWxzLmVuZFNOKS1uZXdEZXRhaWxzLnN0YXJ0U04sXHJcbiAgICAgICAgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gLSBvbGREZXRhaWxzLnN0YXJ0U04sXHJcbiAgICAgICAgb2xkZnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHMsXHJcbiAgICAgICAgbmV3ZnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHMsXHJcbiAgICAgICAgY2NPZmZzZXQgPTAsXHJcbiAgICAgICAgUFRTRnJhZztcclxuXHJcbiAgICAvLyBjaGVjayBpZiBvbGQvbmV3IHBsYXlsaXN0cyBoYXZlIGZyYWdtZW50cyBpbiBjb21tb25cclxuICAgIGlmICggZW5kIDwgc3RhcnQpIHtcclxuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUyAsIGNjLCBhbmQgZHVyYXRpb24gaWYgYW55IGZvdW5kXHJcbiAgICBmb3IodmFyIGkgPSBzdGFydCA7IGkgPD0gZW5kIDsgaSsrKSB7XHJcbiAgICAgIHZhciBvbGRGcmFnID0gb2xkZnJhZ21lbnRzW2RlbHRhK2ldLFxyXG4gICAgICAgICAgbmV3RnJhZyA9IG5ld2ZyYWdtZW50c1tpXTtcclxuICAgICAgaWYgKG5ld0ZyYWcgJiYgb2xkRnJhZykge1xyXG4gICAgICAgIGNjT2Zmc2V0ID0gb2xkRnJhZy5jYyAtIG5ld0ZyYWcuY2M7XHJcbiAgICAgICAgaWYgKCFpc05hTihvbGRGcmFnLnN0YXJ0UFRTKSkge1xyXG4gICAgICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTO1xyXG4gICAgICAgICAgbmV3RnJhZy5lbmRQVFMgPSBvbGRGcmFnLmVuZFBUUztcclxuICAgICAgICAgIG5ld0ZyYWcuZHVyYXRpb24gPSBvbGRGcmFnLmR1cmF0aW9uO1xyXG4gICAgICAgICAgUFRTRnJhZyA9IG5ld0ZyYWc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYoY2NPZmZzZXQpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhgZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50YCk7XHJcbiAgICAgIGZvcihpID0gMCA7IGkgPCBuZXdmcmFnbWVudHMubGVuZ3RoIDsgaSsrKSB7XHJcbiAgICAgICAgbmV3ZnJhZ21lbnRzW2ldLmNjICs9IGNjT2Zmc2V0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXHJcbiAgICBpZihQVFNGcmFnKSB7XHJcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscyxQVFNGcmFnLFBUU0ZyYWcuc3RhcnRQVFMsUFRTRnJhZy5lbmRQVFMsUFRTRnJhZy5zdGFydERUUyxQVFNGcmFnLmVuZERUUyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkZnJhZ21lbnRzIHJhbmdlXHJcbiAgICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXHJcbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXHJcbiAgICAgIGlmIChkZWx0YSA+PSAwICYmIGRlbHRhIDwgb2xkZnJhZ21lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIGFkanVzdCBzdGFydCBieSBzbGlkaW5nIG9mZnNldFxyXG4gICAgICAgIHZhciBzbGlkaW5nID0gb2xkZnJhZ21lbnRzW2RlbHRhXS5zdGFydDtcclxuICAgICAgICBmb3IoaSA9IDAgOyBpIDwgbmV3ZnJhZ21lbnRzLmxlbmd0aCA7IGkrKykge1xyXG4gICAgICAgICAgbmV3ZnJhZ21lbnRzW2ldLnN0YXJ0ICs9IHNsaWRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgaXQgbWVhbnMgd2UgaGF2ZSBmcmFnbWVudHMgb3ZlcmxhcHBpbmcgYmV0d2VlblxyXG4gICAgLy8gb2xkIGFuZCBuZXcgbGV2ZWwuIHJlbGlhYmxlIFBUUyBpbmZvIGlzIHRodXMgcmVseWluZyBvbiBvbGQgbGV2ZWxcclxuICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBvbGREZXRhaWxzLlBUU0tub3duO1xyXG4gICAgcmV0dXJuO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZUZyYWdQVFNEVFMgOiBmdW5jdGlvbihkZXRhaWxzLGZyYWcsc3RhcnRQVFMsZW5kUFRTLHN0YXJ0RFRTLGVuZERUUykge1xyXG4gICAgLy8gdXBkYXRlIGZyYWcgUFRTL0RUU1xyXG4gICAgaWYoIWlzTmFOKGZyYWcuc3RhcnRQVFMpKSB7XHJcbiAgICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xyXG4gICAgICBsZXQgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnLnN0YXJ0UFRTLXN0YXJ0UFRTKTtcclxuICAgICAgaWYgKGlzTmFOKGZyYWcuZGVsdGFQVFMpKSB7XHJcbiAgICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUyxmcmFnLmRlbHRhUFRTKTtcclxuICAgICAgfVxyXG4gICAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLGZyYWcuc3RhcnRQVFMpO1xyXG4gICAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWcuZW5kUFRTKTtcclxuICAgICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUyxmcmFnLnN0YXJ0RFRTKTtcclxuICAgICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XHJcbiAgICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0UFRTO1xyXG4gICAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XHJcbiAgICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XHJcbiAgICBmcmFnLmVuZERUUyA9IGVuZERUUztcclxuICAgIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcclxuXHJcbiAgICBjb25zdCBzbiA9IGZyYWcuc247XHJcbiAgICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxyXG4gICAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIHZhciBmcmFnSWR4LCBmcmFnbWVudHMsIGk7XHJcbiAgICBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XHJcbiAgICBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcclxuICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZ0lkeF07XHJcbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXHJcbiAgICBmb3IoaSA9IGZyYWdJZHggOyBpID4gMCA7IGktLSkge1xyXG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVQVFMoZnJhZ21lbnRzLGksaS0xKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtIHRvIGxhc3QgZnJhZ1xyXG4gICAgZm9yKGkgPSBmcmFnSWR4IDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxIDsgaSsrKSB7XHJcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZVBUUyhmcmFnbWVudHMsaSxpKzEpO1xyXG4gICAgfVxyXG4gICAgZGV0YWlscy5QVFNLbm93biA9IHRydWU7XHJcbiAgICAvL2xvZ2dlci5sb2coYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyBzdGFydC9lbmQ6JHtzdGFydFBUUy50b0ZpeGVkKDMpfS8ke2VuZFBUUy50b0ZpeGVkKDMpfWApO1xyXG5cclxuICAgIHJldHVybiBkcmlmdDtcclxuICB9LFxyXG5cclxuICB1cGRhdGVQVFMgOiBmdW5jdGlvbihmcmFnbWVudHMsZnJvbUlkeCwgdG9JZHgpIHtcclxuICAgIHZhciBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XSxmcmFnVG8gPSBmcmFnbWVudHNbdG9JZHhdLCBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7XHJcbiAgICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxyXG4gICAgaWYoIWlzTmFOKGZyYWdUb1BUUykpIHtcclxuICAgICAgLy8gdXBkYXRlIGZyYWdtZW50IGR1cmF0aW9uLlxyXG4gICAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cclxuICAgICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xyXG4gICAgICAgIGZyYWdGcm9tLmR1cmF0aW9uID0gZnJhZ1RvUFRTLWZyYWdGcm9tLnN0YXJ0O1xyXG4gICAgICAgIGlmKGZyYWdGcm9tLmR1cmF0aW9uIDwgMCkge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG5lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZ0Zyb20uc259LGxldmVsICR7ZnJhZ0Zyb20ubGV2ZWx9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZnJhZ1RvLmR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XHJcbiAgICAgICAgaWYoZnJhZ1RvLmR1cmF0aW9uIDwgMCkge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG5lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZ1RvLnNufSxsZXZlbCAke2ZyYWdUby5sZXZlbH0sIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxyXG4gICAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XHJcbiAgICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyBmcmFnRnJvbS5kdXJhdGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmcmFnVG8uc3RhcnQgPSBNYXRoLm1heChmcmFnRnJvbS5zdGFydCAtIGZyYWdUby5kdXJhdGlvbiwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExldmVsSGVscGVyO1xyXG4iLCIvKipcclxuICogSExTIGludGVyZmFjZVxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMnO1xyXG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi9lcnJvcnMnO1xyXG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcclxuaW1wb3J0IEZyYWdtZW50TG9hZGVyIGZyb20gJy4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlcic7XHJcbmltcG9ydCBLZXlMb2FkZXIgZnJvbSAnLi9sb2FkZXIva2V5LWxvYWRlcic7XHJcblxyXG5pbXBvcnQgU3RyZWFtQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyJztcclxuaW1wb3J0IExldmVsQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgSUQzVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlcic7XHJcblxyXG5pbXBvcnQge2xvZ2dlciwgZW5hYmxlTG9nc30gZnJvbSAnLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XHJcbmltcG9ydCB7aGxzRGVmYXVsdENvbmZpZ30gZnJvbSAnLi9jb25maWcnO1xyXG5cclxuY2xhc3MgSGxzIHtcclxuXHJcbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xyXG4gICAgLy8gcmVwbGFjZWQgd2l0aCBicm93c2VyaWZ5LXZlcnNpb25pZnkgdHJhbnNmb3JtXHJcbiAgICByZXR1cm4gJ19fVkVSU0lPTl9fJztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcclxuICAgIHdpbmRvdy5NZWRpYVNvdXJjZSA9IHdpbmRvdy5NZWRpYVNvdXJjZSB8fCB3aW5kb3cuV2ViS2l0TWVkaWFTb3VyY2U7XHJcbiAgICB3aW5kb3cuU291cmNlQnVmZmVyID0gd2luZG93LlNvdXJjZUJ1ZmZlciB8fCB3aW5kb3cuV2ViS2l0U291cmNlQnVmZmVyO1xyXG5cclxuICAgIGNvbnN0IGlzVHlwZVN1cHBvcnRlZCA9IHdpbmRvdy5NZWRpYVNvdXJjZSAmJlxyXG4gICAgICB0eXBlb2Ygd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICB3aW5kb3cuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiJyk7XHJcbiAgICBjb25zdCBoYXNTdXBwb3J0ZWRTb3VyY2VCdWZmZXIgPSB3aW5kb3cuU291cmNlQnVmZmVyICYmIHdpbmRvdy5Tb3VyY2VCdWZmZXIucHJvdG90eXBlICYmXHJcbiAgICAgIHR5cGVvZiB3aW5kb3cuU291cmNlQnVmZmVyLnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgdHlwZW9mIHdpbmRvdy5Tb3VyY2VCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIGNvbnN0IGlzU2FmYXJpID0gbmF2aWdhdG9yLnZlbmRvciAmJiBuYXZpZ2F0b3IudmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMTtcclxuXHJcbiAgICAvLyBzYWZhcmkgZG9lcyBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcclxuICAgIHJldHVybiBpc1R5cGVTdXBwb3J0ZWQgJiYgKGhhc1N1cHBvcnRlZFNvdXJjZUJ1ZmZlciB8fCBpc1NhZmFyaSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0IEV2ZW50cygpIHtcclxuICAgIHJldHVybiBFdmVudDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcygpIHtcclxuICAgIHJldHVybiBFcnJvclR5cGVzO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldCBFcnJvckRldGFpbHMoKSB7XHJcbiAgICByZXR1cm4gRXJyb3JEZXRhaWxzO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldCBEZWZhdWx0Q29uZmlnKCkge1xyXG4gICAgaWYoIUhscy5kZWZhdWx0Q29uZmlnKSB7XHJcbiAgICAgIHJldHVybiBobHNEZWZhdWx0Q29uZmlnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHNldCBEZWZhdWx0Q29uZmlnKGRlZmF1bHRDb25maWcpIHtcclxuICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XHJcbiAgICB2YXIgZGVmYXVsdENvbmZpZyA9IEhscy5EZWZhdWx0Q29uZmlnO1xyXG5cclxuICAgIGlmICgoY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAoY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb25cXCd0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRDb25maWcpIHtcclxuICAgICAgICBpZiAocHJvcCBpbiBjb25maWcpIHsgY29udGludWU7IH1cclxuICAgICAgICBjb25maWdbcHJvcF0gPSBkZWZhdWx0Q29uZmlnW3Byb3BdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xyXG4gICAgfVxyXG5cclxuICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnKTtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xyXG4gICAgLy8gb2JzZXJ2ZXIgc2V0dXBcclxuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBvYnNlcnZlci50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXZlbnQsIC4uLmRhdGEpIHtcclxuICAgICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBvYnNlcnZlci5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50LCAuLi5kYXRhKSB7XHJcbiAgICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uID0gb2JzZXJ2ZXIub24uYmluZChvYnNlcnZlcik7XHJcbiAgICB0aGlzLm9mZiA9IG9ic2VydmVyLm9mZi5iaW5kKG9ic2VydmVyKTtcclxuICAgIHRoaXMudHJpZ2dlciA9IG9ic2VydmVyLnRyaWdnZXIuYmluZChvYnNlcnZlcik7XHJcblxyXG4gICAgLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXHJcbiAgICBjb25zdCBhYnJDb250cm9sbGVyID0gdGhpcy5hYnJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5hYnJDb250cm9sbGVyKHRoaXMpO1xyXG4gICAgY29uc3QgYnVmZmVyQ29udHJvbGxlciAgPSBuZXcgY29uZmlnLmJ1ZmZlckNvbnRyb2xsZXIodGhpcyk7XHJcbiAgICBjb25zdCBjYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTtcclxuICAgIGNvbnN0IGZwc0NvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmZwc0NvbnRyb2xsZXIodGhpcyk7XHJcbiAgICBjb25zdCBwbGF5TGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcih0aGlzKTtcclxuICAgIGNvbnN0IGZyYWdtZW50TG9hZGVyID0gbmV3IEZyYWdtZW50TG9hZGVyKHRoaXMpO1xyXG4gICAgY29uc3Qga2V5TG9hZGVyID0gbmV3IEtleUxvYWRlcih0aGlzKTtcclxuICAgIGNvbnN0IGlkM1RyYWNrQ29udHJvbGxlciA9IG5ldyBJRDNUcmFja0NvbnRyb2xsZXIodGhpcyk7XHJcblxyXG4gICAgLy8gbmV0d29yayBjb250cm9sbGVyc1xyXG4gICAgY29uc3QgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xyXG4gICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdHJlYW1Db250cm9sbGVyKHRoaXMpO1xyXG4gICAgbGV0IG5ldHdvcmtDb250cm9sbGVycyA9IFtsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xyXG5cclxuICAgIC8vIG9wdGlvbmFsIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXHJcbiAgICBsZXQgQ29udHJvbGxlciA9IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXI7XHJcbiAgICBpZiAoQ29udHJvbGxlcikge1xyXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQ29udHJvbGxlcih0aGlzKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcclxuXHJcbiAgICBsZXQgY29yZUNvbXBvbmVudHMgPSBbIHBsYXlMaXN0TG9hZGVyLCBmcmFnbWVudExvYWRlciwga2V5TG9hZGVyLCBhYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXIsIGlkM1RyYWNrQ29udHJvbGxlciBdO1xyXG5cclxuICAgIC8vIG9wdGlvbmFsIGF1ZGlvIHRyYWNrIGFuZCBzdWJ0aXRsZSBjb250cm9sbGVyXHJcbiAgICBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xyXG4gICAgaWYgKENvbnRyb2xsZXIpIHtcclxuICAgICAgbGV0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIodGhpcyk7XHJcbiAgICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBhdWRpb1RyYWNrQ29udHJvbGxlcjtcclxuICAgICAgY29yZUNvbXBvbmVudHMucHVzaChhdWRpb1RyYWNrQ29udHJvbGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcclxuICAgIGlmIChDb250cm9sbGVyKSB7XHJcbiAgICAgIGxldCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xyXG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XHJcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG9wdGlvbmFsIHN1YnRpdGxlIGNvbnRyb2xsZXJcclxuICAgIFtjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBjb25maWcudGltZWxpbmVDb250cm9sbGVyXS5mb3JFYWNoKENvbnRyb2xsZXIgPT4ge1xyXG4gICAgICBpZiAoQ29udHJvbGxlcikge1xyXG4gICAgICAgIGNvcmVDb21wb25lbnRzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcykpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSBjb3JlQ29tcG9uZW50cztcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XHJcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuREVTVFJPWUlORyk7XHJcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XHJcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmNvbmNhdCh0aGlzLm5ldHdvcmtDb250cm9sbGVycykuZm9yRWFjaChjb21wb25lbnQgPT4ge2NvbXBvbmVudC5kZXN0cm95KCk7fSk7XHJcbiAgICB0aGlzLnVybCA9IG51bGw7XHJcbiAgICB0aGlzLm9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xyXG4gIH1cclxuXHJcbiAgYXR0YWNoTWVkaWEobWVkaWEpIHtcclxuICAgIGxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XHJcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XHJcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNISU5HLCB7bWVkaWE6IG1lZGlhfSk7XHJcbiAgfVxyXG5cclxuICBkZXRhY2hNZWRpYSgpIHtcclxuICAgIGxvZ2dlci5sb2coJ2RldGFjaE1lZGlhJyk7XHJcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUVESUFfREVUQUNISU5HKTtcclxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgbG9hZFNvdXJjZSh1cmwpIHtcclxuICAgIHVybCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICAgIGxvZ2dlci5sb2coYGxvYWRTb3VyY2U6JHt1cmx9YCk7XHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcclxuICAgIHRoaXMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9MT0FESU5HLCB7dXJsOiB1cmx9KTtcclxuICB9XHJcblxyXG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uPS0xKSB7XHJcbiAgICBsb2dnZXIubG9nKGBzdGFydExvYWQoJHtzdGFydFBvc2l0aW9ufSlgKTtcclxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7Y29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7fSk7XHJcbiAgfVxyXG5cclxuICBzdG9wTG9hZCgpIHtcclxuICAgIGxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XHJcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge2NvbnRyb2xsZXIuc3RvcExvYWQoKTt9KTtcclxuICB9XHJcblxyXG4gIHN3YXBBdWRpb0NvZGVjKCkge1xyXG4gICAgbG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcclxuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xyXG4gIH1cclxuXHJcbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xyXG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcclxuICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFJldHVybiBhbGwgcXVhbGl0eSBsZXZlbHMgKiovXHJcbiAgZ2V0IGxldmVscygpIHtcclxuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIGN1cnJlbnQgcGxheWJhY2sgcXVhbGl0eSBsZXZlbCAqKi9cclxuICBnZXQgY3VycmVudExldmVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiBzZXQgcXVhbGl0eSBsZXZlbCBpbW1lZGlhdGVseSAoLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24pICovXHJcbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbCkge1xyXG4gICAgbG9nZ2VyLmxvZyhgc2V0IGN1cnJlbnRMZXZlbDoke25ld0xldmVsfWApO1xyXG4gICAgdGhpcy5sb2FkTGV2ZWwgPSBuZXdMZXZlbDtcclxuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFJldHVybiBuZXh0IHBsYXliYWNrIHF1YWxpdHkgbGV2ZWwgKHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBmcmFnbWVudCkgKiovXHJcbiAgZ2V0IG5leHRMZXZlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsO1xyXG4gIH1cclxuXHJcbiAgLyogc2V0IHF1YWxpdHkgbGV2ZWwgZm9yIG5leHQgZnJhZ21lbnQgKC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uKSAqL1xyXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWwpIHtcclxuICAgIGxvZ2dlci5sb2coYHNldCBuZXh0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcclxuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XHJcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIGN1cnJlbnQvbGFzdCBsb2FkZWQgZnJhZ21lbnQgKiovXHJcbiAgZ2V0IGxvYWRMZXZlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcclxuICB9XHJcblxyXG4gIC8qIHNldCBxdWFsaXR5IGxldmVsIGZvciBjdXJyZW50L25leHQgbG9hZGVkIGZyYWdtZW50ICgtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbikgKi9cclxuICBzZXQgbG9hZExldmVsKG5ld0xldmVsKSB7XHJcbiAgICBsb2dnZXIubG9nKGBzZXQgbG9hZExldmVsOiR7bmV3TGV2ZWx9YCk7XHJcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xyXG4gIH1cclxuXHJcbiAgLyoqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBmcmFnbWVudCAqKi9cclxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xyXG4gIH1cclxuXHJcbiAgLyoqIHNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIGZyYWdtZW50ICoqL1xyXG4gIHNldCBuZXh0TG9hZExldmVsKGxldmVsKSB7XHJcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxyXG4gICoqL1xyXG4gIGdldCBmaXJzdExldmVsKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcclxuICB9XHJcblxyXG4gIC8qKiBzZXQgZmlyc3QgbGV2ZWwgKGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3QpXHJcbiAgKiovXHJcbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcclxuICAgIGxvZ2dlci5sb2coYHNldCBmaXJzdExldmVsOiR7bmV3TGV2ZWx9YCk7XHJcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXHJcbiAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxyXG4gICAgICBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGggKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxyXG4gICoqL1xyXG4gIGdldCBzdGFydExldmVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxyXG4gICAgICBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcclxuICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcclxuICAqKi9cclxuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xyXG4gICAgbG9nZ2VyLmxvZyhgc2V0IHN0YXJ0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcclxuICAgIGNvbnN0IGhscyA9IHRoaXM7XHJcbiAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxyXG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xyXG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLGhscy5taW5BdXRvTGV2ZWwpO1xyXG4gICAgfVxyXG4gICAgaGxzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIHRoZSBjYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IGNvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKiovXHJcbiAgZ2V0IGF1dG9MZXZlbENhcHBpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcclxuICB9XHJcblxyXG4gIC8qKiBzZXQgdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cclxuICBzZXQgYXV0b0xldmVsQ2FwcGluZyhuZXdMZXZlbCkge1xyXG4gICAgbG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcclxuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcclxuICB9XHJcblxyXG4gIC8qIGNoZWNrIGlmIHdlIGFyZSBpbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIG1vZGUgKi9cclxuICBnZXQgYXV0b0xldmVsRW5hYmxlZCgpIHtcclxuICAgIHJldHVybiAodGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xKTtcclxuICB9XHJcblxyXG4gIC8qIHJldHVybiBtYW51YWwgbGV2ZWwgKi9cclxuICBnZXQgbWFudWFsTGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiByZXR1cm4gbWluIGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBjb25maWcubWluQXV0b0JpdHJhdGUgKi9cclxuICBnZXQgbWluQXV0b0xldmVsKCkge1xyXG4gICAgbGV0IGhscyA9IHRoaXMsIGxldmVscyA9IGhscy5sZXZlbHMsIG1pbkF1dG9CaXRyYXRlID0gaGxzLmNvbmZpZy5taW5BdXRvQml0cmF0ZSwgbGVuID0gbGV2ZWxzID8gbGV2ZWxzLmxlbmd0aCA6IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbaV0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbaV0ucmVhbEJpdHJhdGUsbGV2ZWxzW2ldLmJpdHJhdGUpIDogbGV2ZWxzW2ldLmJpdHJhdGU7XHJcbiAgICAgIGlmIChsZXZlbE5leHRCaXRyYXRlID4gbWluQXV0b0JpdHJhdGUpIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvKiByZXR1cm4gbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nICovXHJcbiAgZ2V0IG1heEF1dG9MZXZlbCgpIHtcclxuICAgIGNvbnN0IGhscyA9IHRoaXM7XHJcbiAgICBjb25zdCBsZXZlbHMgPSBobHMubGV2ZWxzO1xyXG4gICAgY29uc3QgYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xyXG4gICAgbGV0IG1heEF1dG9MZXZlbDtcclxuICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcclxuICAgIH1cclxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXHJcbiAgZ2V0IG5leHRBdXRvTGV2ZWwoKSB7XHJcbiAgICBjb25zdCBobHMgPSB0aGlzO1xyXG4gICAgLy8gZW5zdXJlIG5leHQgYXV0byBsZXZlbCBpcyBiZXR3ZWVuICBtaW4gYW5kIG1heCBhdXRvIGxldmVsXHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoaGxzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCxobHMubWluQXV0b0xldmVsKSxobHMubWF4QXV0b0xldmVsKTtcclxuICB9XHJcblxyXG4gIC8vIHRoaXMgc2V0dGVyIGlzIHVzZWQgdG8gZm9yY2UgbmV4dCBhdXRvIGxldmVsXHJcbiAgLy8gdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGUgOiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXHJcbiAgLy8gZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2VzZnVsIGZyYWcgbG9hZGluZyBhdCBmb3JjZWQgbGV2ZWwsIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlclxyXG4gIHNldCBuZXh0QXV0b0xldmVsKG5leHRMZXZlbCkge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcztcclxuICAgIGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heChobHMubWluQXV0b0xldmVsLG5leHRMZXZlbCk7XHJcbiAgfVxyXG5cclxuICAvKiogZ2V0IGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xyXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcclxuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcclxuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XHJcbiAgfVxyXG5cclxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpICoqL1xyXG4gIGdldCBhdWRpb1RyYWNrKCkge1xyXG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xyXG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXHJcbiAgc2V0IGF1ZGlvVHJhY2soYXVkaW9UcmFja0lkKSB7XHJcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XHJcbiAgICBpZiAoYXVkaW9UcmFja0NvbnRyb2xsZXIpIHtcclxuICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cclxuICBnZXQgc3VidGl0bGVUcmFja3MoKSB7XHJcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XHJcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cclxuICBnZXQgc3VidGl0bGVUcmFjaygpIHtcclxuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcclxuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcclxuICB9XHJcblxyXG4gIC8qKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cyoqL1xyXG4gIHNldCBzdWJ0aXRsZVRyYWNrKHN1YnRpdGxlVHJhY2tJZCkge1xyXG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xyXG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XHJcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgPSBzdWJ0aXRsZVRyYWNrSWQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIbHM7XHJcbiIsIi8vIFRoaXMgaXMgbW9zdGx5IGZvciBzdXBwb3J0IG9mIHRoZSBlczYgbW9kdWxlIGV4cG9ydFxyXG4vLyBzeW50YXggd2l0aCB0aGUgYmFiZWwgY29tcGlsZXIsIGl0IGxvb2tzIGxpa2UgaXQgZG9lc250IHN1cHBvcnRcclxuLy8gZnVuY3Rpb24gZXhwb3J0cyBsaWtlIHdlIGFyZSB1c2VkIHRvIGluIG5vZGUvY29tbW9uanNcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2hscy5qcycpLmRlZmF1bHQ7XHJcbiIsIi8qXHJcbiAqIEZyYWdtZW50IExvYWRlclxyXG4qL1xyXG5cclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNsYXNzIEZyYWdtZW50TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsIEV2ZW50LkZSQUdfTE9BRElORyk7XHJcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBsZXQgbG9hZGVycyA9IHRoaXMubG9hZGVycztcclxuICAgIGZvciAobGV0IGxvYWRlck5hbWUgaW4gbG9hZGVycykge1xyXG4gICAgICBsZXQgbG9hZGVyID0gbG9hZGVyc1tsb2FkZXJOYW1lXTtcclxuICAgICAgaWYgKGxvYWRlcikge1xyXG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnLFxyXG4gICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXHJcbiAgICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdLFxyXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcclxuXHJcbiAgICBmcmFnLmxvYWRlZCA9IDA7XHJcbiAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBmcmFnbWVudCBsb2FkZXIgZm9yIHR5cGU6JHt0eXBlfWApO1xyXG4gICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuICAgIGxvYWRlciAgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBmcmFnLmxvYWRlciA9IHR5cGVvZihjb25maWcuZkxvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5mTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xyXG5cclxuICAgIGxldCBsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcclxuICAgIGxvYWRlckNvbnRleHQgPSB7IHVybCA6IGZyYWcudXJsLCBmcmFnIDogZnJhZywgcmVzcG9uc2VUeXBlIDogJ2FycmF5YnVmZmVyJywgcHJvZ3Jlc3NEYXRhIDogZmFsc2V9O1xyXG4gICAgbGV0IHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldCwgZW5kID0gZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XHJcbiAgICBpZiAoIWlzTmFOKHN0YXJ0KSAmJiAhaXNOYU4oZW5kKSkge1xyXG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcclxuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGVuZDtcclxuICAgIH1cclxuICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dCA6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5IDogMCAsIHJldHJ5RGVsYXkgOiAwLCBtYXhSZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fTtcclxuICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzIDogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLCBvbkVycm9yIDp0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLCBvblRpbWVvdXQgOiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIG9uUHJvZ3Jlc3M6IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyl9O1xyXG4gICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCxsb2FkZXJDb25maWcsbG9hZGVyQ2FsbGJhY2tzKTtcclxuICB9XHJcblxyXG4gIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xyXG4gICAgbGV0IHBheWxvYWQgPSByZXNwb25zZS5kYXRhLCBmcmFnID0gY29udGV4dC5mcmFnO1xyXG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcclxuICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BREVELCB7cGF5bG9hZDogcGF5bG9hZCwgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzfSk7XHJcbiAgfVxyXG5cclxuICBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcclxuICAgIGxldCBsb2FkZXIgPSBjb250ZXh0LmxvYWRlcjtcclxuICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCByZXNwb25zZTogcmVzcG9uc2V9KTtcclxuICB9XHJcblxyXG4gIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XHJcbiAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnfSk7XHJcbiAgfVxyXG5cclxuICAvLyBkYXRhIHdpbGwgYmUgdXNlZCBmb3IgcHJvZ3Jlc3NpdmUgcGFyc2luZ1xyXG4gIGxvYWRwcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnO1xyXG4gICAgZnJhZy5sb2FkZWQgPSBzdGF0cy5sb2FkZWQ7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRF9QUk9HUkVTUywge2ZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0c30pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRnJhZ21lbnRMb2FkZXI7XHJcbiIsIi8qXHJcbiAqIERlY3J5cHQga2V5IExvYWRlclxyXG4qL1xyXG5cclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNsYXNzIEtleUxvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLCBFdmVudC5LRVlfTE9BRElORyk7XHJcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcclxuICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XHJcbiAgICB0aGlzLmRlY3J5cHR1cmwgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGZvciAobGV0IGxvYWRlck5hbWUgaW4gdGhpcy5sb2FkZXJzKSB7XHJcbiAgICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbbG9hZGVyTmFtZV07XHJcbiAgICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcclxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgb25LZXlMb2FkaW5nKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnLFxyXG4gICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXHJcbiAgICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdLFxyXG4gICAgICAgIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSxcclxuICAgICAgICB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XHJcbiAgICAgICAgLy8gaWYgdXJpIGlzIGRpZmZlcmVudCBmcm9tIHByZXZpb3VzIG9uZSBvciBpZiBkZWNyeXB0IGtleSBub3QgcmV0cmlldmVkIHlldFxyXG4gICAgICBpZiAodXJpICE9PSB0aGlzLmRlY3J5cHR1cmwgfHwgdGhpcy5kZWNyeXB0a2V5ID09PSBudWxsKSB7XHJcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcclxuXHJcbiAgICAgICAgaWYgKGxvYWRlcikge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGtleSBsb2FkZXIgZm9yIHR5cGU6JHt0eXBlfWApO1xyXG4gICAgICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZyYWcubG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdID0gbmV3IGNvbmZpZy5sb2FkZXIoY29uZmlnKTtcclxuICAgICAgICB0aGlzLmRlY3J5cHR1cmwgPSB1cmk7XHJcbiAgICAgICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcclxuXHJcbiAgICAgICAgbGV0IGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xyXG4gICAgICAgIGxvYWRlckNvbnRleHQgPSB7IHVybCA6IHVyaSwgZnJhZyA6IGZyYWcsIHJlc3BvbnNlVHlwZSA6ICdhcnJheWJ1ZmZlcid9O1xyXG4gICAgICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dCA6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkgLCByZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSA6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dH07XHJcbiAgICAgICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3MgOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3IgOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dCA6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07XHJcbiAgICAgICAgZnJhZy5sb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LGxvYWRlckNvbmZpZyxsb2FkZXJDYWxsYmFja3MpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGVjcnlwdGtleSkge1xyXG4gICAgICAgIC8vIHdlIGFscmVhZHkgbG9hZGVkIHRoaXMga2V5LCByZXR1cm4gaXRcclxuICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSB0aGlzLmRlY3J5cHRrZXk7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BREVELCB7ZnJhZzogZnJhZ30pO1xyXG4gICAgICB9XHJcbiAgfVxyXG5cclxuICBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcclxuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnO1xyXG4gICAgdGhpcy5kZWNyeXB0a2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTtcclxuICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXHJcbiAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BREVELCB7ZnJhZzogZnJhZ30pO1xyXG4gIH1cclxuXHJcbiAgbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZyxcclxuICAgICAgICBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcclxuICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnLCByZXNwb25zZTogcmVzcG9uc2V9KTtcclxuICB9XHJcblxyXG4gIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZyxcclxuICAgICAgICBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcclxuICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VULCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWd9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEtleUxvYWRlcjtcclxuIiwiLyoqXHJcbiAqIFBsYXlsaXN0IExvYWRlclxyXG4qL1xyXG5cclxuaW1wb3J0IFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCBBdHRyTGlzdCBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbi8vIGh0dHBzOi8vcmVnZXgxMDEuY29tIGlzIHlvdXIgZnJpZW5kXHJcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXG5cXHJdKilbXFxyXFxuXSsoW15cXHJcXG5dKykvZztcclxuY29uc3QgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYID0gLyNFWFQtWC1NRURJQTooLiopL2c7XHJcbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSAvI0VYVElORjooXFxkKig/OlxcLlxcZCspPykoPzosKC4qKSk/fCg/ISMpKFxcUy4rKXwjRVhULVgtQllURVJBTkdFOiAqKC4rKXwjRVhULVgtUFJPR1JBTS1EQVRFLVRJTUU6KC4rKXwjLiovZztcclxuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IC8oPzooPzojKEVYVE0zVSkpfCg/OiNFWFQtWC0oUExBWUxJU1QtVFlQRSk6KC4rKSl8KD86I0VYVC1YLShNRURJQS1TRVFVRU5DRSk6ICooXFxkKykpfCg/OiNFWFQtWC0oVEFSR0VURFVSQVRJT04pOiAqKFxcZCspKXwoPzojRVhULVgtKEtFWSk6KC4rKSl8KD86I0VYVC1YLShTVEFSVCk6KC4rKSl8KD86I0VYVC1YLShFTkRMSVNUKSl8KD86I0VYVC1YLShESVNDT05USU5VSVRZLVNFUSlVRU5DRTooXFxkKykpfCg/OiNFWFQtWC0oRElTKUNPTlRJTlVJVFkpKXwoPzojRVhULVgtKFZFUlNJT04pOihcXGQrKSl8KD86I0VYVC1YLShNQVApOiguKykpfCg/OigjKSguKik6KC4qKSl8KD86KCMpKC4qKSkoPzouKilcXHI/XFxuPy87XHJcblxyXG5jbGFzcyBMZXZlbEtleSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5tZXRob2QgPSBudWxsO1xyXG4gICAgdGhpcy5rZXkgPSBudWxsO1xyXG4gICAgdGhpcy5pdiA9IG51bGw7XHJcbiAgICB0aGlzLl91cmkgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHVyaSgpIHtcclxuICAgIGlmICghdGhpcy5fdXJpICYmIHRoaXMucmVsdXJpKSB7XHJcbiAgICAgIHRoaXMuX3VyaSA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmksIHRoaXMucmVsdXJpLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl91cmk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY2xhc3MgRnJhZ21lbnQge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX3VybCA9IG51bGw7XHJcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xyXG4gICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xyXG4gICAgdGhpcy50YWdMaXN0ID0gW107XHJcbiAgfVxyXG5cclxuICBnZXQgdXJsKCkge1xyXG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5yZWx1cmwpIHtcclxuICAgICAgdGhpcy5fdXJsID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICB9XHJcblxyXG4gIHNldCB1cmwodmFsdWUpIHtcclxuICAgIHRoaXMuX3VybCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHByb2dyYW1EYXRlVGltZSgpIHtcclxuICAgIGlmICghdGhpcy5fcHJvZ3JhbURhdGVUaW1lICYmIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lKSB7XHJcbiAgICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IG5ldyBEYXRlKERhdGUucGFyc2UodGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0ZVRpbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgYnl0ZVJhbmdlKCkge1xyXG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcclxuICAgICAgbGV0IGJ5dGVSYW5nZSA9IHRoaXMuX2J5dGVSYW5nZSA9IFtdO1xyXG4gICAgICBpZiAodGhpcy5yYXdCeXRlUmFuZ2UpIHtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnJhd0J5dGVSYW5nZS5zcGxpdCgnQCcsIDIpO1xyXG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICBjb25zdCBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID0gdGhpcy5sYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0O1xyXG4gICAgICAgICAgYnl0ZVJhbmdlWzBdID0gbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA/IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgOiAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBieXRlUmFuZ2VbMF0gPSBwYXJzZUludChwYXJhbXNbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBieXRlUmFuZ2VbMV0gPSBwYXJzZUludChwYXJhbXNbMF0pICsgYnl0ZVJhbmdlWzBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJ5dGVSYW5nZUVuZE9mZnNldCgpIHtcclxuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcclxuICB9XHJcblxyXG4gIGdldCBkZWNyeXB0ZGF0YSgpIHtcclxuICAgIGlmICghdGhpcy5fZGVjcnlwdGRhdGEpIHtcclxuICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSB0aGlzLmZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkodGhpcy5sZXZlbGtleSwgdGhpcy5zbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGNyZWF0ZSBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgZm9yIGEgZ2l2ZW4gc2VnbWVudFxyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxyXG4gICAqL1xyXG4gIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpIHtcclxuICAgIHZhciB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICB1aW50OFZpZXdbaV0gPSAoc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkpICYgMHhmZjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdWludDhWaWV3O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBnZXQgYSBmcmFnbWVudCdzIGRlY3J5cHRpb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50bHkgcGFyc2VkIGVuY3J5cHRpb24ga2V5IGRhdGFcclxuICAgKiBAcGFyYW0gbGV2ZWxrZXkgLSBhIHBsYXlsaXN0J3MgZW5jcnlwdGlvbiBpbmZvXHJcbiAgICogQHBhcmFtIHNlZ21lbnROdW1iZXIgLSB0aGUgZnJhZ21lbnQncyBzZWdtZW50IG51bWJlclxyXG4gICAqIEByZXR1cm5zIHsqfSAtIGFuIG9iamVjdCB0byBiZSBhcHBsaWVkIGFzIGEgZnJhZ21lbnQncyBkZWNyeXB0ZGF0YVxyXG4gICAqL1xyXG4gIGZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkobGV2ZWxrZXksIHNlZ21lbnROdW1iZXIpIHtcclxuICAgIHZhciBkZWNyeXB0ZGF0YSA9IGxldmVsa2V5O1xyXG5cclxuICAgIGlmIChsZXZlbGtleSAmJiBsZXZlbGtleS5tZXRob2QgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xyXG4gICAgICBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSgpO1xyXG4gICAgICBkZWNyeXB0ZGF0YS5tZXRob2QgPSBsZXZlbGtleS5tZXRob2Q7XHJcbiAgICAgIGRlY3J5cHRkYXRhLmJhc2V1cmkgPSBsZXZlbGtleS5iYXNldXJpO1xyXG4gICAgICBkZWNyeXB0ZGF0YS5yZWx1cmkgPSBsZXZlbGtleS5yZWx1cmk7XHJcbiAgICAgIGRlY3J5cHRkYXRhLml2ID0gdGhpcy5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGVjcnlwdGRhdGE7XHJcbiAgfVxyXG5cclxuICBjbG9uZU9iaihvYmopIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgUGxheWxpc3RMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscyxcclxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcclxuICAgICAgRXZlbnQuTEVWRUxfTE9BRElORyxcclxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORyxcclxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORyk7XHJcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xyXG4gICAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xyXG4gICAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5sb2FkZXJzID0ge307XHJcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RMb2FkaW5nKGRhdGEpIHtcclxuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlIDogJ21hbmlmZXN0J30pO1xyXG4gIH1cclxuXHJcbiAgb25MZXZlbExvYWRpbmcoZGF0YSkge1xyXG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbGV2ZWwnLCBsZXZlbCA6IGRhdGEubGV2ZWwsIGlkIDogZGF0YS5pZH0pO1xyXG4gIH1cclxuXHJcbiAgb25BdWRpb1RyYWNrTG9hZGluZyhkYXRhKSB7XHJcbiAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZSA6ICdhdWRpb1RyYWNrJywgaWQgOiBkYXRhLmlkfSk7XHJcbiAgfVxyXG5cclxuICBvblN1YnRpdGxlVHJhY2tMb2FkaW5nKGRhdGEpIHtcclxuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlIDogJ3N1YnRpdGxlVHJhY2snLCBpZCA6IGRhdGEuaWR9KTtcclxuICB9XHJcblxyXG4gIGxvYWQodXJsLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV07XHJcbiAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgIGxldCBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XHJcbiAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQudXJsID09PSB1cmwpIHtcclxuICAgICAgICBsb2dnZXIudHJhY2UoYHBsYXlsaXN0IHJlcXVlc3Qgb25nb2luZ2ApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsb2dnZXIud2FybihgYWJvcnQgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOiR7Y29udGV4dC50eXBlfWApO1xyXG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxyXG4gICAgICAgIHJldHJ5LFxyXG4gICAgICAgIHRpbWVvdXQsXHJcbiAgICAgICAgcmV0cnlEZWxheSxcclxuICAgICAgICBtYXhSZXRyeURlbGF5O1xyXG4gICAgaWYoY29udGV4dC50eXBlID09PSAnbWFuaWZlc3QnKSB7XHJcbiAgICAgIHJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xyXG4gICAgICB0aW1lb3V0ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ7XHJcbiAgICAgIHJldHJ5RGVsYXkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTtcclxuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXRyeSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeTtcclxuICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xyXG4gICAgICByZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXk7XHJcbiAgICAgIG1heFJldHJ5RGVsYXkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O1xyXG4gICAgICBsb2dnZXIubG9nKGBsb2FkaW5nIHBsYXlsaXN0IGZvciAke2NvbnRleHQudHlwZX0gJHtjb250ZXh0LmxldmVsIHx8IGNvbnRleHQuaWR9YCk7XHJcbiAgICB9XHJcbiAgICBsb2FkZXIgID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBjb250ZXh0LmxvYWRlciA9IHR5cGVvZihjb25maWcucExvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5wTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xyXG4gICAgY29udGV4dC51cmwgPSB1cmw7XHJcbiAgICBjb250ZXh0LnJlc3BvbnNlVHlwZSA9ICcnO1xyXG5cclxuICAgIGxldCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcclxuICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dCA6IHRpbWVvdXQsIG1heFJldHJ5IDogcmV0cnkgLCByZXRyeURlbGF5IDogcmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSA6IG1heFJldHJ5RGVsYXl9O1xyXG4gICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3MgOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3IgOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dCA6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07XHJcbiAgICBsb2FkZXIubG9hZChjb250ZXh0LGxvYWRlckNvbmZpZyxsb2FkZXJDYWxsYmFja3MpO1xyXG4gIH1cclxuXHJcbiAgcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcclxuICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICB9XHJcblxyXG4gIHBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsKSB7XHJcbiAgICBsZXQgbGV2ZWxzID0gW10sIHJlc3VsdDtcclxuICAgIE1BU1RFUl9QTEFZTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKXtcclxuICAgICAgY29uc3QgbGV2ZWwgPSB7fTtcclxuXHJcbiAgICAgIHZhciBhdHRycyA9IGxldmVsLmF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XHJcbiAgICAgIGxldmVsLnVybCA9IHRoaXMucmVzb2x2ZShyZXN1bHRbMl0sIGJhc2V1cmwpO1xyXG5cclxuICAgICAgdmFyIHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xyXG4gICAgICBpZihyZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgICAgIGxldmVsLmhlaWdodCA9IHJlc29sdXRpb24uaGVpZ2h0O1xyXG4gICAgICB9XHJcbiAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XHJcbiAgICAgIGxldmVsLm5hbWUgPSBhdHRycy5OQU1FO1xyXG5cclxuICAgICAgdmFyIGNvZGVjcyA9IGF0dHJzLkNPREVDUztcclxuICAgICAgaWYoY29kZWNzKSB7XHJcbiAgICAgICAgY29kZWNzID0gY29kZWNzLnNwbGl0KC9bICxdKy8pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IGNvZGVjc1tpXTtcclxuICAgICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdhdmMxJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSB0aGlzLmF2YzF0b2F2Y290aShjb2RlYyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXZlbC5hdWRpb0NvZGVjID0gY29kZWM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXZlbHMucHVzaChsZXZlbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGV2ZWxzO1xyXG4gIH1cclxuXHJcbiAgcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgYmFzZXVybCwgdHlwZSkge1xyXG4gICAgbGV0IHJlc3VsdCwgbWVkaWFzID0gW10sIGlkID0gMDtcclxuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKXtcclxuICAgICAgY29uc3QgbWVkaWEgPSB7fTtcclxuICAgICAgdmFyIGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XHJcbiAgICAgIGlmKGF0dHJzLlRZUEUgPT09IHR5cGUpIHtcclxuICAgICAgICBtZWRpYS5ncm91cElkID0gYXR0cnNbJ0dST1VQLUlEJ107XHJcbiAgICAgICAgbWVkaWEubmFtZSA9IGF0dHJzLk5BTUU7XHJcbiAgICAgICAgbWVkaWEudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XHJcbiAgICAgICAgbWVkaWEuYXV0b3NlbGVjdCA9IChhdHRycy5BVVRPU0VMRUNUID09PSAnWUVTJyk7XHJcbiAgICAgICAgbWVkaWEuZm9yY2VkID0gKGF0dHJzLkZPUkNFRCA9PT0gJ1lFUycpO1xyXG4gICAgICAgIGlmIChhdHRycy5VUkkpIHtcclxuICAgICAgICAgIG1lZGlhLnVybCA9IHRoaXMucmVzb2x2ZShhdHRycy5VUkksIGJhc2V1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZWRpYS5sYW5nID0gYXR0cnMuTEFOR1VBR0U7XHJcbiAgICAgICAgaWYoIW1lZGlhLm5hbWUpIHtcclxuICAgICAgICAgICAgbWVkaWEubmFtZSA9IG1lZGlhLmxhbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lZGlhLmlkID0gaWQrKztcclxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtZWRpYXM7XHJcbiAgfVxyXG5cclxuICBhdmMxdG9hdmNvdGkoY29kZWMpIHtcclxuICAgIHZhciByZXN1bHQsIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xyXG4gICAgaWYgKGF2Y2RhdGEubGVuZ3RoID4gMikge1xyXG4gICAgICByZXN1bHQgPSBhdmNkYXRhLnNoaWZ0KCkgKyAnLic7XHJcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgcmVzdWx0ICs9ICgnMDAwJyArIHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0ID0gY29kZWM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgcGFyc2VMZXZlbFBsYXlsaXN0KHN0cmluZywgYmFzZXVybCwgaWQsIHR5cGUpIHtcclxuICAgIHZhciBjdXJyZW50U04gPSAwLFxyXG4gICAgICAgIHRvdGFsZHVyYXRpb24gPSAwLFxyXG4gICAgICAgIGxldmVsID0ge3R5cGU6IG51bGwsIHZlcnNpb246IG51bGwsIHVybDogYmFzZXVybCwgZnJhZ21lbnRzOiBbXSwgbGl2ZTogdHJ1ZSwgc3RhcnRTTjogMH0sXHJcbiAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKSxcclxuICAgICAgICBjYyA9IDAsXHJcbiAgICAgICAgcHJldkZyYWcgPSBudWxsLFxyXG4gICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKSxcclxuICAgICAgICByZXN1bHQsXHJcbiAgICAgICAgaTtcclxuXHJcbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XHJcblxyXG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcclxuICAgICAgY29uc3QgZHVyYXRpb24gPSByZXN1bHRbMV07XHJcbiAgICAgIGlmIChkdXJhdGlvbikgeyAvLyBJTkZcclxuICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7XHJcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxyXG4gICAgICAgIGNvbnN0IHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XHJcbiAgICAgICAgZnJhZy50aXRsZSA9IHRpdGxlID8gdGl0bGUgOiBudWxsO1xyXG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHRpdGxlID8gWyAnSU5GJyxkdXJhdGlvbix0aXRsZSBdIDogWyAnSU5GJyxkdXJhdGlvbiBdKTtcclxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHsgLy8gdXJsXHJcbiAgICAgICAgaWYgKCFpc05hTihmcmFnLmR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgY29uc3Qgc24gPSBjdXJyZW50U04rKztcclxuICAgICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcclxuICAgICAgICAgIGZyYWcubGV2ZWxrZXkgPSBsZXZlbGtleTtcclxuICAgICAgICAgIGZyYWcuc24gPSBzbjtcclxuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcclxuICAgICAgICAgIGZyYWcuY2MgPSBjYztcclxuICAgICAgICAgIGZyYWcuYmFzZXVybCA9IGJhc2V1cmw7XHJcbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XHJcbiAgICAgICAgICBmcmFnLnJlbHVybCA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xyXG5cclxuICAgICAgICAgIGxldmVsLmZyYWdtZW50cy5wdXNoKGZyYWcpO1xyXG4gICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xyXG4gICAgICAgICAgdG90YWxkdXJhdGlvbiArPSBmcmFnLmR1cmF0aW9uO1xyXG5cclxuICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7IC8vIFgtQllURVJBTkdFXHJcbiAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSAoJyAnICsgcmVzdWx0WzRdKS5zbGljZSgxKTtcclxuICAgICAgICBpZiAocHJldkZyYWcpIHtcclxuICAgICAgICAgIGNvbnN0IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBwcmV2RnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XHJcbiAgICAgICAgICBpZiAobGFzdEJ5dGVSYW5nZUVuZE9mZnNldCkge1xyXG4gICAgICAgICAgICBmcmFnLmxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNV0pIHsgLy8gUFJPR1JBTS1EQVRFLVRJTUVcclxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XHJcbiAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSAoJyAnICsgcmVzdWx0WzVdKS5zbGljZSgxKTtcclxuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ1BST0dSQU0tREFURS1USU1FJywgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWVdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XHJcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKHJlc3VsdFtpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxyXG4gICAgICAgIGNvbnN0IHZhbHVlMSA9ICgnICcgKyByZXN1bHRbaSsxXSkuc2xpY2UoMSk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUyID0gKCcgJyArIHJlc3VsdFtpKzJdKS5zbGljZSgxKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChyZXN1bHRbaV0pIHtcclxuICAgICAgICAgIGNhc2UgJyMnOlxyXG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh2YWx1ZTIgPyBbIHZhbHVlMSx2YWx1ZTIgXSA6IFsgdmFsdWUxIF0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ1BMQVlMSVNULVRZUEUnOlxyXG4gICAgICAgICAgICBsZXZlbC50eXBlID0gdmFsdWUxLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnTUVESUEtU0VRVUVOQ0UnOlxyXG4gICAgICAgICAgICBjdXJyZW50U04gPSBsZXZlbC5zdGFydFNOID0gcGFyc2VJbnQodmFsdWUxKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdUQVJHRVREVVJBVElPTic6XHJcbiAgICAgICAgICAgIGxldmVsLnRhcmdldGR1cmF0aW9uID0gcGFyc2VGbG9hdCh2YWx1ZTEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxyXG4gICAgICAgICAgICBsZXZlbC52ZXJzaW9uID0gcGFyc2VJbnQodmFsdWUxKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdFWFRNM1UnOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ0VORExJU1QnOlxyXG4gICAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnRElTJzpcclxuICAgICAgICAgICAgY2MrKztcclxuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydESVMnXSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWS1TRVEnOlxyXG4gICAgICAgICAgICBjYyA9IHBhcnNlSW50KHZhbHVlMSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnS0VZJzpcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1odHRwLWxpdmUtc3RyZWFtaW5nLTA4I3NlY3Rpb24tMy40LjRcclxuICAgICAgICAgICAgdmFyIGRlY3J5cHRwYXJhbXMgPSB2YWx1ZTE7XHJcbiAgICAgICAgICAgIHZhciBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChkZWNyeXB0cGFyYW1zKTtcclxuICAgICAgICAgICAgdmFyIGRlY3J5cHRtZXRob2QgPSBrZXlBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdNRVRIT0QnKSxcclxuICAgICAgICAgICAgICAgIGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkksXHJcbiAgICAgICAgICAgICAgICBkZWNyeXB0aXYgPSBrZXlBdHRycy5oZXhhZGVjaW1hbEludGVnZXIoJ0lWJyk7XHJcbiAgICAgICAgICAgIGlmIChkZWNyeXB0bWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKTtcclxuICAgICAgICAgICAgICBpZiAoKGRlY3J5cHR1cmkpICYmIChbJ0FFUy0xMjgnLCAnU0FNUExFLUFFUyddLmluZGV4T2YoZGVjcnlwdG1ldGhvZCkgPj0gMCkpIHtcclxuICAgICAgICAgICAgICAgIGxldmVsa2V5Lm1ldGhvZCA9IGRlY3J5cHRtZXRob2Q7XHJcbiAgICAgICAgICAgICAgICAvLyBVUkkgdG8gZ2V0IHRoZSBrZXlcclxuICAgICAgICAgICAgICAgIGxldmVsa2V5LmJhc2V1cmkgPSBiYXNldXJsO1xyXG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkucmVsdXJpID0gZGVjcnlwdHVyaTtcclxuICAgICAgICAgICAgICAgIGxldmVsa2V5LmtleSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKElWKVxyXG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkuaXYgPSBkZWNyeXB0aXY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnU1RBUlQnOlxyXG4gICAgICAgICAgICBsZXQgc3RhcnRQYXJhbXMgPSB2YWx1ZTE7XHJcbiAgICAgICAgICAgIGxldCBzdGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHN0YXJ0UGFyYW1zKTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XHJcbiAgICAgICAgICAgIC8vVElNRS1PRkZTRVQgY2FuIGJlIDBcclxuICAgICAgICAgICAgaWYgKCAhaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSApIHtcclxuICAgICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBzdGFydFRpbWVPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdNQVAnOlxyXG4gICAgICAgICAgICBsZXQgbWFwQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcclxuICAgICAgICAgICAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XHJcbiAgICAgICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gbWFwQXR0cnMuQllURVJBTkdFO1xyXG4gICAgICAgICAgICBmcmFnLmJhc2V1cmwgPSBiYXNldXJsO1xyXG4gICAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XHJcbiAgICAgICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xyXG4gICAgICAgICAgICBsZXZlbC5pbml0U2VnbWVudCA9IGZyYWc7XHJcbiAgICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAke3Jlc3VsdH1gKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmcmFnID0gcHJldkZyYWc7XHJcbiAgICAvL2xvZ2dlci5sb2coJ2ZvdW5kICcgKyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoICsgJyBmcmFnbWVudHMnKTtcclxuICAgIGlmKGZyYWcgJiYgIWZyYWcucmVsdXJsKSB7XHJcbiAgICAgIGxldmVsLmZyYWdtZW50cy5wb3AoKTtcclxuICAgICAgdG90YWxkdXJhdGlvbi09ZnJhZy5kdXJhdGlvbjtcclxuICAgIH1cclxuICAgIGxldmVsLnRvdGFsZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uO1xyXG4gICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGxldmVsLmZyYWdtZW50cy5sZW5ndGg7XHJcbiAgICBsZXZlbC5lbmRTTiA9IGN1cnJlbnRTTiAtIDE7XHJcbiAgICByZXR1cm4gbGV2ZWw7XHJcbiAgfVxyXG5cclxuICBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcclxuICAgIHZhciBzdHJpbmcgPSByZXNwb25zZS5kYXRhLFxyXG4gICAgICAgIHVybCA9IHJlc3BvbnNlLnVybCxcclxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlLFxyXG4gICAgICAgIGlkID0gY29udGV4dC5pZCxcclxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWwsXHJcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XHJcblxyXG4gICAgdGhpcy5sb2FkZXJzW3R5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgLy8gcmVzcG9uc2VVUkwgbm90IHN1cHBvcnRlZCBvbiBzb21lIGJyb3dzZXJzIChpdCBpcyB1c2VkIHRvIGRldGVjdCBVUkwgcmVkaXJlY3Rpb24pXHJcbiAgICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxyXG4gICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XHJcbiAgICAgIC8vIGZhbGxiYWNrIHRvIGluaXRpYWwgVVJMXHJcbiAgICAgIHVybCA9IGNvbnRleHQudXJsO1xyXG4gICAgfVxyXG4gICAgc3RhdHMudGxvYWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIC8vc3RhdHMubXRpbWUgPSBuZXcgRGF0ZSh0YXJnZXQuZ2V0UmVzcG9uc2VIZWFkZXIoJ0xhc3QtTW9kaWZpZWQnKSk7XHJcbiAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRNM1UnKSA9PT0gMCkge1xyXG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRJTkY6JykgPiAwKSB7XHJcbiAgICAgICAgbGV0IGlzTGV2ZWwgPSAodHlwZSAhPT0gJ2F1ZGlvVHJhY2snICYmIHR5cGUgIT09ICdzdWJ0aXRsZVRyYWNrJyksXHJcbiAgICAgICAgICAgIGxldmVsSWQgPSAhaXNOYU4obGV2ZWwpID8gbGV2ZWwgOiAhaXNOYU4oaWQpID8gaWQgOiAwLFxyXG4gICAgICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLnBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIHVybCwgbGV2ZWxJZCwgKHR5cGUgPT09ICdhdWRpb1RyYWNrJyA/ICdhdWRpbycgOiAodHlwZSA9PT0gJ3N1YnRpdGxlVHJhY2snID8gJ3N1YnRpdGxlJyA6ICdtYWluJykgKSk7XHJcbiAgICAgICAgICAgIGxldmVsRGV0YWlscy50bG9hZCA9IHN0YXRzLnRsb2FkO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAnbWFuaWZlc3QnKSB7XHJcbiAgICAgICAgLy8gZmlyc3QgcmVxdWVzdCwgc3RyZWFtIG1hbmlmZXN0IChubyBtYXN0ZXIgcGxheWxpc3QpLCBmaXJlIG1hbmlmZXN0IGxvYWRlZCBldmVudCB3aXRoIGxldmVsIGRldGFpbHNcclxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge2xldmVsczogW3t1cmw6IHVybCwgZGV0YWlscyA6IGxldmVsRGV0YWlsc31dLCBhdWRpb1RyYWNrcyA6IFtdLCB1cmw6IHVybCwgc3RhdHM6IHN0YXRzfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBpZiAobGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICBpZiAoaXNMZXZlbCkge1xyXG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FERUQsIHtkZXRhaWxzOiBsZXZlbERldGFpbHMsIGxldmVsOiBsZXZlbCB8fCAwLCBpZDogaWQgfHwgMCwgc3RhdHM6IHN0YXRzfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvVHJhY2snKSB7XHJcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVELCB7ZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBpZDogaWQsIHN0YXRzOiBzdGF0c30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdWJ0aXRsZVRyYWNrJykge1xyXG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCwge2RldGFpbHM6IGxldmVsRGV0YWlscywgaWQ6IGlkLCBzdGF0czogc3RhdHN9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IHVybCwgcmVhc29uOiAnaW52YWxpZCB0YXJnZXRkdXJhdGlvbid9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGxldmVscyA9IHRoaXMucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCk7XHJcbiAgICAgICAgLy8gbXVsdGkgbGV2ZWwgcGxheWxpc3QsIHBhcnNlIGxldmVsIGluZm9cclxuICAgICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgbGV0IGF1ZGlvVHJhY2tzID0gdGhpcy5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdBVURJTycpO1xyXG4gICAgICAgICAgbGV0IHN1YnRpdGxlcyA9IHRoaXMucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnU1VCVElUTEVTJyk7XHJcbiAgICAgICAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxyXG4gICAgICAgICAgICBsZXQgZW1iZWRkZWRBdWRpb0ZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goYXVkaW9UcmFjayA9PiB7XHJcbiAgICAgICAgICAgICAgaWYoIWF1ZGlvVHJhY2sudXJsKSB7XHJcbiAgICAgICAgICAgICAgICBlbWJlZGRlZEF1ZGlvRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGlmIG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIGRlZmluZWQsIGJ1dCBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCB3ZSBuZWVkIHRvIHNpZ25hbCB0aGlzIG1haW4gYXVkaW8gdHJhY2tcclxuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aCBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKSBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcclxuICAgICAgICAgICAgaWYgKGVtYmVkZGVkQXVkaW9Gb3VuZCA9PT0gZmFsc2UgJiYgbGV2ZWxzWzBdLmF1ZGlvQ29kZWMgJiYgIWxldmVsc1swXS5hdHRycy5BVURJTykge1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coJ2F1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIGJ1dCBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBzaWduYWxlZCwgY3JlYXRlIG9uZScpO1xyXG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoeyB0eXBlIDogJ21haW4nLCBuYW1lIDogJ21haW4nfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge2xldmVscywgYXVkaW9UcmFja3MsIHN1YnRpdGxlcywgdXJsLCBzdGF0c30pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IHVybCwgcmVhc29uOiAnbm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3QnfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IHVybCwgcmVhc29uOiAnbm8gRVhUTTNVIGRlbGltaXRlcid9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxvYWRlcnJvcihyZXNwb25zZSwgY29udGV4dCkge1xyXG4gICAgdmFyIGRldGFpbHMsIGZhdGFsLGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xyXG4gICAgc3dpdGNoKGNvbnRleHQudHlwZSkge1xyXG4gICAgICBjYXNlICdtYW5pZmVzdCc6XHJcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SO1xyXG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnbGV2ZWwnOlxyXG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjtcclxuICAgICAgICBmYXRhbCA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdhdWRpb1RyYWNrJzpcclxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XHJcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZGV0YWlscywgZmF0YWw6IGZhdGFsLCB1cmw6IGxvYWRlci51cmwsIGxvYWRlcjogbG9hZGVyLCByZXNwb25zZTogcmVzcG9uc2UsIGNvbnRleHQgOiBjb250ZXh0fSk7XHJcbiAgfVxyXG5cclxuICBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCkge1xyXG4gICAgdmFyIGRldGFpbHMsIGZhdGFsLCBsb2FkZXIgPSBjb250ZXh0LmxvYWRlcjtcclxuICAgIHN3aXRjaChjb250ZXh0LnR5cGUpIHtcclxuICAgICAgY2FzZSAnbWFuaWZlc3QnOlxyXG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUO1xyXG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnbGV2ZWwnOlxyXG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUO1xyXG4gICAgICAgIGZhdGFsID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2F1ZGlvVHJhY2snOlxyXG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUO1xyXG4gICAgICAgIGZhdGFsID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IGRldGFpbHMsIGZhdGFsOiBmYXRhbCwgdXJsOiBsb2FkZXIudXJsLCBsb2FkZXI6IGxvYWRlciwgY29udGV4dCA6IGNvbnRleHR9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBsYXlsaXN0TG9hZGVyO1xyXG4iLCIvKipcclxuICogR2VuZXJhdGUgTVA0IEJveFxyXG4qL1xyXG5cclxuLy9pbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XHJcblxyXG5jb25zdCBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcclxuXHJcbmNsYXNzIE1QNCB7XHJcbiAgc3RhdGljIGluaXQoKSB7XHJcbiAgICBNUDQudHlwZXMgPSB7XHJcbiAgICAgIGF2YzE6IFtdLCAvLyBjb2RpbmduYW1lXHJcbiAgICAgIGF2Y0M6IFtdLFxyXG4gICAgICBidHJ0OiBbXSxcclxuICAgICAgZGluZjogW10sXHJcbiAgICAgIGRyZWY6IFtdLFxyXG4gICAgICBlc2RzOiBbXSxcclxuICAgICAgZnR5cDogW10sXHJcbiAgICAgIGhkbHI6IFtdLFxyXG4gICAgICBtZGF0OiBbXSxcclxuICAgICAgbWRoZDogW10sXHJcbiAgICAgIG1kaWE6IFtdLFxyXG4gICAgICBtZmhkOiBbXSxcclxuICAgICAgbWluZjogW10sXHJcbiAgICAgIG1vb2Y6IFtdLFxyXG4gICAgICBtb292OiBbXSxcclxuICAgICAgbXA0YTogW10sXHJcbiAgICAgICcubXAzJzogW10sXHJcbiAgICAgIG12ZXg6IFtdLFxyXG4gICAgICBtdmhkOiBbXSxcclxuICAgICAgcGFzcDogW10sXHJcbiAgICAgIHNkdHA6IFtdLFxyXG4gICAgICBzdGJsOiBbXSxcclxuICAgICAgc3RjbzogW10sXHJcbiAgICAgIHN0c2M6IFtdLFxyXG4gICAgICBzdHNkOiBbXSxcclxuICAgICAgc3RzejogW10sXHJcbiAgICAgIHN0dHM6IFtdLFxyXG4gICAgICB0ZmR0OiBbXSxcclxuICAgICAgdGZoZDogW10sXHJcbiAgICAgIHRyYWY6IFtdLFxyXG4gICAgICB0cmFrOiBbXSxcclxuICAgICAgdHJ1bjogW10sXHJcbiAgICAgIHRyZXg6IFtdLFxyXG4gICAgICB0a2hkOiBbXSxcclxuICAgICAgdm1oZDogW10sXHJcbiAgICAgIHNtaGQ6IFtdXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpIGluIE1QNC50eXBlcykge1xyXG4gICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgICAgTVA0LnR5cGVzW2ldID0gW1xyXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDApLFxyXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDEpLFxyXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDIpLFxyXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDMpXHJcbiAgICAgICAgXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxyXG4gICAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LCAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LFxyXG4gICAgICAweDZmLCAweDQ4LCAweDYxLCAweDZlLFxyXG4gICAgICAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXHJcbiAgICBdKTtcclxuXHJcbiAgICB2YXIgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcclxuICAgICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSwgLy8gaGFuZGxlcl90eXBlOiAnc291bidcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSxcclxuICAgICAgMHg2NCwgMHg0OCwgMHg2MSwgMHg2ZSxcclxuICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xyXG4gICAgXSk7XHJcblxyXG4gICAgTVA0LkhETFJfVFlQRVMgPSB7XHJcbiAgICAgICd2aWRlbyc6IHZpZGVvSGRscixcclxuICAgICAgJ2F1ZGlvJzogYXVkaW9IZGxyXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBkcmVmID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZW50cnlfY291bnRcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxyXG4gICAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLCAvLyAndXJsJyB0eXBlXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXHJcbiAgICBdKTtcclxuXHJcbiAgICB2YXIgc3RjbyA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvblxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGVudHJ5X2NvdW50XHJcbiAgICBdKTtcclxuXHJcbiAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xyXG5cclxuICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9zaXplXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9jb3VudFxyXG4gICAgXSk7XHJcbiAgICBNUDQuVk1IRCA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvblxyXG4gICAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAvLyBncmFwaGljc21vZGVcclxuICAgICAgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXHJcbiAgICBdKTtcclxuICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2VcclxuICAgICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxyXG4gICAgXSk7XHJcblxyXG4gICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxXSk7Ly8gZW50cnlfY291bnRcclxuXHJcbiAgICB2YXIgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsMTE1LDExMSwxMDldKTsgLy8gaXNvbVxyXG4gICAgdmFyIGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywxMTgsOTksNDldKTsgLy8gYXZjMVxyXG4gICAgdmFyIG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XHJcblxyXG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBtYWpvckJyYW5kLCBtaW5vclZlcnNpb24sIG1ham9yQnJhbmQsIGF2YzFCcmFuZCk7XHJcbiAgICBNUDQuRElORiA9IE1QNC5ib3goTVA0LnR5cGVzLmRpbmYsIE1QNC5ib3goTVA0LnR5cGVzLmRyZWYsIGRyZWYpKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBib3godHlwZSkge1xyXG4gIHZhclxyXG4gICAgcGF5bG9hZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgICBzaXplID0gOCxcclxuICAgIGkgPSBwYXlsb2FkLmxlbmd0aCxcclxuICAgIGxlbiA9IGksXHJcbiAgICByZXN1bHQ7XHJcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xyXG4gICAgcmVzdWx0WzBdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcclxuICAgIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XHJcbiAgICByZXN1bHRbMl0gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XHJcbiAgICByZXN1bHRbM10gPSBzaXplICAmIDB4ZmY7XHJcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xyXG4gICAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcclxuICAgIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcclxuICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcclxuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGhkbHIodHlwZSkge1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtZGF0KGRhdGEpIHtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcclxuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcclxuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xyXG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxyXG4gICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXHJcbiAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhGRixcclxuICAgICAgKHRpbWVzY2FsZSA+PiAgOCkgJiAweEZGLFxyXG4gICAgICB0aW1lc2NhbGUgJiAweEZGLCAvLyB0aW1lc2NhbGVcclxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDI0KSxcclxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAgOCkgJiAweEZGLFxyXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXHJcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAyNCksXHJcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxyXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gIDgpICYgMHhGRixcclxuICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweEZGLFxyXG4gICAgICAweDU1LCAweGM0LCAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxyXG4gICAgICAweDAwLCAweDAwXHJcbiAgICBdKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbWRpYSh0cmFjaykge1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gMjQpLFxyXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gMTYpICYgMHhGRixcclxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+ICA4KSAmIDB4RkYsXHJcbiAgICAgIHNlcXVlbmNlTnVtYmVyICYgMHhGRiwgLy8gc2VxdWVuY2VfbnVtYmVyXHJcbiAgICBdKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbWluZih0cmFjaykge1xyXG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcclxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBtb29mKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xyXG4gIH1cclxuLyoqXHJcbiAqIEBwYXJhbSB0cmFja3MuLi4gKG9wdGlvbmFsKSB7YXJyYXl9IHRoZSB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbW92aWVcclxuICovXHJcbiAgc3RhdGljIG1vb3YodHJhY2tzKSB7XHJcbiAgICB2YXJcclxuICAgICAgaSA9IHRyYWNrcy5sZW5ndGgsXHJcbiAgICAgIGJveGVzID0gW107XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tb292LCBNUDQubXZoZCh0cmFja3NbMF0udGltZXNjYWxlLCB0cmFja3NbMF0uZHVyYXRpb24pXS5jb25jYXQoYm94ZXMpLmNvbmNhdChNUDQubXZleCh0cmFja3MpKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbXZleCh0cmFja3MpIHtcclxuICAgIHZhclxyXG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcclxuICAgICAgYm94ZXMgPSBbXTtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbXZoZCh0aW1lc2NhbGUsZHVyYXRpb24pIHtcclxuICAgIGR1cmF0aW9uKj10aW1lc2NhbGU7XHJcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcclxuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xyXG4gICAgdmFyXHJcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXHJcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAyNCkgJiAweEZGLFxyXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhGRixcclxuICAgICAgICAodGltZXNjYWxlID4+ICA4KSAmIDB4RkYsXHJcbiAgICAgICAgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXHJcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDI0KSxcclxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcclxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gIDgpICYgMHhGRixcclxuICAgICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXHJcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcclxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcclxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gIDgpICYgMHhGRixcclxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXHJcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgLy8gMS4wIHJhdGVcclxuICAgICAgICAweDAxLCAweDAwLCAvLyAxLjAgdm9sdW1lXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcclxuICAgICAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcclxuICAgICAgXSk7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHNkdHAodHJhY2spIHtcclxuICAgIHZhclxyXG4gICAgICBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXSxcclxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpLFxyXG4gICAgICBmbGFncyxcclxuICAgICAgaTtcclxuICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXHJcbiAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XHJcbiAgICAgIGJ5dGVzW2kgKyA0XSA9IChmbGFncy5kZXBlbmRzT24gPDwgNCkgfFxyXG4gICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgMikgfFxyXG4gICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHN0YmwodHJhY2spIHtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXZjMSh0cmFjaykge1xyXG4gICAgdmFyIHNwcyA9IFtdLCBwcHMgPSBbXSwgaSwgZGF0YSwgbGVuO1xyXG4gICAgLy8gYXNzZW1ibGUgdGhlIFNQU3NcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2suc3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XHJcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgc3BzLnB1c2goKGxlbiA+Pj4gOCkgJiAweEZGKTtcclxuICAgICAgc3BzLnB1c2goKGxlbiAmIDB4RkYpKTtcclxuICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7IC8vIFNQU1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XHJcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgcHBzLnB1c2goKGxlbiA+Pj4gOCkgJiAweEZGKTtcclxuICAgICAgcHBzLnB1c2goKGxlbiAmIDB4RkYpKTtcclxuICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgICAgIDB4MDEsICAgLy8gdmVyc2lvblxyXG4gICAgICAgICAgICBzcHNbM10sIC8vIHByb2ZpbGVcclxuICAgICAgICAgICAgc3BzWzRdLCAvLyBwcm9maWxlIGNvbXBhdFxyXG4gICAgICAgICAgICBzcHNbNV0sIC8vIGxldmVsXHJcbiAgICAgICAgICAgIDB4ZmMgfCAzLCAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xyXG4gICAgICAgICAgICAweEUwIHwgdHJhY2suc3BzLmxlbmd0aCAvLyAzYml0IHJlc2VydmVkICgxMTEpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcclxuICAgICAgICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFtcclxuICAgICAgICAgICAgdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXHJcbiAgICAgICAgICBdKS5jb25jYXQocHBzKSkpLCAvLyBcIlBQU1wiXHJcbiAgICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSB0cmFjay5oZWlnaHQsXHJcbiAgICAgICAgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdLFxyXG4gICAgICAgIHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcclxuICAgIC8vY29uc29sZS5sb2coJ2F2Y2M6JyArIEhleC5oZXhEdW1wKGF2Y2MpKTtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XHJcbiAgICAgICAgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcclxuICAgICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxyXG4gICAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXHJcbiAgICAgICAgd2lkdGggJiAweGZmLCAvLyB3aWR0aFxyXG4gICAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxyXG4gICAgICAgIGhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxyXG4gICAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIGhvcml6cmVzb2x1dGlvblxyXG4gICAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgICAweDAwLCAweDAxLCAvLyBmcmFtZV9jb3VudFxyXG4gICAgICAgIDB4MTIsXHJcbiAgICAgICAgMHg2NCwgMHg2MSwgMHg2OSwgMHg2QywgLy9kYWlseW1vdGlvbi9obHMuanNcclxuICAgICAgICAweDc5LCAweDZELCAweDZGLCAweDc0LFxyXG4gICAgICAgIDB4NjksIDB4NkYsIDB4NkUsIDB4MkYsXHJcbiAgICAgICAgMHg2OCwgMHg2QywgMHg3MywgMHgyRSxcclxuICAgICAgICAweDZBLCAweDczLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBjb21wcmVzc29ybmFtZVxyXG4gICAgICAgIDB4MDAsIDB4MTgsICAgLy8gZGVwdGggPSAyNFxyXG4gICAgICAgIDB4MTEsIDB4MTFdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxyXG4gICAgICAgICAgYXZjYyxcclxuICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgICAgICAgMHgwMCwgMHgxYywgMHg5YywgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXHJcbiAgICAgICAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsIC8vIG1heEJpdHJhdGVcclxuICAgICAgICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSwgLy8gYXZnQml0cmF0ZVxyXG4gICAgICAgICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAgICAgICAoaFNwYWNpbmcgPj4gMjQpLCAgICAgICAgIC8vIGhTcGFjaW5nXHJcbiAgICAgICAgICAgIChoU3BhY2luZyA+PiAxNikgJiAweEZGLFxyXG4gICAgICAgICAgICAoaFNwYWNpbmcgPj4gIDgpICYgMHhGRixcclxuICAgICAgICAgICAgaFNwYWNpbmcgJiAweEZGLFxyXG4gICAgICAgICAgICAodlNwYWNpbmcgPj4gMjQpLCAgICAgICAgIC8vIHZTcGFjaW5nXHJcbiAgICAgICAgICAgICh2U3BhY2luZyA+PiAxNikgJiAweEZGLFxyXG4gICAgICAgICAgICAodlNwYWNpbmcgPj4gIDgpICYgMHhGRixcclxuICAgICAgICAgICAgdlNwYWNpbmcgJiAweEZGXSkpXHJcbiAgICAgICAgICApO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGVzZHModHJhY2spIHtcclxuICAgIHZhciBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcblxyXG4gICAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcclxuICAgICAgMHgxNytjb25maWdsZW4sIC8vIGxlbmd0aFxyXG4gICAgICAweDAwLCAweDAxLCAvL2VzX2lkXHJcbiAgICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxyXG5cclxuICAgICAgMHgwNCwgLy8gZGVzY3JpcHRvcl90eXBlXHJcbiAgICAgIDB4MGYrY29uZmlnbGVuLCAvLyBsZW5ndGhcclxuICAgICAgMHg0MCwgLy9jb2RlYyA6IG1wZWc0X2F1ZGlvXHJcbiAgICAgIDB4MTUsIC8vIHN0cmVhbV90eXBlXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGJ1ZmZlcl9zaXplXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1heEJpdHJhdGVcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYXZnQml0cmF0ZVxyXG5cclxuICAgICAgMHgwNSAvLyBkZXNjcmlwdG9yX3R5cGVcclxuICAgICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdCh0cmFjay5jb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTsgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxyXG4gIH1cclxuXHJcbiAgc3RhdGljIG1wNGEodHJhY2spIHtcclxuICAgIHZhciBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcclxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcclxuICAgICAgMHgwMCwgMHgxMCwgLy8gc2FtcGxlU2l6ZToxNmJpdHNcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQyXHJcbiAgICAgIChzYW1wbGVyYXRlID4+IDgpICYgMHhGRixcclxuICAgICAgc2FtcGxlcmF0ZSAmIDB4ZmYsIC8vXHJcbiAgICAgIDB4MDAsIDB4MDBdKSxcclxuICAgICAgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbXAzKHRyYWNrKSB7XHJcbiAgICB2YXIgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XHJcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlc1snLm1wMyddLCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XHJcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxyXG4gICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXHJcbiAgICAgIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xyXG4gICAgICAweDAwLCAweDAwXSkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHN0c2QodHJhY2spIHtcclxuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XHJcbiAgICAgIGlmICghdHJhY2suaXNBQUMgJiYgdHJhY2suY29kZWMgPT09ICdtcDMnKSB7XHJcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXAzKHRyYWNrKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXA0YSh0cmFjaykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIHRraGQodHJhY2spIHtcclxuICAgIHZhciBpZCA9IHRyYWNrLmlkLFxyXG4gICAgICAgIGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24qdHJhY2sudGltZXNjYWxlLFxyXG4gICAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0LFxyXG4gICAgICAgIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpLFxyXG4gICAgICAgIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDcsIC8vIGZsYWdzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcclxuICAgICAgKGlkID4+IDI0KSAmIDB4RkYsXHJcbiAgICAgIChpZCA+PiAxNikgJiAweEZGLFxyXG4gICAgICAoaWQgPj4gOCkgJiAweEZGLFxyXG4gICAgICBpZCAmIDB4RkYsIC8vIHRyYWNrX0lEXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXHJcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxyXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gIDgpICYgMHhGRixcclxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxyXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxyXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcclxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+ICA4KSAmIDB4RkYsXHJcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMCwgLy8gbGF5ZXJcclxuICAgICAgMHgwMCwgMHgwMCwgLy8gYWx0ZXJuYXRlX2dyb3VwXHJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcclxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxyXG4gICAgICAod2lkdGggPj4gOCkgJiAweEZGLFxyXG4gICAgICB3aWR0aCAmIDB4RkYsXHJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHdpZHRoXHJcbiAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxyXG4gICAgICBoZWlnaHQgJiAweEZGLFxyXG4gICAgICAweDAwLCAweDAwIC8vIGhlaWdodFxyXG4gICAgXSkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHRyYWYodHJhY2ssYmFzZU1lZGlhRGVjb2RlVGltZSkge1xyXG4gICAgdmFyIHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKSxcclxuICAgICAgICBpZCA9IHRyYWNrLmlkLFxyXG4gICAgICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKSxcclxuICAgICAgICBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZixcclxuICAgICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgICAgICAgICAgICAgKGlkID4+IDI0KSxcclxuICAgICAgICAgICAgICAgICAoaWQgPj4gMTYpICYgMFhGRixcclxuICAgICAgICAgICAgICAgICAoaWQgPj4gOCkgJiAwWEZGLFxyXG4gICAgICAgICAgICAgICAgIChpZCAmIDB4RkYpIC8vIHRyYWNrX0lEXHJcbiAgICAgICAgICAgICAgIF0pKSxcclxuICAgICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxyXG4gICAgICAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgICAgICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4yNCksXHJcbiAgICAgICAgICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMFhGRixcclxuICAgICAgICAgICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXHJcbiAgICAgICAgICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKSxcclxuICAgICAgICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PjI0KSxcclxuICAgICAgICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAwWEZGLFxyXG4gICAgICAgICAgICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDgpICYgMFhGRixcclxuICAgICAgICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkYpXHJcbiAgICAgICAgICAgICAgIF0pKSxcclxuICAgICAgICAgICAgICAgTVA0LnRydW4odHJhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgMTYgKyAvLyB0ZmhkXHJcbiAgICAgICAgICAgICAgICAgICAgMjAgKyAvLyB0ZmR0XHJcbiAgICAgICAgICAgICAgICAgICAgOCArICAvLyB0cmFmIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gbWZoZFxyXG4gICAgICAgICAgICAgICAgICAgIDggKyAgLy8gbW9vZiBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICA4KSwgIC8vIG1kYXQgaGVhZGVyXHJcbiAgICAgICAgICAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cclxuICAgKiBAcGFyYW0gdHJhY2sge29iamVjdH0gYSB0cmFjayBkZWZpbml0aW9uXHJcbiAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHRyYWNrIGJveFxyXG4gICAqL1xyXG4gIHN0YXRpYyB0cmFrKHRyYWNrKSB7XHJcbiAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHRyZXgodHJhY2spIHtcclxuICAgIHZhciBpZCA9IHRyYWNrLmlkO1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgKGlkID4+IDI0KSxcclxuICAgICAoaWQgPj4gMTYpICYgMFhGRixcclxuICAgICAoaWQgPj4gOCkgJiAwWEZGLFxyXG4gICAgIChpZCAmIDB4RkYpLCAvLyB0cmFja19JRFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBkZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXHJcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcclxuICAgIF0pKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyB0cnVuKHRyYWNrLCBvZmZzZXQpIHtcclxuICAgIHZhciBzYW1wbGVzPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxyXG4gICAgICAgIGxlbiA9IHNhbXBsZXMubGVuZ3RoLFxyXG4gICAgICAgIGFycmF5bGVuID0gMTIgKyAoMTYgKiBsZW4pLFxyXG4gICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pLFxyXG4gICAgICAgIGksc2FtcGxlLGR1cmF0aW9uLHNpemUsZmxhZ3MsY3RzO1xyXG4gICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcclxuICAgIGFycmF5LnNldChbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDBmLCAweDAxLCAvLyBmbGFnc1xyXG4gICAgICAobGVuID4+PiAyNCkgJiAweEZGLFxyXG4gICAgICAobGVuID4+PiAxNikgJiAweEZGLFxyXG4gICAgICAobGVuID4+PiA4KSAmIDB4RkYsXHJcbiAgICAgIGxlbiAmIDB4RkYsIC8vIHNhbXBsZV9jb3VudFxyXG4gICAgICAob2Zmc2V0ID4+PiAyNCkgJiAweEZGLFxyXG4gICAgICAob2Zmc2V0ID4+PiAxNikgJiAweEZGLFxyXG4gICAgICAob2Zmc2V0ID4+PiA4KSAmIDB4RkYsXHJcbiAgICAgIG9mZnNldCAmIDB4RkYgLy8gZGF0YV9vZmZzZXRcclxuICAgIF0sMCk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcclxuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XHJcbiAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcclxuICAgICAgZmxhZ3MgPSBzYW1wbGUuZmxhZ3M7XHJcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XHJcbiAgICAgIGFycmF5LnNldChbXHJcbiAgICAgICAgKGR1cmF0aW9uID4+PiAyNCkgJiAweEZGLFxyXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcclxuICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhGRixcclxuICAgICAgICBkdXJhdGlvbiAmIDB4RkYsIC8vIHNhbXBsZV9kdXJhdGlvblxyXG4gICAgICAgIChzaXplID4+PiAyNCkgJiAweEZGLFxyXG4gICAgICAgIChzaXplID4+PiAxNikgJiAweEZGLFxyXG4gICAgICAgIChzaXplID4+PiA4KSAmIDB4RkYsXHJcbiAgICAgICAgc2l6ZSAmIDB4RkYsIC8vIHNhbXBsZV9zaXplXHJcbiAgICAgICAgKGZsYWdzLmlzTGVhZGluZyA8PCAyKSB8IGZsYWdzLmRlcGVuZHNPbixcclxuICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYpIHxcclxuICAgICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQpIHxcclxuICAgICAgICAgIChmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSkgfFxyXG4gICAgICAgICAgZmxhZ3MuaXNOb25TeW5jLFxyXG4gICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweEYwIDw8IDgsXHJcbiAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MEYsIC8vIHNhbXBsZV9mbGFnc1xyXG4gICAgICAgIChjdHMgPj4+IDI0KSAmIDB4RkYsXHJcbiAgICAgICAgKGN0cyA+Pj4gMTYpICYgMHhGRixcclxuICAgICAgICAoY3RzID4+PiA4KSAmIDB4RkYsXHJcbiAgICAgICAgY3RzICYgMHhGRiAvLyBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcclxuICAgICAgXSwxMisxNippKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaW5pdFNlZ21lbnQodHJhY2tzKSB7XHJcbiAgICBpZiAoIU1QNC50eXBlcykge1xyXG4gICAgICBNUDQuaW5pdCgpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKSwgcmVzdWx0O1xyXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTVA0LkZUWVAuYnl0ZUxlbmd0aCArIG1vdmllLmJ5dGVMZW5ndGgpO1xyXG4gICAgcmVzdWx0LnNldChNUDQuRlRZUCk7XHJcbiAgICByZXN1bHQuc2V0KG1vdmllLCBNUDQuRlRZUC5ieXRlTGVuZ3RoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNUDQ7XHJcbiIsIi8qKlxyXG4gKiBmTVA0IHJlbXV4ZXJcclxuKi9cclxuXHJcblxyXG5pbXBvcnQgQUFDIGZyb20gJy4uL2hlbHBlci9hYWMnO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCBNUDQgZnJvbSAnLi4vcmVtdXgvbXA0LWdlbmVyYXRvcic7XHJcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5cclxuLy8gMTAgc2Vjb25kc1xyXG5jb25zdCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OID0gMTAgKiAxMDAwO1xyXG5cclxuY2xhc3MgTVA0UmVtdXhlciB7XHJcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yKSB7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XHJcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gICAgdGhpcy5pc1NhZmFyaSA9IHZlbmRvciAmJiB2ZW5kb3IuaW5kZXhPZignQXBwbGUnKSA+IC0xICYmIHVzZXJBZ2VudCAmJiAhdXNlckFnZW50Lm1hdGNoKCdDcmlPUycpO1xyXG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICB9XHJcblxyXG4gIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRUaW1lU3RhbXApIHtcclxuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcclxuICB9XHJcblxyXG4gIHJlc2V0SW5pdFNlZ21lbnQoKSB7XHJcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZW11eChhdWRpb1RyYWNrLHZpZGVvVHJhY2ssaWQzVHJhY2ssdGV4dFRyYWNrLHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICAvLyBnZW5lcmF0ZSBJbml0IFNlZ21lbnQgaWYgbmVlZGVkXHJcbiAgICBpZiAoIXRoaXMuSVNHZW5lcmF0ZWQpIHtcclxuICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssdmlkZW9UcmFjayx0aW1lT2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xyXG4gICAgICAvLyBQdXJwb3NlZnVsbHkgcmVtdXhpbmcgYXVkaW8gYmVmb3JlIHZpZGVvLCBzbyB0aGF0IHJlbXV4VmlkZW8gY2FuIHVzZSBuZXh0QXVkaW9QdHMsIHdoaWNoIGlzXHJcbiAgICAgIC8vIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cclxuICAgICAgLy9sb2dnZXIubG9nKCduYiBBQUMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XHJcbiAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cclxuICAgICAgICBpZiAoIWF1ZGlvVHJhY2sudGltZXNjYWxlKSB7XHJcbiAgICAgICAgICBsb2dnZXIud2FybigncmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyBhdWRpbyBkZXRlY3RlZCcpO1xyXG4gICAgICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssdmlkZW9UcmFjayx0aW1lT2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGF1ZGlvRGF0YSA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLHRpbWVPZmZzZXQsY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xyXG4gICAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBsZXQgYXVkaW9UcmFja0xlbmd0aDtcclxuICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcclxuICAgICAgICAgICAgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvRGF0YS5lbmRQVFMgLSBhdWRpb0RhdGEuc3RhcnRQVFM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxyXG4gICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLnRpbWVzY2FsZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybigncmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjayx2aWRlb1RyYWNrLHRpbWVPZmZzZXQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssdGltZU9mZnNldCxjb250aWd1b3VzLGF1ZGlvVHJhY2tMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgdmlkZW9EYXRhO1xyXG4gICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xyXG4gICAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB2aWRlb0RhdGEgPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjayx0aW1lT2Zmc2V0LGNvbnRpZ3VvdXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmlkZW9EYXRhICYmIGF1ZGlvVHJhY2suY29kZWMpIHtcclxuICAgICAgICAgIHRoaXMucmVtdXhFbXB0eUF1ZGlvKGF1ZGlvVHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvL2xvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcclxuICAgIGlmIChpZDNUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLnJlbXV4SUQzKGlkM1RyYWNrLHRpbWVPZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgLy9sb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XHJcbiAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMucmVtdXhUZXh0KHRleHRUcmFjayx0aW1lT2Zmc2V0KTtcclxuICAgIH1cclxuICAgIC8vbm90aWZ5IGVuZCBvZiBwYXJzaW5nXHJcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQpO1xyXG4gIH1cclxuXHJcbiAgZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLHZpZGVvVHJhY2ssdGltZU9mZnNldCkge1xyXG4gICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcixcclxuICAgICAgICBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsXHJcbiAgICAgICAgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLFxyXG4gICAgICAgIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQsXHJcbiAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wNCcsXHJcbiAgICAgICAgdHJhY2tzID0ge30sXHJcbiAgICAgICAgZGF0YSA9IHsgdHJhY2tzIDogdHJhY2tzIH0sXHJcbiAgICAgICAgY29tcHV0ZVBUU0RUUyA9ICh0aGlzLl9pbml0UFRTID09PSB1bmRlZmluZWQpLFxyXG4gICAgICAgIGluaXRQVFMsIGluaXREVFM7XHJcblxyXG4gICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcclxuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcclxuICAgIH1cclxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIGxldCdzIHVzZSBhdWRpbyBzYW1wbGluZyByYXRlIGFzIE1QNCB0aW1lIHNjYWxlLlxyXG4gICAgICAvLyByYXRpb25hbGUgaXMgdGhhdCB0aGVyZSBpcyBhIGludGVnZXIgbmIgb2YgYXVkaW8gZnJhbWVzIHBlciBhdWRpbyBzYW1wbGUgKDEwMjQgZm9yIEFBQylcclxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxyXG4gICAgICAvLyB0aGlzIGF2b2lkcyBwb3RlbnRpYWwgcm91bmRpbmcgaXNzdWUgYW5kIEFWIHN5bmMgaXNzdWVcclxuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBhdWRpb1RyYWNrLnNhbXBsZXJhdGU7XHJcbiAgICAgIGxvZ2dlci5sb2cgKGBhdWRpbyBzYW1wbGluZyByYXRlIDogJHthdWRpb1RyYWNrLnNhbXBsZXJhdGV9YCk7XHJcbiAgICAgIGlmICghYXVkaW9UcmFjay5pc0FBQykge1xyXG4gICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHsgLy8gQ2hyb21lIGFuZCBTYWZhcmlcclxuICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcclxuICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnJztcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVTdXBwb3J0ZWQubXAzKSB7IC8vIEZpcmVmb3hcclxuICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xyXG4gICAgICAgIGNvbnRhaW5lciA6IGNvbnRhaW5lcixcclxuICAgICAgICBjb2RlYyA6ICBhdWRpb1RyYWNrLmNvZGVjLFxyXG4gICAgICAgIGluaXRTZWdtZW50IDogIWF1ZGlvVHJhY2suaXNBQUMgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoKSA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxyXG4gICAgICAgIG1ldGFkYXRhIDoge1xyXG4gICAgICAgICAgY2hhbm5lbENvdW50IDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XHJcbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcclxuICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlICogdGltZU9mZnNldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIGxldCdzIHVzZSBpbnB1dCB0aW1lIHNjYWxlIGFzIE1QNCB2aWRlbyB0aW1lc2NhbGVcclxuICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cclxuICAgICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xyXG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IGlucHV0VGltZVNjYWxlO1xyXG4gICAgICB0cmFja3MudmlkZW8gPSB7XHJcbiAgICAgICAgY29udGFpbmVyIDogJ3ZpZGVvL21wNCcsXHJcbiAgICAgICAgY29kZWMgOiAgdmlkZW9UcmFjay5jb2RlYyxcclxuICAgICAgICBpbml0U2VnbWVudCA6IE1QNC5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxyXG4gICAgICAgIG1ldGFkYXRhIDoge1xyXG4gICAgICAgICAgd2lkdGggOiB2aWRlb1RyYWNrLndpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0IDogdmlkZW9UcmFjay5oZWlnaHRcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XHJcbiAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsdmlkZW9TYW1wbGVzWzBdLnB0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XHJcbiAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsdmlkZW9TYW1wbGVzWzBdLmR0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFN9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XHJcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxkYXRhKTtcclxuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XHJcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XHJcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdubyBhdWRpby92aWRlbyBzYW1wbGVzIGZvdW5kJ30pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmVtdXhWaWRlbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCkge1xyXG4gICAgdmFyIG9mZnNldCA9IDgsXHJcbiAgICAgICAgdGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlLFxyXG4gICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uLFxyXG4gICAgICAgIG1kYXQsIG1vb2YsXHJcbiAgICAgICAgZmlyc3RQVFMsIGZpcnN0RFRTLFxyXG4gICAgICAgIG5leHREVFMsXHJcbiAgICAgICAgbGFzdFBUUywgbGFzdERUUyxcclxuICAgICAgICBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzLFxyXG4gICAgICAgIG91dHB1dFNhbXBsZXMgPSBbXSxcclxuICAgICAgICBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoLFxyXG4gICAgICAgIHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZSxcclxuICAgICAgICBpbml0RFRTID0gdGhpcy5faW5pdERUUztcclxuXHJcbiAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFjay5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgLy8gICBsZXQgYXZjU2FtcGxlID0gdHJhY2suc2FtcGxlc1tpXTtcclxuICAvLyAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcclxuICAvLyAgIGxldCB1bml0c1N0cmluZyA9ICcnO1xyXG4gIC8vICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bml0cy5sZW5ndGggOyBqKyspIHtcclxuICAvLyAgICAgdW5pdHNTdHJpbmcgKz0gdW5pdHNbal0udHlwZSArICcsJztcclxuICAvLyAgICAgaWYgKHVuaXRzW2pdLmRhdGEubGVuZ3RoIDwgNTAwKSB7XHJcbiAgLy8gICAgICAgdW5pdHNTdHJpbmcgKz0gSGV4LmhleER1bXAodW5pdHNbal0uZGF0YSk7XHJcbiAgLy8gICAgIH1cclxuICAvLyAgIH1cclxuICAvLyAgIGxvZ2dlci5sb2coYXZjU2FtcGxlLnB0cyArICcvJyArIGF2Y1NhbXBsZS5kdHMgKyAnLCcgKyB1bml0c1N0cmluZyArIGF2Y1NhbXBsZS51bml0cy5sZW5ndGgpO1xyXG4gIC8vIH1cclxuXHJcbiAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcclxuICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgY29uc3QgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xyXG4gICAgICBjb25zdCBkZWx0YXB0cyA9IGEucHRzIC0gYi5wdHM7XHJcbiAgICAgIHJldHVybiBkZWx0YWR0cyA/IGRlbHRhZHRzIDogZGVsdGFwdHMgPyBkZWx0YXB0cyA6IChhLmlkIC0gYi5pZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBoYW5kbGUgYnJva2VuIHN0cmVhbXMgd2l0aCBQVFMgPCBEVFMsIHRvbGVyYW5jZSB1cCAyMDBtcyAoMTgwMDAgaW4gOTBrSHogdGltZXNjYWxlKVxyXG4gICAgbGV0IFBUU0RUU3NoaWZ0ID0gaW5wdXRTYW1wbGVzLnJlZHVjZSggKHByZXYsIGN1cnIpID0+IE1hdGgubWF4KE1hdGgubWluKHByZXYsY3Vyci5wdHMtY3Vyci5kdHMpLC0xODAwMCksMCk7XHJcbiAgICBpZiAoUFRTRFRTc2hpZnQgPCAwKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKGBQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgc2hpZnRpbmcgRFRTIGJ5ICR7TWF0aC5yb3VuZChQVFNEVFNzaGlmdC85MCl9IG1zIHRvIG92ZXJjb21lIHRoaXMgaXNzdWVgKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzICs9IFBUU0RUU3NoaWZ0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIC8vIFBUUyBpcyBjb2RlZCBvbiAzM2JpdHMsIGFuZCBjYW4gbG9vcCBmcm9tIC0yXjMyIHRvIDJeMzJcclxuICAvLyBwdHNOb3JtYWxpemUgd2lsbCBtYWtlIFBUUy9EVFMgdmFsdWUgbW9ub3RvbmljLCB3ZSB1c2UgbGFzdCBrbm93biBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlIHZhbHVlXHJcbiAgIGxldCBuZXh0QXZjRHRzO1xyXG4gICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxyXG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcclxuICAgICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxyXG4gICAgICBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxyXG4gICAgICBuZXh0QXZjRHRzID0gdGltZU9mZnNldCp0aW1lU2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29tcHV0ZSBmaXJzdCBEVFMgYW5kIGxhc3QgRFRTLCBub3JtYWxpemUgdGhlbSBhZ2FpbnN0IHJlZmVyZW5jZSB2YWx1ZVxyXG4gICAgbGV0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1swXTtcclxuICAgIGZpcnN0RFRTID0gIE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdERUUyxuZXh0QXZjRHRzKSwwKTtcclxuICAgIGZpcnN0UFRTID0gIE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdERUUyxuZXh0QXZjRHRzKSwwKTtcclxuXHJcbiAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY2Nyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXHJcbiAgICBsZXQgZGVsdGEgPSBNYXRoLnJvdW5kKChmaXJzdERUUyAtIG5leHRBdmNEdHMpIC8gOTApO1xyXG4gICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXHJcbiAgICBpZiAoY29udGlndW91cykge1xyXG4gICAgICBpZiAoZGVsdGEpIHtcclxuICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHtkZWx0YX0gbXMgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IC0xKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHsoLWRlbHRhKX0gbXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVtb3ZlIGhvbGUvZ2FwIDogc2V0IERUUyB0byBuZXh0IGV4cGVjdGVkIERUU1xyXG4gICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcclxuICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFMgKyBpbml0RFRTO1xyXG4gICAgICAgIC8vIG9mZnNldCBQVFMgYXMgd2VsbCwgZW5zdXJlIHRoYXQgUFRTIGlzIHNtYWxsZXIgb3IgZXF1YWwgdGhhbiBuZXcgRFRTXHJcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heChmaXJzdFBUUyAtIGRlbHRhLCBuZXh0QXZjRHRzKTtcclxuICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFMgKyBpbml0RFRTO1xyXG4gICAgICAgIGxvZ2dlci5sb2coYFZpZGVvL1BUUy9EVFMgYWRqdXN0ZWQ6ICR7TWF0aC5yb3VuZChmaXJzdFBUUy85MCl9LyR7TWF0aC5yb3VuZChmaXJzdERUUy85MCl9LGRlbHRhOiR7ZGVsdGF9IG1zYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG5leHREVFMgPSBmaXJzdERUUztcclxuXHJcbiAgICAvLyBjb21wdXRlIGxhc3RQVFMvbGFzdERUU1xyXG4gICAgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGgtMV07XHJcbiAgICBsYXN0RFRTID0gTWF0aC5tYXgocHRzTm9ybWFsaXplKHNhbXBsZS5kdHMgLSBpbml0RFRTLG5leHRBdmNEdHMpICwwKTtcclxuICAgIGxhc3RQVFMgPSBNYXRoLm1heChwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXREVFMsbmV4dEF2Y0R0cykgLDApO1xyXG4gICAgbGFzdFBUUyA9IE1hdGgubWF4KGxhc3RQVFMsIGxhc3REVFMpO1xyXG5cclxuICAgIGNvbnN0IGlzU2FmYXJpID0gdGhpcy5pc1NhZmFyaTtcclxuICAgICAgLy8gb24gU2FmYXJpIGxldCdzIHNpZ25hbCB0aGUgc2FtZSBzYW1wbGUgZHVyYXRpb24gZm9yIGFsbCBzYW1wbGVzXHJcbiAgICAgIC8vIHNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xyXG4gICAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxyXG4gICAgaWYgKGlzU2FmYXJpKSB7XHJcbiAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gTWF0aC5yb3VuZCgobGFzdERUUy1maXJzdERUUykvKGlucHV0U2FtcGxlcy5sZW5ndGgtMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBuYk5hbHUgPSAwLCBuYWx1TGVuID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwIDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XHJcbiAgICAgIC8vIGNvbXB1dGUgdG90YWwvYXZjIHNhbXBsZSBsZW5ndGggYW5kIG5iIG9mIE5BTCB1bml0c1xyXG4gICAgICBsZXQgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLCB1bml0cyA9IHNhbXBsZS51bml0cywgbmJVbml0cyA9IHVuaXRzLmxlbmd0aCwgc2FtcGxlTGVuID0gMDtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcclxuICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XHJcbiAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xyXG4gICAgICBzYW1wbGUubGVuZ3RoID0gc2FtcGxlTGVuO1xyXG5cclxuICAgICAgLy8gbm9ybWFsaXplIFBUUy9EVFNcclxuICAgICAgaWYgKGlzU2FmYXJpKSB7XHJcbiAgICAgICAgLy8gc2FtcGxlIERUUyBpcyBjb21wdXRlZCB1c2luZyBhIGNvbnN0YW50IGRlY29kaW5nIG9mZnNldCAobXA0U2FtcGxlRHVyYXRpb24pIGJldHdlZW4gc2FtcGxlc1xyXG4gICAgICAgIHNhbXBsZS5kdHMgPSBmaXJzdERUUyArIGkqbXA0U2FtcGxlRHVyYXRpb247XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZW5zdXJlIHNhbXBsZSBtb25vdG9uaWMgRFRTXHJcbiAgICAgICAgc2FtcGxlLmR0cyA9IE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdERUUywgbmV4dEF2Y0R0cyksZmlyc3REVFMpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHdlIG5vcm1hbGl6ZSBQVFMgYWdhaW5zdCBuZXh0QXZjRHRzLCB3ZSBhbHNvIHN1YnN0cmFjdCBpbml0RFRTIChzb21lIHN0cmVhbXMgZG9uJ3Qgc3RhcnQgQCBQVFMgTylcclxuICAgICAgLy8gYW5kIHdlIGVuc3VyZSB0aGF0IGNvbXB1dGVkIHZhbHVlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiBzYW1wbGUgRFRTXHJcbiAgICAgIHNhbXBsZS5wdHMgPSBNYXRoLm1heChwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXREVFMsbmV4dEF2Y0R0cykgLCBzYW1wbGUuZHRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXHJcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cclxuICAgIGxldCBtZGF0U2l6ZSA9IG5hbHVMZW4gKyAoNCAqIG5iTmFsdSkgKyA4O1xyXG4gICAgdHJ5IHtcclxuICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcclxuICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ5dGVzIDogbWRhdFNpemUsIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0ICR7bWRhdFNpemV9YH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XHJcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XHJcbiAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcclxuICAgICAgbGV0IGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSxcclxuICAgICAgICAgIGF2Y1NhbXBsZVVuaXRzID0gYXZjU2FtcGxlLnVuaXRzLFxyXG4gICAgICAgICAgbXA0U2FtcGxlTGVuZ3RoID0gMCxcclxuICAgICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldDtcclxuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxyXG4gICAgICBmb3IobGV0IGogPSAwLCBuYlVuaXRzID0gYXZjU2FtcGxlVW5pdHMubGVuZ3RoOyBqIDwgbmJVbml0cyA7IGorKykge1xyXG4gICAgICAgIGxldCB1bml0ID0gYXZjU2FtcGxlVW5pdHNbal0sXHJcbiAgICAgICAgICAgIHVuaXREYXRhID0gdW5pdC5kYXRhLFxyXG4gICAgICAgICAgICB1bml0RGF0YUxlbiA9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xyXG4gICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgIG1kYXQuc2V0KHVuaXREYXRhLCBvZmZzZXQpO1xyXG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcclxuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZighaXNTYWZhcmkpIHtcclxuICAgICAgICAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcclxuICAgICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcclxuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gaW5wdXRTYW1wbGVzW2krMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnLFxyXG4gICAgICAgICAgICAgIGxhc3RGcmFtZUR1cmF0aW9uID0gYXZjU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tpID4gMCA/IGktMSA6IGldLmR0cztcclxuICAgICAgICAgIGlmIChjb25maWcuc3RyZXRjaFNob3J0VmlkZW9UcmFjaykge1xyXG4gICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cclxuICAgICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cclxuICAgICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIHRoZSBtaW5pbXVtIG9mIG1heEJ1ZmZlckhvbGUgYW5kXHJcbiAgICAgICAgICAgIC8vIG1heFNlZWtIb2xlLiBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxyXG4gICAgICAgICAgICAvLyB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3QgZnJhbWUgdG8gbWluaW1pemUgYW55IHBvdGVudGlhbCBnYXAgYmV0d2VlbiBzZWdtZW50cy5cclxuICAgICAgICAgICAgbGV0IG1heEJ1ZmZlckhvbGUgPSBjb25maWcubWF4QnVmZmVySG9sZSxcclxuICAgICAgICAgICAgICAgIG1heFNlZWtIb2xlID0gY29uZmlnLm1heFNlZWtIb2xlLFxyXG4gICAgICAgICAgICAgICAgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhCdWZmZXJIb2xlLCBtYXhTZWVrSG9sZSkgKiB0aW1lU2NhbGUpLFxyXG4gICAgICAgICAgICAgICAgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBmaXJzdFBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiB0aW1lU2NhbGUgOiB0aGlzLm5leHRBdWRpb1B0cykgLSBhdmNTYW1wbGUucHRzO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXHJcbiAgICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZS9tYXhTZWVrSG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxyXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgSXQgaXMgYXBwcm94aW1hdGVseSAke2RlbHRhVG9GcmFtZUVuZC85MH0gbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gJHttcDRTYW1wbGVEdXJhdGlvbi85MH0gbXMgZm9yIHRoZSBsYXN0IHZpZGVvIGZyYW1lLmApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgubWF4KDAsbXA0U2FtcGxlRHVyYXRpb24qTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpL21wNFNhbXBsZUR1cmF0aW9uKSk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvL2NvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXZjU2FtcGxlLnB0c30vJHthdmNTYW1wbGUuZHRzfS8ke2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdmNTYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XHJcbiAgICAgIG91dHB1dFNhbXBsZXMucHVzaCh7XHJcbiAgICAgICAgc2l6ZTogbXA0U2FtcGxlTGVuZ3RoLFxyXG4gICAgICAgICAvLyBjb25zdGFudCBkdXJhdGlvblxyXG4gICAgICAgIGR1cmF0aW9uOiBtcDRTYW1wbGVEdXJhdGlvbixcclxuICAgICAgICBjdHM6IGNvbXBvc2l0aW9uVGltZU9mZnNldCxcclxuICAgICAgICBmbGFnczoge1xyXG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxyXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxyXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcclxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXHJcbiAgICAgICAgICBkZXBlbmRzT24gOiBhdmNTYW1wbGUua2V5ID8gMiA6IDEsXHJcbiAgICAgICAgICBpc05vblN5bmMgOiBhdmNTYW1wbGUua2V5ID8gMCA6IDFcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gbmV4dCBBVkMgc2FtcGxlIERUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgRFRTICsgbGFzdCBzYW1wbGUgZHVyYXRpb24gKGluIFBFUyB0aW1lc2NhbGUpXHJcbiAgICB0aGlzLm5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XHJcbiAgICBsZXQgZHJvcHBlZCA9IHRyYWNrLmRyb3BwZWQ7XHJcbiAgICB0cmFjay5sZW4gPSAwO1xyXG4gICAgdHJhY2submJOYWx1ID0gMDtcclxuICAgIHRyYWNrLmRyb3BwZWQgPSAwO1xyXG4gICAgaWYob3V0cHV0U2FtcGxlcy5sZW5ndGggJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZScpID4gLTEpIHtcclxuICAgICAgbGV0IGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcclxuICAgIC8vIGNocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxyXG4gICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxyXG4gICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xyXG4gICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xyXG4gICAgfVxyXG4gICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XHJcbiAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMgLCB0cmFjayk7XHJcbiAgICB0cmFjay5zYW1wbGVzID0gW107XHJcblxyXG4gICAgbGV0IGRhdGEgPSB7XHJcbiAgICAgIGRhdGExOiBtb29mLFxyXG4gICAgICBkYXRhMjogbWRhdCxcclxuICAgICAgc3RhcnRQVFM6IGZpcnN0UFRTIC8gdGltZVNjYWxlLFxyXG4gICAgICBlbmRQVFM6IChsYXN0UFRTICsgIG1wNFNhbXBsZUR1cmF0aW9uKSAvIHRpbWVTY2FsZSxcclxuICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gdGltZVNjYWxlLFxyXG4gICAgICBlbmREVFM6IHRoaXMubmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSxcclxuICAgICAgdHlwZTogJ3ZpZGVvJyxcclxuICAgICAgbmI6IG91dHB1dFNhbXBsZXMubGVuZ3RoLFxyXG4gICAgICBkcm9wcGVkIDogZHJvcHBlZFxyXG4gICAgfTtcclxuICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgZGF0YSk7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIHJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlLFxyXG4gICAgICAgICAgbXA0dGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlLFxyXG4gICAgICAgICAgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZS9tcDR0aW1lU2NhbGUsXHJcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLmlzQUFDID8gMTAyNCA6IDExNTIsXHJcbiAgICAgICAgICBpbnB1dFNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb24gKiBzY2FsZUZhY3RvcixcclxuICAgICAgICAgIHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZSxcclxuICAgICAgICAgIGluaXREVFMgPSB0aGlzLl9pbml0RFRTLFxyXG4gICAgICAgICAgcmF3TVBFRyA9ICF0cmFjay5pc0FBQyAmJiB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZztcclxuXHJcbiAgICB2YXIgdmlldyxcclxuICAgICAgICBvZmZzZXQgPSByYXdNUEVHID8gMCA6IDgsXHJcbiAgICAgICAgYXVkaW9TYW1wbGUsIG1wNFNhbXBsZSxcclxuICAgICAgICB1bml0LFxyXG4gICAgICAgIG1kYXQsIG1vb2YsXHJcbiAgICAgICAgZmlyc3RQVFMsIGZpcnN0RFRTLCBsYXN0RFRTLFxyXG4gICAgICAgIHB0cywgZHRzLCBwdHNub3JtLCBkdHNub3JtLFxyXG4gICAgICAgIG91dHB1dFNhbXBsZXMgPSBbXSxcclxuICAgICAgICBpbnB1dFNhbXBsZXMgPSBbXSxcclxuICAgICAgICBmaWxsRnJhbWUsIG5ld1N0YW1wLFxyXG4gICAgICAgIG5leHRBdWRpb1B0cztcclxuXHJcbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICByZXR1cm4gKGEucHRzLWIucHRzKTtcclxuICAgIH0pO1xyXG4gICAgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcclxuXHJcbiAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxyXG4gICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcclxuICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxyXG4gICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcclxuICAgIC8vICAtIGxlc3MgdGhhbiAyMCBhdWRpbyBmcmFtZXMgZGlzdGFuY2VcclxuICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXHJcbiAgICAvLyB0aGlzIGhlbHBzIGVuc3VyaW5nIGF1ZGlvIGNvbnRpbnVpdHlcclxuICAgIC8vIGFuZCB0aGlzIGFsc28gYXZvaWRzIGF1ZGlvIGdsaXRjaGVzL2N1dCB3aGVuIHN3aXRjaGluZyBxdWFsaXR5LCBvciByZXBvcnRpbmcgd3JvbmcgZHVyYXRpb24gb24gZmlyc3QgYXVkaW8gZnJhbWVcclxuXHJcbiAgICBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cztcclxuICAgIGNvbnRpZ3VvdXMgfD0gKGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvUHRzICYmXHJcbiAgICAgICAgICAgICAgICAgICAoKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0LW5leHRBdWRpb1B0cy9pbnB1dFRpbWVTY2FsZSkgPCAwLjEpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoKGlucHV0U2FtcGxlc1swXS5wdHMtbmV4dEF1ZGlvUHRzLWluaXREVFMpKSA8IDIwKmlucHV0U2FtcGxlRHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcclxuICAgICAgLy8gaWYgZnJhZ21lbnRzIGFyZSBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRpbWVPZmZzZXQgdG8gY29tcHV0ZSBuZXh0IEF1ZGlvIFBUU1xyXG4gICAgICBuZXh0QXVkaW9QdHMgPSB0aW1lT2Zmc2V0KmlucHV0VGltZVNjYWxlO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcclxuICAgIC8vIHJlc3VsdGluZyBtcDQgc2VnbWVudCwgY2F1c2luZyBzeW5jIGlzc3VlcyBhbmQgbGVhdmluZyBnYXBzIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIHNlZ21lbnQuXHJcbiAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXHJcbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XHJcbiAgICAvLyBmcmFtZS5cclxuXHJcbiAgICAvLyBvbmx5IGluamVjdC9kcm9wIGF1ZGlvIGZyYW1lcyBpbiBjYXNlIHRpbWUgb2Zmc2V0IGlzIGFjY3VyYXRlXHJcbiAgICBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIHRyYWNrLmlzQUFDKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBuZXh0UHRzTm9ybSA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7ICkge1xyXG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxyXG4gICAgICAgIHZhciBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sXHJcbiAgICAgICAgICAgIHB0c05vcm0gPSBwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXREVFMsIG5leHRBdWRpb1B0cyksXHJcbiAgICAgICAgICAgIGRlbHRhID0gcHRzTm9ybSAtIG5leHRQdHNOb3JtO1xyXG5cclxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGguYWJzKDEwMDAqZGVsdGEvaW5wdXRUaW1lU2NhbGUpO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSdyZSBvdmVybGFwcGluZyBieSBtb3JlIHRoYW4gYSBkdXJhdGlvbiwgZHJvcCB0aGlzIHNhbXBsZVxyXG4gICAgICAgIGlmIChkZWx0YSA8PSAtaW5wdXRTYW1wbGVEdXJhdGlvbikge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYERyb3BwaW5nIDEgYXVkaW8gZnJhbWUgQCAkeyhuZXh0UHRzTm9ybS9pbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke2R1cmF0aW9ufSBtcyBvdmVybGFwLmApO1xyXG4gICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIHRyYWNrLmxlbiAtPSBzYW1wbGUudW5pdC5sZW5ndGg7XHJcbiAgICAgICAgICAvLyBEb24ndCB0b3VjaCBuZXh0UHRzTm9ybSBvciBpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbnNlcnQgbWlzc2luZyBmcmFtZXMgaWY6XHJcbiAgICAgICAgLy8gMTogV2UncmUgbW9yZSB0aGFuIG9uZSBmcmFtZSBhd2F5XHJcbiAgICAgICAgLy8gMjogTm90IG1vcmUgdGhhbiBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIGF3YXlcclxuICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxyXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhID49IGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZHVyYXRpb24gPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OICYmIG5leHRQdHNOb3JtKSB7XHJcbiAgICAgICAgICB2YXIgbWlzc2luZyA9IE1hdGgucm91bmQoZGVsdGEgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKGBJbmplY3RpbmcgJHttaXNzaW5nfSBhdWRpbyBmcmFtZSBAICR7KG5leHRQdHNOb3JtL2lucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMgZHVlIHRvICR7TWF0aC5yb3VuZCgxMDAwKmRlbHRhL2lucHV0VGltZVNjYWxlKX0gbXMgZ2FwLmApO1xyXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcclxuICAgICAgICAgICAgbmV3U3RhbXAgPSBuZXh0UHRzTm9ybSArIGluaXREVFM7XHJcbiAgICAgICAgICAgIG5ld1N0YW1wID0gTWF0aC5tYXgobmV3U3RhbXAsIGluaXREVFMpO1xyXG4gICAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYyx0cmFjay5jaGFubmVsQ291bnQpO1xyXG4gICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xyXG4gICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHNhbXBsZS51bml0LnN1YmFycmF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAwLCB7dW5pdDogZmlsbEZyYW1lLCBwdHM6IG5ld1N0YW1wLCBkdHM6IG5ld1N0YW1wfSk7XHJcbiAgICAgICAgICAgIHRyYWNrLmxlbiArPSBmaWxsRnJhbWUubGVuZ3RoO1xyXG4gICAgICAgICAgICBuZXh0UHRzTm9ybSArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xyXG4gICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQWRqdXN0IHNhbXBsZSB0byBuZXh0IGV4cGVjdGVkIHB0c1xyXG4gICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBuZXh0UHRzTm9ybSArIGluaXREVFM7XHJcbiAgICAgICAgICBuZXh0UHRzTm9ybSArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xyXG4gICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgYWRqdXN0IHB0c1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+ICgwLjEgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKGBJbnZhbGlkIGZyYW1lIGRlbHRhICR7TWF0aC5yb3VuZChwdHNOb3JtIC0gbmV4dFB0c05vcm0gKyBpbnB1dFNhbXBsZUR1cmF0aW9uKX0gYXQgUFRTICR7TWF0aC5yb3VuZChwdHNOb3JtIC8gOTApfSAoc2hvdWxkIGJlICR7TWF0aC5yb3VuZChpbnB1dFNhbXBsZUR1cmF0aW9uKX0pLmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbmV4dFB0c05vcm0gKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcclxuICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gaW5pdERUUyArIG5leHRBdWRpb1B0cztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gaW5wdXRTYW1wbGVzW2kgLSAxXS5wdHMgKyBpbnB1dFNhbXBsZUR1cmF0aW9uO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmb3IgKGxldCBqID0wICwgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDsgaiA8IG5iU2FtcGxlcyA7IGorKykge1xyXG4gICAgICBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tqXTtcclxuICAgICAgdW5pdCA9IGF1ZGlvU2FtcGxlLnVuaXQ7XHJcbiAgICAgIHB0cyA9IGF1ZGlvU2FtcGxlLnB0cyAtIGluaXREVFM7XHJcbiAgICAgIGR0cyA9IGF1ZGlvU2FtcGxlLmR0cyAtIGluaXREVFM7XHJcbiAgICAgIC8vbG9nZ2VyLmxvZyhgQXVkaW8vUFRTOiR7TWF0aC5yb3VuZChwdHMvOTApfWApO1xyXG4gICAgICAvLyBpZiBub3QgZmlyc3Qgc2FtcGxlXHJcbiAgICAgIGlmIChsYXN0RFRTICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBwdHNub3JtID0gcHRzTm9ybWFsaXplKHB0cywgbGFzdERUUyk7XHJcbiAgICAgICAgZHRzbm9ybSA9IHB0c05vcm1hbGl6ZShkdHMsIGxhc3REVFMpO1xyXG4gICAgICAgIG1wNFNhbXBsZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoKGR0c25vcm0gLSBsYXN0RFRTKSAvIHNjYWxlRmFjdG9yKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwdHNub3JtID0gcHRzTm9ybWFsaXplKHB0cywgbmV4dEF1ZGlvUHRzKTtcclxuICAgICAgICBkdHNub3JtID0gcHRzTm9ybWFsaXplKGR0cywgbmV4dEF1ZGlvUHRzKTtcclxuICAgICAgICBsZXQgZGVsdGEgPSBNYXRoLnJvdW5kKDEwMDAgKiAocHRzbm9ybSAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFRpbWVTY2FsZSksXHJcbiAgICAgICAgICAgIG51bU1pc3NpbmdGcmFtZXMgPSAwO1xyXG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xyXG4gICAgICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXHJcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suaXNBQUMpIHtcclxuICAgICAgICAgIC8vIGxvZyBkZWx0YVxyXG4gICAgICAgICAgaWYgKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDAgJiYgZGVsdGEgPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OKSB7XHJcbiAgICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IE1hdGgucm91bmQoKHB0c25vcm0gLSBuZXh0QXVkaW9QdHMpIC8gaW5wdXRTYW1wbGVEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgJHtkZWx0YX0gbXMgaG9sZSBiZXR3ZWVuIEFBQyBzYW1wbGVzIGRldGVjdGVkLGZpbGxpbmcgaXRgKTtcclxuICAgICAgICAgICAgICBpZiAobnVtTWlzc2luZ0ZyYW1lcyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLHRyYWNrLmNoYW5uZWxDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnN1YmFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cmFjay5sZW4gKz0gbnVtTWlzc2luZ0ZyYW1lcyAqIGZpbGxGcmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgZnJhbWUgb3ZlcmxhcCwgb3ZlcmxhcHBpbmcgZm9yIG1vcmUgdGhhbiBoYWxmIGEgZnJhbWUgZHVyYWlvblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgLTEyKSB7XHJcbiAgICAgICAgICAgICAgLy8gZHJvcCBvdmVybGFwcGluZyBhdWRpbyBmcmFtZXMuLi4gYnJvd3NlciB3aWxsIGRlYWwgd2l0aCBpdFxyXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGRyb3Agb3ZlcmxhcHBpbmcgQUFDIHNhbXBsZSwgZXhwZWN0ZWQvcGFyc2VkL2RlbHRhOiR7KG5leHRBdWRpb1B0cy9pbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zLyR7KHB0c25vcm0vaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMyl9cy8keygtZGVsdGEpfW1zYCk7XHJcbiAgICAgICAgICAgICAgdHJhY2subGVuIC09IHVuaXQuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXHJcbiAgICAgICAgICAgIHB0c25vcm0gPSBkdHNub3JtID0gbmV4dEF1ZGlvUHRzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2Ygb3VyIGF1ZGlvU2FtcGxlcywgZW5zdXJlIHZhbHVlIGlzIHBvc2l0aXZlXHJcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heCgwLCBwdHNub3JtKTtcclxuICAgICAgICBmaXJzdERUUyA9IE1hdGgubWF4KDAsIGR0c25vcm0pO1xyXG4gICAgICAgIGlmKHRyYWNrLmxlbiA+IDApIHtcclxuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcclxuICAgICAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtZGF0IHR5cGUpICovXHJcblxyXG5cclxuICAgICAgICAgIGxldCBtZGF0U2l6ZSA9IHJhd01QRUcgPyB0cmFjay5sZW4gOiB0cmFjay5sZW4gKyA4O1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcclxuICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ5dGVzIDogbWRhdFNpemUsIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0ICR7bWRhdFNpemV9YH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcclxuICAgICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcclxuICAgICAgICAgICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTWlzc2luZ0ZyYW1lczsgaSsrKSB7XHJcbiAgICAgICAgICBuZXdTdGFtcCA9IHB0c25vcm0gLSAobnVtTWlzc2luZ0ZyYW1lcyAtIGkpICogaW5wdXRTYW1wbGVEdXJhdGlvbjtcclxuICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLHRyYWNrLmNoYW5uZWxDb3VudCk7XHJcbiAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIHRoaXMgZnJhbWUgaW5zdGVhZC4nKTtcclxuICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbWRhdC5zZXQoZmlsbEZyYW1lLCBvZmZzZXQpO1xyXG4gICAgICAgICAgb2Zmc2V0ICs9IGZpbGxGcmFtZS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgbXA0U2FtcGxlID0ge1xyXG4gICAgICAgICAgICBzaXplOiBmaWxsRnJhbWUuYnl0ZUxlbmd0aCxcclxuICAgICAgICAgICAgY3RzOiAwLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMTAyNCxcclxuICAgICAgICAgICAgZmxhZ3M6IHtcclxuICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxyXG4gICAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXHJcbiAgICAgICAgICAgICAgZGVncmFkUHJpbzogMCxcclxuICAgICAgICAgICAgICBkZXBlbmRzT246IDEsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcclxuICAgICAgbGV0IHVuaXRMZW4gPSB1bml0LmJ5dGVMZW5ndGg7XHJcbiAgICAgIG9mZnNldCArPSB1bml0TGVuO1xyXG4gICAgICAvL2NvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXVkaW9TYW1wbGUucHRzfS8ke2F1ZGlvU2FtcGxlLmR0c30vJHtpbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYXVkaW9TYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XHJcbiAgICAgIG1wNFNhbXBsZSA9IHtcclxuICAgICAgICBzaXplOiB1bml0TGVuLFxyXG4gICAgICAgIGN0czogMCxcclxuICAgICAgICBkdXJhdGlvbjogMCxcclxuICAgICAgICBmbGFnczoge1xyXG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxyXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxyXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcclxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXHJcbiAgICAgICAgICBkZXBlbmRzT246IDEsXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcclxuICAgICAgbGFzdERUUyA9IGR0c25vcm07XHJcbiAgICB9XHJcbiAgICB2YXIgbGFzdFNhbXBsZUR1cmF0aW9uID0gMDtcclxuICAgIHZhciBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcclxuICAgIC8vc2V0IGxhc3Qgc2FtcGxlIGR1cmF0aW9uIGFzIGJlaW5nIGlkZW50aWNhbCB0byBwcmV2aW91cyBzYW1wbGVcclxuICAgIGlmIChuYlNhbXBsZXMgPj0gMikge1xyXG4gICAgICBsYXN0U2FtcGxlRHVyYXRpb24gPSBvdXRwdXRTYW1wbGVzW25iU2FtcGxlcyAtIDJdLmR1cmF0aW9uO1xyXG4gICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBsYXN0U2FtcGxlRHVyYXRpb247XHJcbiAgICB9XHJcbiAgICBpZiAobmJTYW1wbGVzKSB7XHJcbiAgICAgIC8vIG5leHQgYXVkaW8gc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZHVyYXRpb25cclxuICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBwdHNub3JtICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlRHVyYXRpb247XHJcbiAgICAgIC8vbG9nZ2VyLmxvZygnQXVkaW8vUFRTL1BUU2VuZDonICsgYXVkaW9TYW1wbGUucHRzLnRvRml4ZWQoMCkgKyAnLycgKyB0aGlzLm5leHRBYWNEdHMudG9GaXhlZCgwKSk7XHJcbiAgICAgIHRyYWNrLmxlbiA9IDA7XHJcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xyXG4gICAgICBpZiAocmF3TVBFRykge1xyXG4gICAgICAgIG1vb2YgPSBuZXcgVWludDhBcnJheSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUyAvIHNjYWxlRmFjdG9yLCB0cmFjayk7XHJcbiAgICAgIH1cclxuICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xyXG4gICAgICBsZXQgYXVkaW9EYXRhID0ge1xyXG4gICAgICAgIGRhdGExOiBtb29mLFxyXG4gICAgICAgIGRhdGEyOiBtZGF0LFxyXG4gICAgICAgIHN0YXJ0UFRTOiBmaXJzdFBUUyAvIGlucHV0VGltZVNjYWxlLFxyXG4gICAgICAgIGVuZFBUUzogdGhpcy5uZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZSxcclxuICAgICAgICBzdGFydERUUzogZmlyc3REVFMgLyBpbnB1dFRpbWVTY2FsZSxcclxuICAgICAgICBlbmREVFM6IChkdHNub3JtICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlRHVyYXRpb24pIC8gaW5wdXRUaW1lU2NhbGUsXHJcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcclxuICAgICAgICBuYjogbmJTYW1wbGVzXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgYXVkaW9EYXRhKTtcclxuICAgICAgcmV0dXJuIGF1ZGlvRGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgcmVtdXhFbXB0eUF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpIHtcclxuICAgIGxldCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlLFxyXG4gICAgICAgIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGUsXHJcbiAgICAgICAgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZS9tcDR0aW1lU2NhbGUsXHJcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHMsXHJcblxyXG4gICAgICAgIC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxyXG4gICAgICAgIHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gdW5kZWZpbmVkID8gbmV4dEF1ZGlvUHRzIDogdmlkZW9EYXRhLnN0YXJ0RFRTICogaW5wdXRUaW1lU2NhbGUpICsgdGhpcy5faW5pdERUUyxcclxuICAgICAgICBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogaW5wdXRUaW1lU2NhbGUgKyB0aGlzLl9pbml0RFRTLFxyXG4gICAgICAgIC8vIG9uZSBzYW1wbGUncyBkdXJhdGlvbiB2YWx1ZVxyXG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gMTAyNCxcclxuICAgICAgICBmcmFtZUR1cmF0aW9uID0gc2NhbGVGYWN0b3IgKiBzYW1wbGVEdXJhdGlvbixcclxuXHJcbiAgICAgICAgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxyXG4gICAgICAgIG5iU2FtcGxlcyA9IE1hdGguY2VpbCgoZW5kRFRTIC0gc3RhcnREVFMpIC8gZnJhbWVEdXJhdGlvbiksXHJcblxyXG4gICAgICAgIC8vIHNpbGVudCBmcmFtZVxyXG4gICAgICAgIHNpbGVudEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsdHJhY2suY2hhbm5lbENvdW50KTtcclxuXHJcbiAgICAgICAgbG9nZ2VyLndhcm4oJ3JlbXV4IGVtcHR5IEF1ZGlvJyk7XHJcbiAgICAvLyBDYW4ndCByZW11eCBpZiB3ZSBjYW4ndCBnZW5lcmF0ZSBhIHNpbGVudCBmcmFtZS4uLlxyXG4gICAgaWYgKCFzaWxlbnRGcmFtZSkge1xyXG4gICAgICBsb2dnZXIudHJhY2UoJ1VuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYyEnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzYW1wbGVzID0gW107XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcclxuICAgICAgdmFyIHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcclxuICAgICAgc2FtcGxlcy5wdXNoKHt1bml0OiBzaWxlbnRGcmFtZSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcH0pO1xyXG4gICAgICB0cmFjay5sZW4gKz0gc2lsZW50RnJhbWUubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XHJcblxyXG4gICAgdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcclxuICB9XHJcblxyXG4gIHJlbXV4SUQzKHRyYWNrLHRpbWVPZmZzZXQpIHtcclxuICAgIHZhciBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aCwgc2FtcGxlO1xyXG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcclxuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xyXG4gICAgY29uc3QgaW5pdERUUyA9IHRoaXMuX2luaXREVFM7XHJcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcclxuICAgIGlmKGxlbmd0aCkge1xyXG4gICAgICBmb3IodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcclxuICAgICAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXHJcbiAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxyXG4gICAgICAgIHNhbXBsZS5wdHMgPSAoKHNhbXBsZS5wdHMgLSBpbml0UFRTKSAvIGlucHV0VGltZVNjYWxlKTtcclxuICAgICAgICBzYW1wbGUuZHRzID0gKChzYW1wbGUuZHRzIC0gaW5pdERUUykgLyBpbnB1dFRpbWVTY2FsZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwge1xyXG4gICAgICAgIHNhbXBsZXM6dHJhY2suc2FtcGxlc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFjay5zYW1wbGVzID0gW107XHJcbiAgICB0aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcclxuICB9XHJcblxyXG4gIHJlbXV4VGV4dCh0cmFjayx0aW1lT2Zmc2V0KSB7XHJcbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICByZXR1cm4gKGEucHRzLWIucHRzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aCwgc2FtcGxlO1xyXG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcclxuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xyXG4gICAgLy8gY29uc3VtZSBzYW1wbGVzXHJcbiAgICBpZihsZW5ndGgpIHtcclxuICAgICAgZm9yKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XHJcbiAgICAgICAgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcclxuICAgICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXHJcbiAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIGluaXRQVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHtcclxuICAgICAgICBzYW1wbGVzOnRyYWNrLnNhbXBsZXNcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xyXG4gICAgdGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XHJcbiAgfVxyXG5cclxuICBfUFRTTm9ybWFsaXplKHZhbHVlLCByZWZlcmVuY2UpIHtcclxuICAgIHZhciBvZmZzZXQ7XHJcbiAgICBpZiAocmVmZXJlbmNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlZmVyZW5jZSA8IHZhbHVlKSB7XHJcbiAgICAgIC8vIC0gMl4zM1xyXG4gICAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vICsgMl4zM1xyXG4gICAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xyXG4gICAgfVxyXG4gICAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcclxuICAgICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcclxuICAgICAgUFRTIGxvb3Bpbmcgb2NjdXJlZC4gZmlsbCB0aGUgZ2FwICovXHJcbiAgICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xyXG4gICAgICAgIHZhbHVlICs9IG9mZnNldDtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNUDRSZW11eGVyO1xyXG4iLCIvKipcclxuICogcGFzc3Rocm91Z2ggcmVtdXhlclxyXG4qL1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuXHJcbmNsYXNzIFBhc3NUaHJvdWdoUmVtdXhlciB7XHJcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgfVxyXG5cclxuICByZXNldFRpbWVTdGFtcCgpIHtcclxuICB9XHJcblxyXG4gIHJlc2V0SW5pdFNlZ21lbnQoKSB7XHJcbiAgfVxyXG5cclxuICByZW11eChhdWRpb1RyYWNrLHZpZGVvVHJhY2ssaWQzVHJhY2ssdGV4dFRyYWNrLHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0LHJhd0RhdGEpIHtcclxuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XHJcbiAgICB2YXIgc3RyZWFtVHlwZSA9ICcnO1xyXG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcclxuICAgICAgc3RyZWFtVHlwZSArPSAnYXVkaW8nO1xyXG4gICAgfVxyXG4gICAgaWYgKHZpZGVvVHJhY2spIHtcclxuICAgICAgc3RyZWFtVHlwZSArPSAndmlkZW8nO1xyXG4gICAgfVxyXG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwge1xyXG4gICAgICBkYXRhMTogcmF3RGF0YSxcclxuICAgICAgc3RhcnRQVFM6IHRpbWVPZmZzZXQsXHJcbiAgICAgIHN0YXJ0RFRTOiB0aW1lT2Zmc2V0LFxyXG4gICAgICB0eXBlOiBzdHJlYW1UeXBlLFxyXG4gICAgICBuYjogMSxcclxuICAgICAgZHJvcHBlZCA6IDBcclxuICAgIH0pO1xyXG4gICAgLy9ub3RpZnkgZW5kIG9mIHBhcnNpbmdcclxuICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGFzc1Rocm91Z2hSZW11eGVyO1xyXG4iLCJjb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcclxuY29uc3QgQVRUUl9MSVNUX1JFR0VYID0gL1xccyooLis/KVxccyo9KCg/OlxcXCIuKj9cXFwiKXwuKj8pKD86LHwkKS9nO1xyXG5cclxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xyXG5jbGFzcyBBdHRyTGlzdCB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XHJcbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xyXG4gICAgICBhdHRycyA9IEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QoYXR0cnMpO1xyXG4gICAgfVxyXG4gICAgZm9yKHZhciBhdHRyIGluIGF0dHJzKXtcclxuICAgICAgaWYoYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcclxuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XHJcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XHJcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW50VmFsdWU7XHJcbiAgfVxyXG5cclxuICBoZXhhZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcclxuICAgIGlmKHRoaXNbYXR0ck5hbWVdKSB7XHJcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcclxuICAgICAgc3RyaW5nVmFsdWUgPSAoKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEpID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XHJcblxyXG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xyXG4gICAgICAgIHZhbHVlW2ldID0gcGFyc2VJbnQoc3RyaW5nVmFsdWUuc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyKGF0dHJOYW1lKSB7XHJcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxNik7XHJcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW50VmFsdWU7XHJcbiAgfVxyXG5cclxuICBkZWNpbWFsRmxvYXRpbmdQb2ludChhdHRyTmFtZSkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xyXG4gIH1cclxuXHJcbiAgZW51bWVyYXRlZFN0cmluZyhhdHRyTmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xyXG4gIH1cclxuXHJcbiAgZGVjaW1hbFJlc29sdXRpb24oYXR0ck5hbWUpIHtcclxuICAgIGNvbnN0IHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcclxuICAgIGlmIChyZXMgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcclxuICAgICAgaGVpZ2h0OiBwYXJzZUludChyZXNbMl0sIDEwKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwYXJzZUF0dHJMaXN0KGlucHV0KSB7XHJcbiAgICB2YXIgbWF0Y2gsIGF0dHJzID0ge307XHJcbiAgICBBVFRSX0xJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcclxuICAgIHdoaWxlICgobWF0Y2ggPSBBVFRSX0xJU1RfUkVHRVguZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdLCBxdW90ZSA9ICdcIic7XHJcblxyXG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihxdW90ZSkgPT09IDAgJiZcclxuICAgICAgICAgIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gKHZhbHVlLmxlbmd0aC0xKSkge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xyXG4gICAgICB9XHJcbiAgICAgIGF0dHJzW21hdGNoWzFdXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF0dHJzO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEF0dHJMaXN0O1xyXG4iLCJ2YXIgQmluYXJ5U2VhcmNoID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXHJcbiAgICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXHJcbiAgICAgKiBhbmQgZm9yIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmlzb25GdW5jdGlvblxyXG4gICAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxyXG4gICAgICogICAgICBTaG91bGQgcmV0dXJuOlxyXG4gICAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXHJcbiAgICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cclxuICAgICAqICAgICAgICAgID4gMCBpZiB0aGUgaXRlbSBpcyB0aGUgaXRlbSB5b3UncmUgbG9va2luZyBmb3IuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Kn0gVGhlIG9iamVjdCBpZiBpdCBpcyBmb3VuZCBvciBudWxsIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgc2VhcmNoOiBmdW5jdGlvbihsaXN0LCBjb21wYXJpc29uRnVuY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBtYXhJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gbnVsbDtcclxuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBudWxsO1xyXG4gICAgIFxyXG4gICAgICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xyXG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDtcclxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GdW5jdGlvbihjdXJyZW50RWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpbmFyeVNlYXJjaDtcclxuIiwiLyoqXHJcbiAqXHJcbiAqIFRoaXMgY29kZSB3YXMgcG9ydGVkIGZyb20gdGhlIGRhc2guanMgcHJvamVjdCBhdDpcclxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2Jsb2IvZGV2ZWxvcG1lbnQvZXh0ZXJuYWxzL2NlYTYwOC1wYXJzZXIuanNcclxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcclxuICpcclxuICogVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhcHBlYXJzIGJlbG93OlxyXG4gKlxyXG4gKiBUaGUgY29weXJpZ2h0IGluIHRoaXMgc29mdHdhcmUgaXMgYmVpbmcgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLFxyXG4gKiBpbmNsdWRlZCBiZWxvdy4gVGhpcyBzb2Z0d2FyZSBtYXkgYmUgc3ViamVjdCB0byBvdGhlciB0aGlyZCBwYXJ0eSBhbmQgY29udHJpYnV0b3JcclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYsIERBU0ggSW5kdXN0cnkgRm9ydW0uXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xyXG4gKiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXHJcbiAqICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXHJcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXHJcbiAqICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgQVMgSVMgQU5EIEFOWVxyXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxyXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxyXG4gKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcclxuICogIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVRcclxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxyXG4gKiAgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxyXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcclxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuICAgIC8qKlxyXG4gICAgICogIEV4Y2VwdGlvbnMgZnJvbSByZWd1bGFyIEFTQ0lJLiBDb2RlUG9pbnRzIGFyZSBtYXBwZWQgdG8gVVRGLTE2IGNvZGVzXHJcbiAgICAgKi9cclxuXHJcbnZhciBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcclxuICAgIDB4MmEgOiAweGUxLCAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XHJcbiAgICAweDVjIDogMHhlOSwgLy8gbG93ZXJjYXNlIGUsIGFjdXRlIGFjY2VudFxyXG4gICAgMHg1ZSA6IDB4ZWQsIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcclxuICAgIDB4NWYgOiAweGYzLCAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XHJcbiAgICAweDYwIDogMHhmYSwgLy8gbG93ZXJjYXNlIHUsIGFjdXRlIGFjY2VudFxyXG4gICAgMHg3YiA6IDB4ZTcsIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxyXG4gICAgMHg3YyA6IDB4ZjcsIC8vIGRpdmlzaW9uIHN5bWJvbFxyXG4gICAgMHg3ZCA6IDB4ZDEsIC8vIHVwcGVyY2FzZSBOIHRpbGRlXHJcbiAgICAweDdlIDogMHhmMSwgLy8gbG93ZXJjYXNlIG4gdGlsZGVcclxuICAgIDB4N2YgOiAweDI1ODgsIC8vIEZ1bGwgYmxvY2tcclxuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXHJcbiAgICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTEgQU5EIExPVyBCRVRXRUVOIDB4MzAgQU5EIDB4M0ZcclxuICAgIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcclxuICAgIDB4ODAgOiAweGFlLCAvLyBSZWdpc3RlcmVkIHN5bWJvbCAoUilcclxuICAgIDB4ODEgOiAweGIwLCAvLyBkZWdyZWUgc2lnblxyXG4gICAgMHg4MiA6IDB4YmQsIC8vIDEvMiBzeW1ib2xcclxuICAgIDB4ODMgOiAweGJmLCAvLyBJbnZlcnRlZCAob3BlbikgcXVlc3Rpb24gbWFya1xyXG4gICAgMHg4NCA6IDB4MjEyMiwgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXHJcbiAgICAweDg1IDogMHhhMiwgLy8gQ2VudHMgc3ltYm9sXHJcbiAgICAweDg2IDogMHhhMywgLy8gUG91bmRzIHN0ZXJsaW5nXHJcbiAgICAweDg3IDogMHgyNjZhLCAvLyBNdXNpYyA4J3RoIG5vdGVcclxuICAgIDB4ODggOiAweGUwLCAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XHJcbiAgICAweDg5IDogMHgyMCwgLy8gdHJhbnNwYXJlbnQgc3BhY2UgKHJlZ3VsYXIpXHJcbiAgICAweDhhIDogMHhlOCwgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxyXG4gICAgMHg4YiA6IDB4ZTIsIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxyXG4gICAgMHg4YyA6IDB4ZWEsIC8vIGxvd2VyY2FzZSBlLCBjaXJjdW1mbGV4IGFjY2VudFxyXG4gICAgMHg4ZCA6IDB4ZWUsIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxyXG4gICAgMHg4ZSA6IDB4ZjQsIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxyXG4gICAgMHg4ZiA6IDB4ZmIsIC8vIGxvd2VyY2FzZSB1LCBjaXJjdW1mbGV4IGFjY2VudFxyXG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcclxuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxyXG4gICAgMHg5MCA6IDB4YzEsIC8vIGNhcGl0YWwgbGV0dGVyIEEgd2l0aCBhY3V0ZVxyXG4gICAgMHg5MSA6IDB4YzksIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBhY3V0ZVxyXG4gICAgMHg5MiA6IDB4ZDMsIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxyXG4gICAgMHg5MyA6IDB4ZGEsIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBhY3V0ZVxyXG4gICAgMHg5NCA6IDB4ZGMsIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBkaWFyZXNpc1xyXG4gICAgMHg5NSA6IDB4ZmMsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xyXG4gICAgMHg5NiA6IDB4MjAxOCwgLy8gb3BlbmluZyBzaW5nbGUgcXVvdGVcclxuICAgIDB4OTcgOiAweGExLCAvLyBpbnZlcnRlZCBleGNsYW1hdGlvbiBtYXJrXHJcbiAgICAweDk4IDogMHgyYSwgLy8gYXN0ZXJpc2tcclxuICAgIDB4OTkgOiAweDIwMTksIC8vIGNsb3Npbmcgc2luZ2xlIHF1b3RlXHJcbiAgICAweDlhIDogMHgyNTAxLCAvLyBib3ggZHJhd2luZ3MgaGVhdnkgaG9yaXpvbnRhbFxyXG4gICAgMHg5YiA6IDB4YTksIC8vIGNvcHlyaWdodCBzaWduXHJcbiAgICAweDljIDogMHgyMTIwLCAvLyBTZXJ2aWNlIG1hcmtcclxuICAgIDB4OWQgOiAweDIwMjIsIC8vIChyb3VuZCkgYnVsbGV0XHJcbiAgICAweDllIDogMHgyMDFjLCAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xyXG4gICAgMHg5ZiA6IDB4MjAxZCwgLy8gUmlnaHQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXHJcbiAgICAweGEwIDogMHhjMCwgLy8gdXBwZXJjYXNlIEEsIGdyYXZlIGFjY2VudFxyXG4gICAgMHhhMSA6IDB4YzIsIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XHJcbiAgICAweGEyIDogMHhjNywgLy8gdXBwZXJjYXNlIEMgd2l0aCBjZWRpbGxhXHJcbiAgICAweGEzIDogMHhjOCwgLy8gdXBwZXJjYXNlIEUsIGdyYXZlIGFjY2VudFxyXG4gICAgMHhhNCA6IDB4Y2EsIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XHJcbiAgICAweGE1IDogMHhjYiwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGRpYXJlc2lzXHJcbiAgICAweGE2IDogMHhlYiwgLy8gbG93ZXJjYXNlIGxldHRlciBlIHdpdGggZGlhcmVzaXNcclxuICAgIDB4YTcgOiAweGNlLCAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxyXG4gICAgMHhhOCA6IDB4Y2YsIC8vIHVwcGVyY2FzZSBJLCB3aXRoIGRpYXJlc2lzXHJcbiAgICAweGE5IDogMHhlZiwgLy8gbG93ZXJjYXNlIGksIHdpdGggZGlhcmVzaXNcclxuICAgIDB4YWEgOiAweGQ0LCAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxyXG4gICAgMHhhYiA6IDB4ZDksIC8vIHVwcGVyY2FzZSBVLCBncmF2ZSBhY2NlbnRcclxuICAgIDB4YWMgOiAweGY5LCAvLyBsb3dlcmNhc2UgdSwgZ3JhdmUgYWNjZW50XHJcbiAgICAweGFkIDogMHhkYiwgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcclxuICAgIDB4YWUgOiAweGFiLCAvLyBsZWZ0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xyXG4gICAgMHhhZiA6IDB4YmIsIC8vIHJpZ2h0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xyXG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcclxuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxyXG4gICAgMHhiMCA6IDB4YzMsIC8vIFVwcGVyY2FzZSBBLCB0aWxkZVxyXG4gICAgMHhiMSA6IDB4ZTMsIC8vIExvd2VyY2FzZSBhLCB0aWxkZVxyXG4gICAgMHhiMiA6IDB4Y2QsIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcclxuICAgIDB4YjMgOiAweGNjLCAvLyBVcHBlcmNhc2UgSSwgZ3JhdmUgYWNjZW50XHJcbiAgICAweGI0IDogMHhlYywgLy8gTG93ZXJjYXNlIGksIGdyYXZlIGFjY2VudFxyXG4gICAgMHhiNSA6IDB4ZDIsIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcclxuICAgIDB4YjYgOiAweGYyLCAvLyBMb3dlcmNhc2UgbywgZ3JhdmUgYWNjZW50XHJcbiAgICAweGI3IDogMHhkNSwgLy8gVXBwZXJjYXNlIE8sIHRpbGRlXHJcbiAgICAweGI4IDogMHhmNSwgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXHJcbiAgICAweGI5IDogMHg3YiwgLy8gT3BlbiBjdXJseSBicmFjZVxyXG4gICAgMHhiYSA6IDB4N2QsIC8vIENsb3NpbmcgY3VybHkgYnJhY2VcclxuICAgIDB4YmIgOiAweDVjLCAvLyBCYWNrc2xhc2hcclxuICAgIDB4YmMgOiAweDVlLCAvLyBDYXJldFxyXG4gICAgMHhiZCA6IDB4NWYsIC8vIFVuZGVyc2NvcmVcclxuICAgIDB4YmUgOiAweDdjLCAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxyXG4gICAgMHhiZiA6IDB4MjIzYywgLy8gVGlsZGUgb3BlcmF0b3JcclxuICAgIDB4YzAgOiAweGM0LCAvLyBVcHBlcmNhc2UgQSwgdW1sYXV0XHJcbiAgICAweGMxIDogMHhlNCwgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxyXG4gICAgMHhjMiA6IDB4ZDYsIC8vIFVwcGVyY2FzZSBPLCB1bWxhdXRcclxuICAgIDB4YzMgOiAweGY2LCAvLyBMb3dlcmNhc2UgbywgdW1sYXV0XHJcbiAgICAweGM0IDogMHhkZiwgLy8gRXNzemV0dCAoc2hhcnAgUylcclxuICAgIDB4YzUgOiAweGE1LCAvLyBZZW4gc3ltYm9sXHJcbiAgICAweGM2IDogMHhhNCwgLy8gR2VuZXJpYyBjdXJyZW5jeSBzaWduXHJcbiAgICAweGM3IDogMHgyNTAzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcclxuICAgIDB4YzggOiAweGM1LCAvLyBVcHBlcmNhc2UgQSwgcmluZ1xyXG4gICAgMHhjOSA6IDB4ZTUsIC8vIExvd2VyY2FzZSBBLCByaW5nXHJcbiAgICAweGNhIDogMHhkOCwgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxyXG4gICAgMHhjYiA6IDB4ZjgsIC8vIExvd2VyY2FzZSBvLCBzdHJva1xyXG4gICAgMHhjYyA6IDB4MjUwZiwgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIHJpZ2h0XHJcbiAgICAweGNkIDogMHgyNTEzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxyXG4gICAgMHhjZSA6IDB4MjUxNywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCByaWdodFxyXG4gICAgMHhjZiA6IDB4MjUxYiAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIGxlZnRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVdGlsc1xyXG4gKi9cclxudmFyIGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24oYnl0ZSkge1xyXG4gICAgdmFyIGNoYXJDb2RlID0gYnl0ZTtcclxuICAgIGlmIChzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlcy5oYXNPd25Qcm9wZXJ0eShieXRlKSkge1xyXG4gICAgICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbYnl0ZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XHJcbn07XHJcblxyXG52YXIgTlJfUk9XUyA9IDE1LFxyXG4gICAgTlJfQ09MUyA9IDEwMDtcclxuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcclxudmFyIHJvd3NMb3dDaDEgPSB7MHgxMSA6IDEsIDB4MTIgOiAzLCAweDE1IDogNSwgMHgxNiA6IDcsIDB4MTcgOiA5LCAweDEwIDogMTEsIDB4MTMgOiAxMiwgMHgxNCA6IDE0fTtcclxudmFyIHJvd3NIaWdoQ2gxID0gezB4MTEgOiAyLCAweDEyIDogNCwgMHgxNSA6IDYsIDB4MTYgOiA4LCAweDE3IDogMTAsIDB4MTMgOiAxMywgMHgxNCA6IDE1fTtcclxudmFyIHJvd3NMb3dDaDIgPSB7MHgxOSA6IDEsIDB4MUEgOiAzLCAweDFEIDogNSwgMHgxRSA6IDcsIDB4MUYgOiA5LCAweDE4IDogMTEsIDB4MUIgOiAxMiwgMHgxQyA6IDE0fTtcclxudmFyIHJvd3NIaWdoQ2gyID0gezB4MTkgOiAyLCAweDFBIDogNCwgMHgxRCA6IDYsIDB4MUUgOiA4LCAweDFGIDogMTAsIDB4MUIgOiAxMywgMHgxQyA6IDE1fTtcclxuXHJcbnZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XHJcblxyXG4vKipcclxuICogU2ltcGxlIGxvZ2dlciBjbGFzcyB0byBiZSBhYmxlIHRvIHdyaXRlIHdpdGggdGltZS1zdGFtcHMgYW5kIGZpbHRlciBvbiBsZXZlbC5cclxuICovXHJcbnZhciBsb2dnZXIgPSB7XHJcbiAgICB2ZXJib3NlRmlsdGVyIDogeydEQVRBJyA6IDMsICdERUJVRycgOiAzLCAnSU5GTycgOiAyLCAnV0FSTklORycgOiAyLCAnVEVYVCcgOiAxLCAnRVJST1InIDogMH0sXHJcbiAgICB0aW1lIDogbnVsbCxcclxuICAgIHZlcmJvc2VMZXZlbCA6IDAsIC8vIE9ubHkgd3JpdGUgZXJyb3JzXHJcbiAgICBzZXRUaW1lIDogZnVuY3Rpb24obmV3VGltZSkge1xyXG4gICAgICAgIHRoaXMudGltZSA9IG5ld1RpbWU7XHJcbiAgICB9LFxyXG4gICAgbG9nIDogZnVuY3Rpb24oc2V2ZXJpdHksIG1zZykge1xyXG4gICAgICAgIHZhciBtaW5MZXZlbCA9IHRoaXMudmVyYm9zZUZpbHRlcltzZXZlcml0eV07XHJcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IG1pbkxldmVsKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGltZSArICcgWycgKyBzZXZlcml0eSArICddICcgKyBtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbihudW1BcnJheSkge1xyXG4gICAgdmFyIGhleEFycmF5ID0gW107XHJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgaGV4QXJyYXkucHVzaChudW1BcnJheVtqXS50b1N0cmluZygxNikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhleEFycmF5O1xyXG59O1xyXG5cclxuY2xhc3MgUGVuU3RhdGUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcclxuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XHJcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSB1bmRlcmxpbmUgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pdGFsaWNzID0gaXRhbGljcyB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XHJcbiAgICAgICAgdGhpcy5mbGFzaCA9IGZsYXNoIHx8IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XHJcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xyXG4gICAgICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTdHlsZXMoc3R5bGVzKSB7XHJcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbJ2ZvcmVncm91bmQnLCAndW5kZXJsaW5lJywgJ2l0YWxpY3MnLCAnYmFja2dyb3VuZCcsICdmbGFzaCddO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gYXR0cmlic1tpXTtcclxuICAgICAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpc0RlZmF1bHQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaCk7XHJcbiAgICB9XHJcblxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICggKHRoaXMuZm9yZWdyb3VuZCA9PT0gb3RoZXIuZm9yZWdyb3VuZCkgJiZcclxuICAgICAgICAgICAgICAgICAodGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSkgJiZcclxuICAgICAgICAgICAgICAgICAodGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzKSAmJlxyXG4gICAgICAgICAgICAgICAgICh0aGlzLmJhY2tncm91bmQgPT09IG90aGVyLmJhY2tncm91bmQpICYmXHJcbiAgICAgICAgICAgICAgICAgKHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoKSApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvcHkobmV3UGVuU3RhdGUpIHtcclxuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBuZXdQZW5TdGF0ZS5mb3JlZ3JvdW5kO1xyXG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gbmV3UGVuU3RhdGUudW5kZXJsaW5lO1xyXG4gICAgICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3UGVuU3RhdGUuYmFja2dyb3VuZDtcclxuICAgICAgICB0aGlzLmZsYXNoID0gbmV3UGVuU3RhdGUuZmxhc2g7XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgK1xyXG4gICAgICAgICAgICAnLCBiYWNrZ3JvdW5kPScgKyB0aGlzLmJhY2tncm91bmQgKyAnLCBmbGFzaD0nICsgdGhpcy5mbGFzaCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgU3R5bGVkVW5pY29kZUNoYXJcclxue1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHVjaGFyLCBmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XHJcbiAgICAgICAgdGhpcy51Y2hhciA9IHVjaGFyIHx8ICcgJzsgLy8gdW5pY29kZSBjaGFyYWN0ZXJcclxuICAgICAgICB0aGlzLnBlblN0YXRlID0gbmV3IFBlblN0YXRlKGZvcmVncm91bmQsIHVuZGVybGluZSxpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy51Y2hhciA9ICcgJztcclxuICAgICAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q2hhcih1Y2hhciwgbmV3UGVuU3RhdGUpIHtcclxuICAgICAgICB0aGlzLnVjaGFyID0gdWNoYXI7XHJcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRQZW5TdGF0ZShuZXdQZW5TdGF0ZSkge1xyXG4gICAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb3B5KG5ld0NoYXIpIHtcclxuICAgICAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcclxuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmNsYXNzIFJvdyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNoYXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUyA7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJzLnB1c2gobmV3IFN0eWxlZFVuaWNvZGVDaGFyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICB2YXIgZXF1YWwgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFM7IGkgKyspIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmVxdWFscyhvdGhlci5jaGFyc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXF1YWw7XHJcbiAgICB9XHJcblxyXG4gICAgY29weShvdGhlcikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFM7IGkgKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFM7IGkgKyspIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbXB0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cclxuICAgICAqL1xyXG4gICAgc2V0Q3Vyc29yKGFic1Bvcykge1xyXG4gICAgICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gYWJzUG9zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wb3MgPCAwKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ05lZ2F0aXZlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+IE5SX0NPTFMpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIG1vdmVDdXJzb3IocmVsUG9zKSB7XHJcbiAgICAgICAgdmFyIG5ld1BvcyA9IHRoaXMucG9zICsgcmVsUG9zO1xyXG4gICAgICAgIGlmIChyZWxQb3MgPiAxKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcysxOyBpIDwgbmV3UG9zKzEgOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnNbaV0uc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKG5ld1Bvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxyXG4gICAgICovXHJcbiAgICBiYWNrU3BhY2UoKSB7XHJcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcclxuICAgICAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKCcgJywgdGhpcy5jdXJyUGVuU3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydENoYXIoYnl0ZSkge1xyXG4gICAgICAgIGlmIChieXRlID49IDB4OTApIHsgLy9FeHRlbmRlZCBjaGFyXHJcbiAgICAgICAgICAgIHRoaXMuYmFja1NwYWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGFyID0gZ2V0Q2hhckZvckJ5dGUoYnl0ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnQ2Fubm90IGluc2VydCAnICsgYnl0ZS50b1N0cmluZygxNikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnICgnICsgY2hhciArICcpIGF0IHBvc2l0aW9uICcgKyB0aGlzLnBvcyArICcuIFNraXBwaW5nIGl0IScpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xyXG4gICAgICAgIHRoaXMubW92ZUN1cnNvcigxKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhckZyb21Qb3Moc3RhcnRQb3MpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSBzdGFydFBvcyA7IGkgPCBOUl9DT0xTIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XHJcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJUb0VuZE9mUm93KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRUZXh0U3RyaW5nKCkge1xyXG4gICAgICAgIHZhciBjaGFycyA9IFtdO1xyXG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUyA7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XHJcbiAgICAgICAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcclxuICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hhcnMucHVzaChjaGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVtcHR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldFBlblN0eWxlcyhzdHlsZXMpIHtcclxuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZS5zZXRTdHlsZXMoc3R5bGVzKTtcclxuICAgICAgICB2YXIgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcclxuICAgICAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcclxuICogQGNvbnN0cnVjdG9yXHJcbiovXHJcbmNsYXNzIENhcHRpb25TY3JlZW4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8ICBOUl9ST1dTOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2gobmV3IFJvdygpKTsgLy8gTm90ZSB0aGF0IHdlIHVzZSB6ZXJvLWJhc2VkIG51bWJlcmluZyAoMC0xNClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XHJcbiAgICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcclxuICAgIH1cclxuXHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICB2YXIgZXF1YWwgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVxdWFsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvcHkob3RoZXIpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW1wdHk7XHJcbiAgICB9XHJcblxyXG4gICAgYmFja1NwYWNlKCkge1xyXG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgICAgICByb3cuYmFja1NwYWNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJUb0VuZE9mUm93KCkge1xyXG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgICAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxyXG4gICAgICovXHJcbiAgICBpbnNlcnRDaGFyKGNoYXIpIHtcclxuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XHJcbiAgICAgICAgcm93Lmluc2VydENoYXIoY2hhcik7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UGVuKHN0eWxlcykge1xyXG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgICAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgbW92ZUN1cnNvcihyZWxQb3MpIHtcclxuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XHJcbiAgICAgICAgcm93Lm1vdmVDdXJzb3IocmVsUG9zKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDdXJzb3IoYWJzUG9zKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdzZXRDdXJzb3I6ICcgKyBhYnNQb3MpO1xyXG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgICAgICByb3cuc2V0Q3Vyc29yKGFic1Bvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UEFDKHBhY0RhdGEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3BhY0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkocGFjRGF0YSkpO1xyXG4gICAgICAgIHZhciBuZXdSb3cgPSBwYWNEYXRhLnJvdyAtIDE7XHJcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcclxuICAgICAgICAgICAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL01ha2Ugc3VyZSB0aGlzIG9ubHkgYWZmZWN0cyBSb2xsLXVwIENhcHRpb25zIGJ5IGNoZWNraW5nIHRoaXMubnJSb2xsVXBSb3dzXHJcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIHRoaXMuY3VyclJvdyAhPT0gbmV3Um93KSB7XHJcbiAgICAgICAgICAvL2NsZWFyIGFsbCByb3dzIGZpcnN0XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvL0NvcHkgdGhpcy5uclJvbGxVcFJvd3Mgcm93cyBmcm9tIGxhc3RPdXRwdXRTY3JlZW4gYW5kIHBsYWNlIGl0IGluIHRoZSBuZXdSb3cgbG9jYXRpb25cclxuICAgICAgICAgIC8vdG9wUm93SW5kZXggLSB0aGUgc3RhcnQgb2Ygcm93cyB0byBjb3B5IChpbmNsdXNpdmUgaW5kZXgpXHJcbiAgICAgICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gKHRoaXMubnJSb2xsVXBSb3dzKTtcclxuICAgICAgICAgIC8vV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxyXG4gICAgICAgICAgLy9XZSB1c2UgdGhlIGN1ZVN0YXJ0VGltZSB2YWx1ZSB0byBjaGVjayB0aGlzLlxyXG4gICAgICAgICAgY29uc3QgbGFzdE91dHB1dFNjcmVlbiA9IHRoaXMubGFzdE91dHB1dFNjcmVlbjtcclxuICAgICAgICAgIGlmIChsYXN0T3V0cHV0U2NyZWVuKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmV2TGluZVRpbWUgPSBsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXhdLmN1ZVN0YXJ0VGltZTtcclxuICAgICAgICAgICAgaWYocHJldkxpbmVUaW1lICYmIHByZXZMaW5lVGltZSA8IGxvZ2dlci50aW1lKSB7XHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5yUm9sbFVwUm93czsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93LXRoaXMubnJSb2xsVXBSb3dzK2krMV0uY29weShsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXgraV0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xyXG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgICAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xyXG4gICAgICAgICAgICB2YXIgcHJldlBvcyA9IE1hdGgubWF4KGluZGVudC0xLCAwKTtcclxuICAgICAgICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XHJcbiAgICAgICAgICAgIHBhY0RhdGEuY29sb3IgPSByb3cuY2hhcnNbcHJldlBvc10ucGVuU3RhdGUuZm9yZWdyb3VuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0eWxlcyA9IHtmb3JlZ3JvdW5kIDogcGFjRGF0YS5jb2xvciwgdW5kZXJsaW5lIDogcGFjRGF0YS51bmRlcmxpbmUsIGl0YWxpY3MgOiBwYWNEYXRhLml0YWxpY3MsIGJhY2tncm91bmQgOiAnYmxhY2snLCBmbGFzaCA6IGZhbHNlfTtcclxuICAgICAgICB0aGlzLnNldFBlbihzdHlsZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGJhY2tncm91bmQvZXh0cmEgZm9yZWdyb3VuZCwgYnV0IGZpcnN0IGRvIGJhY2tfc3BhY2UsIGFuZCB0aGVuIGluc2VydCBzcGFjZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxyXG4gICAgICovXHJcbiAgICBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcclxuXHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdia2dEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGJrZ0RhdGEpKTtcclxuICAgICAgICB0aGlzLmJhY2tTcGFjZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy9TcGFjZVxyXG4gICAgfVxyXG5cclxuICAgIHNldFJvbGxVcFJvd3MobnJSb3dzKSB7XHJcbiAgICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XHJcbiAgICB9XHJcblxyXG4gICAgcm9sbFVwKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdyb2xsX3VwIGJ1dCBuclJvbGxVcFJvd3Mgbm90IHNldCB5ZXQnKTtcclxuICAgICAgICAgICAgcmV0dXJuOyAvL05vdCBwcm9wZXJseSBzZXR1cFxyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcclxuICAgICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XHJcbiAgICAgICAgdmFyIHRvcFJvdyA9IHRoaXMucm93cy5zcGxpY2UodG9wUm93SW5kZXgsIDEpWzBdO1xyXG4gICAgICAgIHRvcFJvdy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUm9sbGluZyB1cCcpO1xyXG4gICAgICAgIC8vbG9nZ2VyLmxvZygnVEVYVCcsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxyXG4gICAgfVxyXG5cclxuICAgLyoqXHJcbiAgICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXHJcbiAgICAqL1xyXG4gICAgZ2V0RGlzcGxheVRleHQoYXNPbmVSb3cpIHtcclxuICAgICAgICBhc09uZVJvdyA9IGFzT25lUm93IHx8IGZhbHNlO1xyXG4gICAgICAgIHZhciBkaXNwbGF5VGV4dCA9IFtdO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XHJcbiAgICAgICAgdmFyIHJvd05yID0gLTE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcm93VGV4dCA9IHRoaXMucm93c1tpXS5nZXRUZXh0U3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChyb3dUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByb3dOciA9IGkrMTtcclxuICAgICAgICAgICAgICAgIGlmIChhc09uZVJvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyAnOiBcXCcnICsgcm93VGV4dCArICdcXCcnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGFzT25lUm93KSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJ1snICsgZGlzcGxheVRleHQuam9pbignIHwgJykgKyAnXSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZGlzcGxheVRleHQuam9pbignXFxuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGV4dEFuZEZvcm1hdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3dzO1xyXG4gICAgfVxyXG59XHJcblxyXG4vL3ZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XHJcblxyXG5jbGFzcyBDZWE2MDhDaGFubmVsXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxOdW1iZXIsIG91dHB1dEZpbHRlcikge1xyXG5cclxuICAgICAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xyXG4gICAgICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xyXG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJib3NlID0gMDtcclxuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XHJcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xyXG4gICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XHJcbiAgICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTLTFdO1xyXG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcclxuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDsgLy8gS2VlcHMgdHJhY2sgb2Ygd2hlcmUgYSBjdWUgc3RhcnRlZC5cclxuICAgIH1cclxuXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcclxuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcclxuICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MtMV07XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdEN1ZUVuZFRpbWUgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEhhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMub3V0cHV0RmlsdGVyID0gbmV3SGFuZGxlcjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRQQUMocGFjRGF0YSkge1xyXG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKHBhY0RhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xyXG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRNb2RlKG5ld01vZGUpIHtcclxuICAgICAgICBpZiAobmV3TW9kZSA9PT0gdGhpcy5tb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01PREU9JyArIG5ld01vZGUpO1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydENoYXJzKGNoYXJzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgY2hhcnMubGVuZ3RoIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzY3JlZW4gPSB0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSA/ICdESVNQJyA6ICdOT05fRElTUCc7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcclxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QQUlOVC1PTicgfHwgdGhpcy5tb2RlID09PSAnTU9ERV9ST0xMLVVQJykge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1BMQVlFRDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KHRydWUpKTtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNjUkNMKCkgeyAvLyBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nIChzd2l0Y2ggbW9kZSB0byBQb3AgT24pXHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSQ0wgLSBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nJyk7XHJcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNjQlMoKSB7IC8vIEJhY2tTcGFjZVxyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnQlMgLSBCYWNrU3BhY2UnKTtcclxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9URVhUJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uYmFja1NwYWNlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjY0FPRigpIHsgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9mZilcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY2NBT04oKSB7IC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY2NERVIoKSB7IC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdERVItIERlbGV0ZSB0byBFbmQgb2YgUm93Jyk7XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcclxuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjY1JVKG5yUm93cykgeyAvL1JvbGwtVXAgQ2FwdGlvbnMtMiwzLG9yIDQgUm93c1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlUoJyArIG5yUm93cyArJykgLSBSb2xsIFVwJyk7XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9ST0xMLVVQJyk7XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRSb2xsVXBSb3dzKG5yUm93cyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2NGT04oKSB7IC8vRmxhc2ggT25cclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0ZPTiAtIEZsYXNoIE9uJyk7XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oe2ZsYXNoIDogdHJ1ZX0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNjUkRDKCkgeyAvLyBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcgKHN3aXRjaCBtb2RlIHRvIFBhaW50T24pXHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSREMgLSBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcnKTtcclxuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUEFJTlQtT04nKTtcclxuICAgIH1cclxuXHJcbiAgICBjY1RSKCkgeyAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnVFInKTtcclxuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNjUlREKCkgeyAvLyBSZXN1bWUgVGV4dCBEaXNwbGF5IGluIFRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JURCcpO1xyXG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2NFRE0oKSB7IC8vIEVyYXNlIERpc3BsYXllZCBNZW1vcnlcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VETSAtIEVyYXNlIERpc3BsYXllZCBNZW1vcnknKTtcclxuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNjQ1IoKSB7IC8vIENhcnJpYWdlIFJldHVyblxyXG4gICAgICAgIGxvZ2dlci5sb2coJ0NSIC0gQ2FycmlhZ2UgUmV0dXJuJyk7XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcclxuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjY0VOTSgpIHsgLy9FcmFzZSBOb24tRGlzcGxheWVkIE1lbW9yeVxyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRU5NIC0gRXJhc2UgTm9uLWRpc3BsYXllZCBNZW1vcnknKTtcclxuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNjRU9DKCkgeyAvL0VuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRU9DIC0gRW5kIE9mIENhcHRpb24nKTtcclxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcclxuICAgICAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVEVYVCcsICdESVNQOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNjVE8obnJDb2xzKSB7IC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcclxuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLm1vdmVDdXJzb3IobnJDb2xzKTtcclxuICAgIH1cclxuXHJcbiAgICBjY01JRFJPVyhzZWNvbmRCeXRlKSB7IC8vIFBhcnNlIE1JRFJPVyBjb21tYW5kXHJcbiAgICAgICAgdmFyIHN0eWxlcyA9IHtmbGFzaCA6IGZhbHNlfTtcclxuICAgICAgICBzdHlsZXMudW5kZXJsaW5lID0gc2Vjb25kQnl0ZSAlIDIgPT09IDE7XHJcbiAgICAgICAgc3R5bGVzLml0YWxpY3MgPSBzZWNvbmRCeXRlID49IDB4MmU7XHJcbiAgICAgICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xyXG4gICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IE1hdGguZmxvb3Ioc2Vjb25kQnl0ZS8yKSAtIDB4MTA7XHJcbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnXTtcclxuICAgICAgICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01JRFJPVzogJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlcykpO1xyXG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHN0eWxlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgb3V0cHV0RGF0YVVwZGF0ZSgpIHtcclxuICAgICAgICB2YXIgdCA9IGxvZ2dlci50aW1lO1xyXG4gICAgICAgIGlmICh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci51cGRhdGVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci51cGRhdGVEYXRhKHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkgeyAvLyBTdGFydCBvZiBhIG5ldyBjdWVcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZXF1YWxzKHRoaXMubGFzdE91dHB1dFNjcmVlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5sYXN0T3V0cHV0U2NyZWVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGN1ZVNwbGl0QXRUaW1lKHQpIHtcclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgQ2VhNjA4UGFyc2VyIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3V0MSwgb3V0Mikge1xyXG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZCB8fCAxO1xyXG4gICAgICAgIHRoaXMub3V0cHV0cyA9IFtvdXQxLCBvdXQyXTtcclxuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW25ldyBDZWE2MDhDaGFubmVsKDEsIG91dDEpLCBuZXcgQ2VhNjA4Q2hhbm5lbCgyLCBvdXQyKV07XHJcbiAgICAgICAgdGhpcy5jdXJyQ2hOciA9IC0xOyAvLyBXaWxsIGJlIDEgb3IgMlxyXG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsOyAvLyBGaXJzdCBieXRlIG9mIGxhc3QgY29tbWFuZFxyXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBTZWNvbmQgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcclxuICAgICAgICB0aGlzLmJ1ZmZlcmVkRGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRhdGFDb3VudGVycyA9IHsncGFkZGluZycgOiAwLCAnY2hhcicgOiAwLCAnY21kJyA6IDAsICdvdGhlcicgOiAwfTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRIYW5kbGVyKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbaW5kZXhdLmdldEhhbmRsZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRIYW5kbGVyKGluZGV4LCBuZXdIYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpbmRleF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBkYXRhIGZvciB0aW1lIHQgaW4gZm9ybXMgb2YgbGlzdCBvZiBieXRlcyAodW5zaWduZWQgaW50cykuIFRoZSBieXRlcyBhcmUgdHJlYXRlZCBhcyBwYWlycy5cclxuICAgICAqL1xyXG4gICAgYWRkRGF0YSh0LCBieXRlTGlzdCkge1xyXG4gICAgICAgIHZhciBjbWRGb3VuZCwgYSwgYixcclxuICAgICAgICBjaGFyc0ZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSB0O1xyXG4gICAgICAgIGxvZ2dlci5zZXRUaW1lKHQpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBieXRlTGlzdC5sZW5ndGggOyBpKz0yKSB7XHJcbiAgICAgICAgICAgIGEgPSBieXRlTGlzdFtpXSAmIDB4N2Y7XHJcbiAgICAgICAgICAgIGIgPSBieXRlTGlzdFtpKzFdICYgMHg3ZjtcclxuICAgICAgICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMucGFkZGluZyArPSAyO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdEQVRBJywgJ1snICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSsxXV0pICsnXSAtPiAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VDbWQoYSwgYik7XHJcbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyc0ZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VyckNoTnIgJiYgdGhpcy5jdXJyQ2hOciA+PTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW3RoaXMuY3VyckNoTnItMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuaW5zZXJ0Q2hhcnMoY2hhcnNGb3VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY21kRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLmNtZCArPSAyO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJzRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLmNoYXIgKz0gMjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLm90aGVyICs9IDI7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdXQVJOSU5HJywgJ0NvdWxkblxcJ3QgcGFyc2UgY2xlYW5lZCBkYXRhICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpKzFdXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgQ29tbWFuZC5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXHJcbiAgICAgKi9cclxuICAgIHBhcnNlQ21kKGEsIGIpIHtcclxuICAgICAgICB2YXIgY2hOciA9IG51bGw7XHJcblxyXG4gICAgICAgIHZhciBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MUMpICYmICgweDIwIDw9IGIgJiYgYiA8PSAweDJGKTtcclxuICAgICAgICB2YXIgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFGKSAmJiAoMHgyMSA8PSBiICYmIGIgPD0gMHgyMyk7XHJcbiAgICAgICAgaWYgKCEoY29uZDEgfHwgY29uZDIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhID09PSB0aGlzLmxhc3RDbWRBICYmIGIgPT09IHRoaXMubGFzdENtZEIpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnUmVwZWF0ZWQgY29tbWFuZCAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJykgaXMgZHJvcHBlZCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcclxuICAgICAgICAgICAgY2hOciA9IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hOciA9IDI7IC8vIChhID09PSAweDFDIHx8IGE9PT0gMHgxZilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XHJcblxyXG4gICAgICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MUMpIHtcclxuICAgICAgICAgICAgaWYgKGIgPT09IDB4MjApIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDIxKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQlMoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDIyKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQU9GKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjQpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NERVIoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI1KSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUlUoMik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjcpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI4KSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRk9OKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkEpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NUUigpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkIpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVEQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJDKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRURNKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRCkge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0NSKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0VOTSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkYpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7IC8vYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxyXG4gICAgICAgICAgICBjaGFubmVsLmNjVE8oYiAtIDB4MjApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcclxuICAgICAgICB0aGlzLmxhc3RDbWRCID0gYjtcclxuICAgICAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIG1pZHJvdyBzdHlsaW5nIGNvbW1hbmRcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBwYXJzZU1pZHJvdyhhLCBiKSB7XHJcbiAgICAgICAgdmFyIGNoTnIgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoICgoYSA9PT0gMHgxMSkgfHwgKGEgPT09IDB4MTkpKSAmJiAweDIwIDw9IGIgJiYgYiA8PSAweDJmKSB7XHJcbiAgICAgICAgICAgIGlmIChhID09PSAweDExKSB7XHJcbiAgICAgICAgICAgICAgICBjaE5yID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlICB7XHJcbiAgICAgICAgICAgICAgICBjaE5yID0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyQ2hOcikge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTWlzbWF0Y2ggY2hhbm5lbCBpbiBtaWRyb3cgcGFyc2luZycpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yLTFdO1xyXG4gICAgICAgICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdNSURST1cgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIFByZWFibGUgQWNjZXNzIENvZGVzIChUYWJsZSA1MykuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgUEFDIGZvdW5kXHJcbiAgICAgKi9cclxuICAgIHBhcnNlUEFDKGEsIGIpIHtcclxuXHJcbiAgICAgICB2YXIgY2hOciA9IG51bGw7XHJcbiAgICAgICB2YXIgcm93ID0gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIGNhc2UxID0gKCgweDExIDw9IGEgICYmIGEgPD0gMHgxNykgfHwgKDB4MTkgPD0gYSAmJiBhIDw9IDB4MUYpKSAmJiAoMHg0MCA8PSBiICYmIGIgPD0gMHg3Rik7XHJcbiAgICAgICAgdmFyIGNhc2UyID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKDB4NDAgPD0gYiAmJiBiIDw9IDB4NUYpO1xyXG4gICAgICAgIGlmICghIChjYXNlMSB8fCBjYXNlMikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoTnIgPSAoYSA8PSAweDE3KSA/IDEgOiAyO1xyXG5cclxuICAgICAgICBpZiAoMHg0MCA8PSBiICYmIGIgPD0gMHg1Rikge1xyXG4gICAgICAgICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcclxuICAgICAgICB9IGVsc2UgeyAvLyAweDYwIDw9IGIgPD0gMHg3RlxyXG4gICAgICAgICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzSGlnaENoMVthXSA6IHJvd3NIaWdoQ2gyW2FdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFjRGF0YSA9IHRoaXMuaW50ZXJwcmV0UEFDKHJvdywgYik7XHJcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnItMV07XHJcbiAgICAgICAgY2hhbm5lbC5zZXRQQUMocGFjRGF0YSk7XHJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IGE7XHJcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IGI7XHJcbiAgICAgICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcnByZXQgdGhlIHNlY29uZCBieXRlIG9mIHRoZSBwYWMsIGFuZCByZXR1cm4gdGhlIGluZm9ybWF0aW9uLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXHJcbiAgICAgKi9cclxuICAgIGludGVycHJldFBBQyhyb3csIGJ5dGUpIHtcclxuICAgICAgICB2YXIgcGFjSW5kZXggPSBieXRlO1xyXG4gICAgICAgIHZhciBwYWNEYXRhID0ge2NvbG9yIDogbnVsbCwgaXRhbGljcyA6IGZhbHNlLCBpbmRlbnQgOiBudWxsLCB1bmRlcmxpbmUgOiBmYWxzZSwgcm93IDogcm93fTtcclxuXHJcbiAgICAgICAgaWYgKGJ5dGUgPiAweDVGKSB7XHJcbiAgICAgICAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NjA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg0MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFjRGF0YS51bmRlcmxpbmUgPSAocGFjSW5kZXggJiAxKSA9PT0gMTtcclxuICAgICAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XHJcbiAgICAgICAgICAgIHBhY0RhdGEuY29sb3IgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnd2hpdGUnXVtNYXRoLmZsb29yKHBhY0luZGV4LzIpXTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBhY0luZGV4IDw9IDB4Zikge1xyXG4gICAgICAgICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xyXG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYWNEYXRhLmluZGVudCA9IChNYXRoLmZsb29yKChwYWNJbmRleC0weDEwKS8yKSkqNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhY0RhdGE7IC8vIE5vdGUgdGhhdCByb3cgaGFzIHplcm8gb2Zmc2V0LiBUaGUgc3BlYyB1c2VzIDEuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCAxIHRvIDIgY29kZXMgY29ycmVzcG9uZGluZyB0byBjaGFycywgaWYgZm91bmQuIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBwYXJzZUNoYXJzKGEsIGIpIHtcclxuXHJcbiAgICAgICB2YXIgIGNoYW5uZWxOciA9IG51bGwsXHJcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IG51bGwsXHJcbiAgICAgICAgICAgIGNoYXJDb2RlMSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChhID49IDB4MTkpIHtcclxuICAgICAgICAgICAgY2hhbm5lbE5yID0gMjtcclxuICAgICAgICAgICAgY2hhckNvZGUxID0gYSAtIDg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hhbm5lbE5yID0gMTtcclxuICAgICAgICAgICAgY2hhckNvZGUxID0gYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKDB4MTEgPD0gY2hhckNvZGUxICYmIGNoYXJDb2RlMSA8PSAweDEzKSB7XHJcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIHZhciBvbmVDb2RlID0gYjtcclxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMSkge1xyXG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xyXG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnU3BlY2lhbCBjaGFyIFxcJycgKyBnZXRDaGFyRm9yQnl0ZShvbmVDb2RlKSArICdcXCcgaW4gY2hhbm5lbCAnICsgY2hhbm5lbE5yKTtcclxuICAgICAgICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoMHgyMCA8PSBhICYmIGEgPD0gMHg3Zikge1xyXG4gICAgICAgICAgICBjaGFyQ29kZXMgPSAoYiA9PT0gMCkgPyBbYV0gOiBbYSwgYl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFyQ29kZXMpIHtcclxuICAgICAgICAgICAgdmFyIGhleENvZGVzID0gbnVtQXJyYXlUb0hleEFycmF5KGNoYXJDb2Rlcyk7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogUGFyc2UgZXh0ZW5kZWQgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgbmV3IGZvcmVncm91bmQgY29sb3IgYmxhY2suXHJcbiAgICAqIEByZXR1cm5ze0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcclxuICAgICovXHJcbiAgICBwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpIHtcclxuICAgICAgIHZhciAgYmtnRGF0YSxcclxuICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgIGNoTnIsXHJcbiAgICAgICAgICAgIGNoYW5uZWw7XHJcblxyXG4gICAgICAgIHZhciBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmICgweDIwIDw9IGIgJiYgYiA8PSAweDJmKTtcclxuICAgICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiAoMHgyZCA8PWIgJiYgYiA8PSAweDJmKTtcclxuICAgICAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBia2dEYXRhID0ge307XHJcbiAgICAgICAgaWYgKGEgID09PSAweDEwIHx8IGEgPT09IDB4MTgpIHtcclxuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiLTB4MjApLzIpO1xyXG4gICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3JzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKGIgJSAyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJkKSB7XHJcbiAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmtnRGF0YS5mb3JlZ3JvdW5kID0gJ2JsYWNrJztcclxuICAgICAgICAgICAgaWYgKGIgPT09IDB4MmYpIHtcclxuICAgICAgICAgICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjaE5yID0gKGEgPCAweDE4KSA/IDEgOiAyO1xyXG4gICAgICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnItMV07XHJcbiAgICAgICAgY2hhbm5lbC5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xyXG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIGZvciAodmFyIGk9MCA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aCA7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlciB0aGUgZ2VuZXJhdGlvbiBvZiBhIGN1ZSwgYW5kIHRoZSBzdGFydCBvZiBhIG5ldyBvbmUgaWYgZGlzcGxheVNjcmVlbnMgYXJlIG5vdCBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgY3VlU3BsaXRBdFRpbWUodCkge1xyXG4gICAgICAgIGZvciAodmFyIGk9MCA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aCA7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5jdWVTcGxpdEF0VGltZSh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2VhNjA4UGFyc2VyO1xyXG4iLCJpbXBvcnQgeyBmaXhMaW5lQnJlYWtzIH0gZnJvbSAnLi92dHRwYXJzZXInO1xyXG5cclxuY29uc3QgQ3VlcyA9IHtcclxuXHJcbiAgbmV3Q3VlOiBmdW5jdGlvbih0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XHJcbiAgICB2YXIgcm93O1xyXG4gICAgdmFyIGN1ZTtcclxuICAgIHZhciBpbmRlbnRpbmc7XHJcbiAgICB2YXIgaW5kZW50O1xyXG4gICAgdmFyIHRleHQ7XHJcbiAgICB2YXIgVlRUQ3VlID0gd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xyXG5cclxuICAgIGZvciAodmFyIHI9MDsgcjxjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspXHJcbiAgICB7XHJcbiAgICAgIHJvdyA9IGNhcHRpb25TY3JlZW4ucm93c1tyXTtcclxuICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcclxuICAgICAgaW5kZW50ID0gMDtcclxuICAgICAgdGV4dCA9ICcnO1xyXG5cclxuICAgICAgaWYgKCFyb3cuaXNFbXB0eSgpKVxyXG4gICAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgYz0wOyBjPHJvdy5jaGFycy5sZW5ndGg7IGMrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZiAocm93LmNoYXJzW2NdLnVjaGFyLm1hdGNoKC9cXHMvKSAmJiBpbmRlbnRpbmcpXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGluZGVudCsrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0ZXh0ICs9IHJvdy5jaGFyc1tjXS51Y2hhcjtcclxuICAgICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vVG8gYmUgdXNlZCBmb3IgY2xlYW5pbmctdXAgb3JwaGFuZWQgcm9sbC11cCBjYXB0aW9uc1xyXG4gICAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7XHJcblxyXG4gICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXHJcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICBlbmRUaW1lICs9IDAuMDAwMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN1ZSA9IG5ldyBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBmaXhMaW5lQnJlYWtzKHRleHQudHJpbSgpKSk7XHJcblxyXG4gICAgICAgIGlmIChpbmRlbnQgPj0gMTYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaW5kZW50LS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpbmRlbnQrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFZUVEN1ZS5saW5lIGdldCdzIGZsYWtleSB3aGVuIHVzaW5nIGNvbnRyb2xzLCBzbyBsZXQncyBub3cgaW5jbHVkZSBsaW5lIDEzJjE0XHJcbiAgICAgICAgLy8gYWxzbywgZHJvcCBsaW5lIDEgc2luY2UgaXQncyB0byBjbG9zZSB0byB0aGUgdG9wXHJcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICBjdWUubGluZSA9IHIgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgY3VlLmxpbmUgPSAociA+IDcgPyByIC0gMiA6IHIgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xyXG4gICAgICAgIC8vIENsYW1wIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIDAgYW5kIDEwMCAtIGlmIG91dCBvZiB0aGVzZSBib3VuZHMsIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiBhbmQgY2FwdGlvbnMgYnJlYWtcclxuICAgICAgICBjdWUucG9zaXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIDEwMCAqIChpbmRlbnQgLyAzMikgKyAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pID8gNTAgOiAwKSkpO1xyXG4gICAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3VlcztcclxuIiwiLypcclxuICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXHJcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cclxuICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcclxuICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXHJcbiAqL1xyXG5cclxuaW1wb3J0IEVXTUEgZnJvbSAnLi4vdXRpbHMvZXdtYSc7XHJcblxyXG5cclxuY2xhc3MgRXdtYUJhbmRXaWR0aEVzdGltYXRvciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscyxzbG93LGZhc3QsZGVmYXVsdEVzdGltYXRlKSB7XHJcbiAgICB0aGlzLmhscyA9IGhscztcclxuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IGRlZmF1bHRFc3RpbWF0ZTtcclxuICAgIHRoaXMubWluV2VpZ2h0XyA9IDAuMDAxO1xyXG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xyXG4gICAgdGhpcy5zbG93XyA9IG5ldyBFV01BKHNsb3cpO1xyXG4gICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QpO1xyXG4gIH1cclxuXHJcbiAgc2FtcGxlKGR1cmF0aW9uTXMsbnVtQnl0ZXMpIHtcclxuICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcclxuICAgIHZhciBiYW5kd2lkdGggPSA4MDAwKiBudW1CeXRlcyAvIGR1cmF0aW9uTXMsXHJcbiAgICAvL2NvbnNvbGUubG9nKCdpbnN0YW50IGJ3OicrIE1hdGgucm91bmQoYmFuZHdpZHRoKSk7XHJcbiAgICAvLyB3ZSB3ZWlnaHQgc2FtcGxlIHVzaW5nIGxvYWRpbmcgZHVyYXRpb24uLi4uXHJcbiAgICAgICAgd2VpZ2h0ID0gZHVyYXRpb25NcyAvIDEwMDA7XHJcbiAgICB0aGlzLmZhc3RfLnNhbXBsZSh3ZWlnaHQsYmFuZHdpZHRoKTtcclxuICAgIHRoaXMuc2xvd18uc2FtcGxlKHdlaWdodCxiYW5kd2lkdGgpO1xyXG4gIH1cclxuXHJcbiAgY2FuRXN0aW1hdGUoKSB7XHJcbiAgICBsZXQgZmFzdCA9IHRoaXMuZmFzdF87XHJcbiAgICByZXR1cm4gKGZhc3QgJiYgZmFzdC5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0Xyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgZ2V0RXN0aW1hdGUoKSB7XHJcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XHJcbiAgICAgIC8vY29uc29sZS5sb2coJ3Nsb3cgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpKTtcclxuICAgICAgLy9jb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xyXG4gICAgICAvLyBUYWtlIHRoZSBtaW5pbXVtIG9mIHRoZXNlIHR3byBlc3RpbWF0ZXMuICBUaGlzIHNob3VsZCBoYXZlIHRoZSBlZmZlY3Qgb2ZcclxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXHJcbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksdGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xyXG5cclxuIiwiLypcclxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxyXG4gKiAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vdmluZ19hdmVyYWdlI0V4cG9uZW50aWFsX21vdmluZ19hdmVyYWdlXHJcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcclxuICovXHJcblxyXG5jbGFzcyBFV01BIHtcclxuXHJcbiAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxyXG4gIGNvbnN0cnVjdG9yKGhhbGZMaWZlKSB7XHJcbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXHJcbiAgICB0aGlzLmFscGhhXyA9IGhhbGZMaWZlID8gTWF0aC5leHAoTWF0aC5sb2coMC41KSAvIGhhbGZMaWZlKSA6IDA7XHJcbiAgICB0aGlzLmVzdGltYXRlXyA9IDA7XHJcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IDA7XHJcbiAgfVxyXG5cclxuICBzYW1wbGUod2VpZ2h0LHZhbHVlKSB7XHJcbiAgICB2YXIgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcclxuICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XHJcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBnZXRUb3RhbFdlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLnRvdGFsV2VpZ2h0XztcclxuICB9XHJcblxyXG4gIGdldEVzdGltYXRlKCkge1xyXG4gICAgaWYgKHRoaXMuYWxwaGFfKSB7XHJcbiAgICAgIHZhciB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFV01BO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBub29wKCkge31cclxuXHJcbmNvbnN0IGZha2VMb2dnZXIgPSB7XHJcbiAgdHJhY2U6IG5vb3AsXHJcbiAgZGVidWc6IG5vb3AsXHJcbiAgbG9nOiBub29wLFxyXG4gIHdhcm46IG5vb3AsXHJcbiAgaW5mbzogbm9vcCxcclxuICBlcnJvcjogbm9vcFxyXG59O1xyXG5cclxubGV0IGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcclxuXHJcbi8qZ2xvYmFscyBzZWxmOiBmYWxzZSAqL1xyXG5cclxuLy9sZXQgbGFzdENhbGxUaW1lO1xyXG4vLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XHJcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XHJcbi8vICAgbGFzdENhbGxUaW1lID0gbm93O1xyXG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xyXG4vLyAgIHJldHVybiBtc2c7XHJcbi8vIH1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdE1zZyh0eXBlLCBtc2cpIHtcclxuICBtc2cgPSAnWycgKyAgdHlwZSArICddID4gJyArIG1zZztcclxuICByZXR1cm4gbXNnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlKSB7XHJcbiAgY29uc3QgZnVuYyA9IHNlbGYuY29uc29sZVt0eXBlXTtcclxuICBpZiAoZnVuYykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuICAgICAgaWYoYXJnc1swXSkge1xyXG4gICAgICAgIGFyZ3NbMF0gPSBmb3JtYXRNc2codHlwZSwgYXJnc1swXSk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuYy5hcHBseShzZWxmLmNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIG5vb3A7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZywgLi4uZnVuY3Rpb25zKSB7XHJcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xyXG4gICAgZXhwb3J0ZWRMb2dnZXJbdHlwZV0gPSBkZWJ1Z0NvbmZpZ1t0eXBlXSA/IGRlYnVnQ29uZmlnW3R5cGVdLmJpbmQoZGVidWdDb25maWcpIDogY29uc29sZVByaW50Rm4odHlwZSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgZW5hYmxlTG9ncyA9IGZ1bmN0aW9uKGRlYnVnQ29uZmlnKSB7XHJcbiAgaWYgKGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcclxuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZyxcclxuICAgICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcclxuICAgICAgLy8ndHJhY2UnLFxyXG4gICAgICAnZGVidWcnLFxyXG4gICAgICAnbG9nJyxcclxuICAgICAgJ2luZm8nLFxyXG4gICAgICAnd2FybicsXHJcbiAgICAgICdlcnJvcidcclxuICAgICk7XHJcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxyXG4gICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBuZWVkZWRcclxuICAgIHRyeSB7XHJcbiAgICAgZXhwb3J0ZWRMb2dnZXIubG9nKCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcclxuICAgIH1cclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IHZhciBsb2dnZXIgPSBleHBvcnRlZExvZ2dlcjtcclxuIiwiLyoqXHJcbiAqICBUaW1lUmFuZ2VzIHRvIHN0cmluZyBoZWxwZXJcclxuICovXHJcblxyXG5jb25zdCBUaW1lUmFuZ2VzID0ge1xyXG4gIHRvU3RyaW5nIDogZnVuY3Rpb24ocikge1xyXG4gICAgdmFyIGxvZyA9ICcnLCBsZW4gPSByLmxlbmd0aDtcclxuICAgIGZvciAodmFyIGk9MDsgaTxsZW47IGkrKykge1xyXG4gICAgICBsb2cgKz0gJ1snICsgci5zdGFydChpKS50b0ZpeGVkKDMpICsgJywnICsgci5lbmQoaSkudG9GaXhlZCgzKSArICddJztcclxuICAgIH1cclxuICAgIHJldHVybiBsb2c7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaW1lUmFuZ2VzO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uKCkge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVlRUQ3VlKSB7XHJcbiAgICByZXR1cm4gd2luZG93LlZUVEN1ZTtcclxuICB9XHJcblxyXG4gIHZhciBhdXRvS2V5d29yZCA9ICdhdXRvJztcclxuICB2YXIgZGlyZWN0aW9uU2V0dGluZyA9IHtcclxuICAgICcnOiB0cnVlLFxyXG4gICAgbHI6IHRydWUsXHJcbiAgICBybDogdHJ1ZVxyXG4gIH07XHJcbiAgdmFyIGFsaWduU2V0dGluZyA9IHtcclxuICAgIHN0YXJ0OiB0cnVlLFxyXG4gICAgbWlkZGxlOiB0cnVlLFxyXG4gICAgZW5kOiB0cnVlLFxyXG4gICAgbGVmdDogdHJ1ZSxcclxuICAgIHJpZ2h0OiB0cnVlXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBkaXIgPSBkaXJlY3Rpb25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgcmV0dXJuIGRpciA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBhbGlnbiA9IGFsaWduU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcclxuICAgIHZhciBpID0gMTtcclxuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBjb2JqID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICBmb3IgKHZhciBwIGluIGNvYmopIHtcclxuICAgICAgICBvYmpbcF0gPSBjb2JqW3BdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcclxuICAgIHZhciBjdWUgPSB0aGlzO1xyXG4gICAgdmFyIGlzSUU4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICB9KSgpO1xyXG4gICAgdmFyIGJhc2VPYmogPSB7fTtcclxuXHJcbiAgICBpZiAoaXNJRTgpIHtcclxuICAgICAgY3VlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cclxuICAgICAqIHRoZSBzcGVjLlxyXG4gICAgICovXHJcblxyXG4gICAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcclxuICAgIC8vIHRvIHJlY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZS4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGVcclxuICAgIC8vIGxhemlseS5cclxuICAgIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZUVEN1ZSBhbmQgVGV4dFRyYWNrQ3VlIHByb3BlcnRpZXNcclxuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxyXG4gICAgICovXHJcblxyXG4gICAgdmFyIF9pZCA9ICcnO1xyXG4gICAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xyXG4gICAgdmFyIF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XHJcbiAgICB2YXIgX2VuZFRpbWUgPSBlbmRUaW1lO1xyXG4gICAgdmFyIF90ZXh0ID0gdGV4dDtcclxuICAgIHZhciBfcmVnaW9uID0gbnVsbDtcclxuICAgIHZhciBfdmVydGljYWwgPSAnJztcclxuICAgIHZhciBfc25hcFRvTGluZXMgPSB0cnVlO1xyXG4gICAgdmFyIF9saW5lID0gJ2F1dG8nO1xyXG4gICAgdmFyIF9saW5lQWxpZ24gPSAnc3RhcnQnO1xyXG4gICAgdmFyIF9wb3NpdGlvbiA9IDUwO1xyXG4gICAgdmFyIF9wb3NpdGlvbkFsaWduID0gJ21pZGRsZSc7XHJcbiAgICB2YXIgX3NpemUgPSA1MDtcclxuICAgIHZhciBfYWxpZ24gPSAnbWlkZGxlJztcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnaWQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9pZDtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBfaWQgPSAnJyArIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3BhdXNlT25FeGl0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2VuZFRpbWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZW5kVGltZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd0ZXh0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfdGV4dDtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBfdGV4dCA9ICcnICsgdmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3JlZ2lvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3ZlcnRpY2FsJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfdmVydGljYWw7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XHJcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYmVjYXVzZSB0aGUgc2V0dGluZyBhbiBiZSBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ZlcnRpY2FsID0gc2V0dGluZztcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc25hcFRvTGluZXMnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfbGluZTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gYXV0b0tleXdvcmQpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBudW1iZXIgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2xpbmUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZUFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfcG9zaXRpb247XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb25BbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uQWxpZ247XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcclxuICAgICAgICBpZiAoIXNldHRpbmcpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NpemUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zaXplO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2FsaWduO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2FsaWduID0gc2V0dGluZztcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcclxuICAgICAqL1xyXG5cclxuICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxyXG4gICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAoaXNJRTgpIHtcclxuICAgICAgcmV0dXJuIGN1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZUVEN1ZSBtZXRob2RzXHJcbiAgICovXHJcblxyXG4gIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXHJcbiAgICB2YXIgV2ViVlRUID0gd2luZG93LldlYlZUVDtcclxuICAgIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFZUVEN1ZTtcclxufSkoKTtcclxuIiwiLypcclxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvZGlzdC92dHQuanMjTDE3MTZcclxuICovXHJcblxyXG5pbXBvcnQgVlRUQ3VlIGZyb20gJy4vdnR0Y3VlJztcclxuXHJcbmNvbnN0IFN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbiBTdHJpbmdEZWNvZGVyKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBkZWNvZGU6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIC0gZXhwZWN0ZWQgc3RyaW5nIGRhdGEuJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG5mdW5jdGlvbiBWVFRQYXJzZXIoKSB7XHJcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcclxuICAgIHRoaXMuc3RhdGUgPSAnSU5JVElBTCc7XHJcbiAgICB0aGlzLmJ1ZmZlciA9ICcnO1xyXG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoKTtcclxuICAgIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xyXG59XHJcblxyXG5cclxuLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cclxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcclxuXHJcbiAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMoaCwgbSwgcywgZikge1xyXG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xyXG4gIH1cclxuXHJcbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xyXG4gIGlmICghbSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAobVszXSkge1xyXG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxyXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10ucmVwbGFjZSgnOicsICcnKSwgbVs0XSk7XHJcbiAgfSBlbHNlIGlmIChtWzFdID4gNTkpIHtcclxuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxyXG4gICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxyXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIDAsIG1bNF0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxyXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKDAsIG1bMV0sIG1bMl0sIG1bNF0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XHJcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXHJcbmZ1bmN0aW9uIFNldHRpbmdzKCkge1xyXG4gIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxufVxyXG5cclxuU2V0dGluZ3MucHJvdG90eXBlID0ge1xyXG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXHJcbiAgc2V0OiBmdW5jdGlvbihrLCB2KSB7XHJcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XHJcbiAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcclxuICAgIH1cclxuICB9LFxyXG4gIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXHJcbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXHJcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcclxuICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXHJcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXHJcbiAgZ2V0OiBmdW5jdGlvbihrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XHJcbiAgICBpZiAoZGVmYXVsdEtleSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHQ7XHJcbiAgfSxcclxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXHJcbiAgaGFzOiBmdW5jdGlvbihrKSB7XHJcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcclxuICB9LFxyXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIG9uZSBvZiB0aGUgZ2l2ZW4gYWx0ZXJuYXRpdmVzLlxyXG4gIGFsdDogZnVuY3Rpb24oaywgdiwgYSkge1xyXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XHJcbiAgICAgIGlmICh2ID09PSBhW25dKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgKHNpZ25lZCkgaW50ZWdlci5cclxuICBpbnRlZ2VyOiBmdW5jdGlvbihrLCB2KSB7XHJcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7IC8vIGludGVnZXJcclxuICAgICAgdGhpcy5zZXQoaywgcGFyc2VJbnQodiwgMTApKTtcclxuICAgIH1cclxuICB9LFxyXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgcGVyY2VudGFnZS5cclxuICBwZXJjZW50OiBmdW5jdGlvbihrLCB2KSB7XHJcbiAgICB2YXIgbTtcclxuICAgIGlmICgobSA9IHYubWF0Y2goL14oW1xcZF17MSwzfSkoXFwuW1xcZF0qKT8lJC8pKSkge1xyXG4gICAgICB2ID0gcGFyc2VGbG9hdCh2KTtcclxuICAgICAgaWYgKHYgPj0gMCAmJiB2IDw9IDEwMCkge1xyXG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxyXG4vLyBpbnRlcnByZXRlIGVhY2ggZ3JvdXAgYXMgYSBrZXkvdmFsdWUgcGFpciBzZXBhcmF0ZWQgYnkgJ2tleVZhbHVlRGVsaW0nLlxyXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XHJcbiAgdmFyIGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XHJcbiAgZm9yICh2YXIgaSBpbiBncm91cHMpIHtcclxuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSAnc3RyaW5nJykge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHZhciBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcclxuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICB2YXIgayA9IGt2WzBdO1xyXG4gICAgdmFyIHYgPSBrdlsxXTtcclxuICAgIGNhbGxiYWNrKGssIHYpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGRlZmF1bHRzID0gbmV3IFZUVEN1ZSgwLCAwLCAwKTtcclxuLy8gJ21pZGRsZScgd2FzIGNoYW5nZWQgdG8gJ2NlbnRlcicgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnR0L3B1bGwvMjQ0XHJcbi8vIENocm9tZSBhbmQgU2FmYXJpIGRvbid0IHlldCBzdXBwb3J0IHRoaXMgY2hhbmdlLCBidXQgRkYgZG9lc1xyXG52YXIgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcclxuXHJcbmZ1bmN0aW9uIHBhcnNlQ3VlKGlucHV0LCBjdWUsIHJlZ2lvbkxpc3QpIHtcclxuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cclxuICB2YXIgb0lucHV0ID0gaW5wdXQ7XHJcbiAgLy8gNC4xIFdlYlZUVCB0aW1lc3RhbXBcclxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xyXG4gICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xyXG4gICAgaWYgKHRzID09PSBudWxsKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxyXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XHJcbiAgICByZXR1cm4gdHM7XHJcbiAgfVxyXG5cclxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXHJcbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcclxuICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xyXG5cclxuICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24oaywgdikge1xyXG4gICAgICBzd2l0Y2ggKGspIHtcclxuICAgICAgICBjYXNlICdyZWdpb24nOlxyXG4gICAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcclxuICAgICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XHJcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydybCcsICdsciddKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2xpbmUnOlxyXG4gICAgICAgICAgdmFyIHZhbHMgPSB2LnNwbGl0KCcsJyksXHJcbiAgICAgICAgICAgIHZhbHMwID0gdmFsc1swXTtcclxuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsczApO1xyXG4gICAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsczApKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsczAsIFsnYXV0byddKTtcclxuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ2xpbmVBbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdwb3NpdGlvbic6XHJcbiAgICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcclxuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ3Bvc2l0aW9uQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xpbmUtbGVmdCcsICdsaW5lLXJpZ2h0JywgJ2F1dG8nXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdzaXplJzpcclxuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdhbGlnbic6XHJcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J10pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0sIC86LywgL1xccy8pO1xyXG5cclxuICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXHJcbiAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KCdyZWdpb24nLCBudWxsKTtcclxuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XHJcbiAgICB2YXIgbGluZSA9IHNldHRpbmdzLmdldCgnbGluZScsICdhdXRvJyk7XHJcbiAgICBpZiAobGluZSA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLmxpbmUgPT09IC0xKSB7XHJcbiAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcclxuICAgICAgbGluZSA9IC0xO1xyXG4gICAgfVxyXG4gICAgY3VlLmxpbmUgPSBsaW5lO1xyXG4gICAgY3VlLmxpbmVBbGlnbiA9IHNldHRpbmdzLmdldCgnbGluZUFsaWduJywgJ3N0YXJ0Jyk7XHJcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XHJcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XHJcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2FsaWduJywgY2VudGVyKTtcclxuICAgIHZhciBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xyXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XHJcbiAgICAgIC8vIHNldCBudW1lcmljIHBvc2l0aW9uIGZvciBTYWZhcmlcclxuICAgICAgcG9zaXRpb24gPSBjdWUuYWxpZ24gPT09ICdzdGFydCcgfHwgY3VlLmFsaWduID09PSAnbGVmdCcgPyAwIDogY3VlLmFsaWduID09PSAnZW5kJyB8fCBjdWUuYWxpZ24gPT09ICdyaWdodCcgPyAxMDAgOiA1MDtcclxuICAgIH1cclxuICAgIGN1ZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XHJcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xyXG4gIH1cclxuXHJcbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cclxuICBza2lwV2hpdGVzcGFjZSgpO1xyXG4gIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7ICAgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcclxuICBza2lwV2hpdGVzcGFjZSgpO1xyXG4gIGlmIChpbnB1dC5zdWJzdHIoMCwgMykgIT09ICctLT4nKSB7ICAgICAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggJy0tPidcclxuICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5IFxcJy0tPlxcJyk6ICcgK1xyXG4gICAgICBvSW5wdXQpO1xyXG4gIH1cclxuICBpbnB1dCA9IGlucHV0LnN1YnN0cigzKTtcclxuICBza2lwV2hpdGVzcGFjZSgpO1xyXG4gIGN1ZS5lbmRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAgICAgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXHJcblxyXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXHJcbiAgc2tpcFdoaXRlc3BhY2UoKTtcclxuICBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpeExpbmVCcmVha3MoaW5wdXQpIHtcclxuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xyXG59XHJcblxyXG5WVFRQYXJzZXIucHJvdG90eXBlID0ge1xyXG4gIHBhcnNlOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSB0aGVuIHdlIHdvbid0IGRlY29kZSBpdCwgYnV0IHdpbGwganVzdCB0cnkgdG8gcGFyc2VcclxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cclxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZShkYXRhLCB7c3RyZWFtOiB0cnVlfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xyXG4gICAgICB2YXIgYnVmZmVyID0gc2VsZi5idWZmZXI7XHJcbiAgICAgIHZhciBwb3MgPSAwO1xyXG5cclxuICAgICAgYnVmZmVyID0gZml4TGluZUJyZWFrcyhidWZmZXIpO1xyXG5cclxuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xyXG4gICAgICAgICsrcG9zO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xyXG4gICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxyXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XHJcbiAgICAgICAgKytwb3M7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xyXG4gICAgICAgICsrcG9zO1xyXG4gICAgICB9XHJcbiAgICAgIHNlbGYuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xyXG4gICAgICByZXR1cm4gbGluZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcclxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XHJcbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24oaywgdikge1xyXG4gICAgICAgIHN3aXRjaCAoaykge1xyXG4gICAgICAgICAgY2FzZSAnUmVnaW9uJzpcclxuICAgICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XHJcbiAgICAgICAgICAgIC8vcGFyc2VSZWdpb24odik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgLzovKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA1LjEgV2ViVlRUIGZpbGUgcGFyc2luZy5cclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciBsaW5lO1xyXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnKSB7XHJcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxyXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcclxuXHJcbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eV0VCVlRUKFsgXFx0XS4qKT8kLyk7XHJcbiAgICAgICAgaWYgKCFtIHx8ICFtWzBdKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi5zdGF0ZSA9ICdIRUFERVInO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcclxuICAgICAgd2hpbGUgKHNlbGYuYnVmZmVyKSB7XHJcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cclxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XHJcbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcclxuICAgICAgICAgIGNhc2UgJ0hFQURFUic6XHJcbiAgICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXHJcbiAgICAgICAgICAgIGlmICgvOi8udGVzdChsaW5lKSkge1xyXG4gICAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XHJcbiAgICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXHJcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICBjYXNlICdOT1RFJzpcclxuICAgICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxyXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcclxuICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIGNhc2UgJ0lEJzpcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cclxuICAgICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcclxuICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ05PVEUnO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXHJcbiAgICAgICAgICAgIGlmICghbGluZSkge1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuY3VlID0gbmV3IFZUVEN1ZSgwLCAwLCAnJyk7XHJcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFJztcclxuICAgICAgICAgICAgLy8gMzAtMzkgLSBDaGVjayBpZiBzZWxmIGxpbmUgY29udGFpbnMgYW4gb3B0aW9uYWwgaWRlbnRpZmllciBvciB0aW1pbmcgZGF0YS5cclxuICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignLS0+JykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXHJcbiAgICAgICAgICAvKmZhbGxzIHRocm91Z2gqL1xyXG4gICAgICAgICAgY2FzZSAnQ1VFJzpcclxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBwYXJzZUN1ZShsaW5lLCBzZWxmLmN1ZSwgc2VsZi5yZWdpb25MaXN0KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IgaWdub3JlIHJlc3Qgb2YgdGhlIGN1ZS5cclxuICAgICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdCQURDVUUnO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFVEVYVCc7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XHJcbiAgICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTtcclxuICAgICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cclxuICAgICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxyXG4gICAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XHJcbiAgICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXHJcbiAgICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxyXG4gICAgICAgICAgICAgIGlmIChzZWxmLm9uY3VlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZWxmLmN1ZS50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSAnXFxuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IGxpbmU7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgY2FzZSAnQkFEQ1VFJzogLy8gQkFEQ1VFXHJcbiAgICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cclxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcblxyXG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXHJcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnQ1VFVEVYVCcgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xyXG4gICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHNlbGYuY3VlID0gbnVsbDtcclxuICAgICAgLy8gRW50ZXIgQkFEV0VCVlRUIHN0YXRlIGlmIGhlYWRlciB3YXMgbm90IHBhcnNlZCBjb3JyZWN0bHkgb3RoZXJ3aXNlXHJcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cclxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG4gIGZsdXNoOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEZpbmlzaCBkZWNvZGluZyB0aGUgc3RyZWFtLlxyXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKCk7XHJcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxyXG4gICAgICBpZiAoc2VsZi5jdWUgfHwgc2VsZi5zdGF0ZSA9PT0gJ0hFQURFUicpIHtcclxuICAgICAgICBzZWxmLmJ1ZmZlciArPSAnXFxuXFxuJztcclxuICAgICAgICBzZWxmLnBhcnNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxyXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XHJcbiAgICAgIC8vIGxpbmUuXHJcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnSU5JVElBTCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VsZi5vbmZsdXNoKSB7XHJcbiAgICAgIHNlbGYub25mbHVzaCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IHsgZml4TGluZUJyZWFrcyB9O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVlRUUGFyc2VyO1xyXG4iLCJpbXBvcnQgVlRUUGFyc2VyIGZyb20gJy4vdnR0cGFyc2VyJztcclxuXHJcbi8vIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCBpcyBub3Qgc3VwcG9ydGVkIGluIElFMTFcclxuY29uc3Qgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKGlucHV0U3RyaW5nLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XHJcbiAgcmV0dXJuIGlucHV0U3RyaW5nLnN1YnN0cihwb3NpdGlvbiB8fCAwLCBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xyXG59O1xyXG5cclxuY29uc3QgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uKHRpbWVTdHJpbmcpIHtcclxuICAgIGxldCB0cyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC0zKSk7XHJcbiAgICBsZXQgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC02LDIpKTtcclxuICAgIGxldCBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTksMikpO1xyXG4gICAgbGV0IGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XHJcblxyXG4gICAgaWYgKGlzTmFOKHRzKSB8fCBpc05hTihzZWNzKSB8fCBpc05hTihtaW5zKSB8fCBpc05hTihob3VycykpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgdHMgKz0gMTAwMCAqIHNlY3M7XHJcbiAgICB0cyArPSA2MCoxMDAwICogbWlucztcclxuICAgIHRzICs9IDYwKjYwKjEwMDAgKiBob3VycztcclxuXHJcbiAgICByZXR1cm4gdHM7XHJcbn07XHJcblxyXG4vLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoXHJcbmNvbnN0IGhhc2ggPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICBsZXQgaGFzaCA9IDUzODE7XHJcbiAgICBsZXQgaSA9IHRleHQubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkpIHtcclxuICAgICAgICBoYXNoID0gKGhhc2ggKiAzMykgXiB0ZXh0LmNoYXJDb2RlQXQoLS1pKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoaGFzaCA+Pj4gMCkudG9TdHJpbmcoKTtcclxufTtcclxuXHJcbmNvbnN0IGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uKHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcclxuICAgIGxldCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xyXG4gICAgbGV0IHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcclxuXHJcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkaXNjb250aW51aXR5IG9yIGN1ZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzaW5jZSB0aGUgbGFzdCBkaXNjb250aW51aXR5XHJcbiAgICAvLyBPZmZzZXQgPSBjdXJyZW50IGRpc2NvbnRpbnVpdHkgdGltZVxyXG4gICAgaWYgKCFwcmV2Q0MgfHwgKCFwcmV2Q0MubmV3ICYmIGN1cnJDQy5uZXcpKSB7XHJcbiAgICAgICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcclxuICAgICAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxyXG4gICAgLy8gT2Zmc2V0ID0gdGltZSBlbGFwc2VkXHJcbiAgICB3aGlsZSAocHJldkNDICYmIHByZXZDQy5uZXcpIHtcclxuICAgICAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xyXG4gICAgICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcclxuICAgICAgICBjdXJyQ0MgPSBwcmV2Q0M7XHJcbiAgICAgICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xyXG4gICAgfVxyXG5cclxuICAgIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lO1xyXG59O1xyXG5cclxuY29uc3QgV2ViVlRUUGFyc2VyID0ge1xyXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHZ0dEJ5dGVBcnJheSwgc3luY1BUUywgdnR0Q0NzLCBjYywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcclxuICAgICAgICAvLyBDb252ZXJ0IGJ5dGVBcnJheSBpbnRvIHN0cmluZywgcmVwbGFjaW5nIGFueSBzb21ld2hhdCBleG90aWMgbGluZWZlZWRzIHdpdGggXCJcXG5cIiwgdGhlbiBzcGxpdCBvbiB0aGF0IGNoYXJhY3Rlci5cclxuICAgICAgICBsZXQgcmUgPSAvXFxyXFxufFxcblxccnxcXG58XFxyL2c7XHJcbiAgICAgICAgbGV0IHZ0dExpbmVzID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSh2dHRCeXRlQXJyYXkpKS50cmltKCkucmVwbGFjZShyZSwgJ1xcbicpLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICBsZXQgY3VlVGltZSA9ICcwMDowMC4wMDAnO1xyXG4gICAgICAgIGxldCBtcGVnVHMgPSAwO1xyXG4gICAgICAgIGxldCBsb2NhbFRpbWUgPSAwO1xyXG4gICAgICAgIGxldCBwcmVzZW50YXRpb25UaW1lID0gMDtcclxuICAgICAgICBsZXQgY3VlcyA9IFtdO1xyXG4gICAgICAgIGxldCBwYXJzaW5nRXJyb3I7XHJcbiAgICAgICAgbGV0IGluSGVhZGVyID0gdHJ1ZTtcclxuICAgICAgICAvLyBsZXQgVlRUQ3VlID0gVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBwYXJzZXIgb2JqZWN0IHVzaW5nIFZUVEN1ZSB3aXRoIFRleHRUcmFja0N1ZSBmYWxsYmFjayBvbiBjZXJ0YWluIGJyb3dzZXJzLlxyXG4gICAgICAgIGxldCBwYXJzZXIgPSBuZXcgVlRUUGFyc2VyKCk7XHJcblxyXG4gICAgICAgIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uKGN1ZSkge1xyXG4gICAgICAgICAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cclxuICAgICAgICAgICAgbGV0IGN1cnJDQyA9IHZ0dENDc1tjY107XHJcbiAgICAgICAgICAgIGxldCBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xyXG4gICAgICAgICAgICBpZiAoY3VyckNDICYmIGN1cnJDQy5uZXcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsb2NhbFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHByZXNlbnRhdGlvblRpbWUgJiYgIWxvY2FsVGltZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBNUEVHVFMgYnV0IG5vIExPQ0FMIHRpbWUsIG9mZnNldCA9IHByZXNlbnRhdGlvbiB0aW1lICsgZGlzY29udGludWl0eSBvZmZzZXRcclxuICAgICAgICAgICAgICAgIGN1ZU9mZnNldCA9IHByZXNlbnRhdGlvblRpbWUgKyB2dHRDQ3MuY2NPZmZzZXQgLSB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdWUuc3RhcnRUaW1lICs9IGN1ZU9mZnNldCAtIGxvY2FsVGltZTtcclxuICAgICAgICAgICAgY3VlLmVuZFRpbWUgKz0gY3VlT2Zmc2V0IC0gbG9jYWxUaW1lO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGhhc2ggaWQgZm9yIGEgY3VlIGJhc2VkIG9uIHN0YXJ0L2VuZCB0aW1lcyBhbmQgdGV4dC5cclxuICAgICAgICAgICAgLy8gVGhpcyBoZWxwcyB0aW1lbGluZS1jb250cm9sbGVyIHRvIGF2b2lkIHNob3dpbmcgcmVwZWF0ZWQgY2FwdGlvbnMuXHJcbiAgICAgICAgICAgIGN1ZS5pZCA9IGhhc2goY3VlLnN0YXJ0VGltZSkgKyBoYXNoKGN1ZS5lbmRUaW1lKSArIGhhc2goY3VlLnRleHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gRml4IGVuY29kaW5nIG9mIHNwZWNpYWwgY2hhcmFjdGVycy4gVE9ETzogVGVzdCB3aXRoIGFsbCBzb3J0cyBvZiB3ZWlyZCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoY3VlLnRleHQpKTtcclxuICAgICAgICAgICAgaWYgKGN1ZS5lbmRUaW1lID4gMCkge1xyXG4gICAgICAgICAgICAgIGN1ZXMucHVzaChjdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJzaW5nRXJyb3IgJiYgZXJyb3JDYWxsQmFjaykge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsQmFjayhwYXJzaW5nRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxCYWNrKGN1ZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEdvIHRocm91Z2ggY29udGVudHMgbGluZSBieSBsaW5lLlxyXG4gICAgICAgIHZ0dExpbmVzLmZvckVhY2gobGluZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbkhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgWC1USU1FU1RBTVAtTUFQIGluIGhlYWRlci5cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKGxpbmUsICdYLVRJTUVTVEFNUC1NQVA9JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGZvdW5kLCBubyBtb3JlIGFyZSBhbGxvd2VkIGFueXdheSwgc28gc3RvcCBzZWFyY2hpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IExPQ0FMIGFuZCBNUEVHVFMuXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZS5zdWJzdHIoMTYpLnNwbGl0KCcsJykuZm9yRWFjaCh0aW1lc3RhbXAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdMT0NBTDonKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1ZVRpbWUgPSB0aW1lc3RhbXAuc3Vic3RyKDYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTVBFR1RTOicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbXBlZ1RzID0gcGFyc2VJbnQodGltZXN0YW1wLnN1YnN0cig3KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgc3VidGl0bGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3luYyBQVFMgaXMgbGVzcyB0aGFuIHplcm8sIHdlIGhhdmUgYSAzMy1iaXQgd3JhcGFyb3VuZCwgd2hpY2ggaXMgZml4ZWQgYnkgYWRkaW5nIDJeMzMgPSA4NTg5OTM0NTkyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW5jUFRTID0gc3luY1BUUyA8IDAgPyBzeW5jUFRTICsgODU4OTkzNDU5MiA6IHN5bmNQVFM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkanVzdCBNUEVHVFMgYnkgc3luYyBQVFMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1wZWdUcyAtPSBzeW5jUFRTO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGN1ZSB0aW1lIHRvIHNlY29uZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUaW1lID0gY3VlU3RyaW5nMm1pbGxpcyhjdWVUaW1lKSAvIDEwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgTVBFR1RTIHRvIHNlY29uZHMgZnJvbSA5MGtIei5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGF0aW9uVGltZSA9IG1wZWdUcyAvIDkwMDAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVGltZSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogJHtsaW5lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiAke2xpbmV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB3aXRob3V0IHBhcnNpbmcgWC1USU1FU1RBTVAtTUFQIGxpbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBhcnNlIGxpbmUgYnkgZGVmYXVsdC5cclxuICAgICAgICAgICAgcGFyc2VyLnBhcnNlKGxpbmUrJ1xcbicpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBwYXJzZXIuZmx1c2goKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlZUVFBhcnNlcjtcclxuIiwiLyoqXHJcbiAqIFhIUiBiYXNlZCBsb2dnZXJcclxuKi9cclxuXHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuY2xhc3MgWGhyTG9hZGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy54aHJTZXR1cCkge1xyXG4gICAgICB0aGlzLnhoclNldHVwID0gY29uZmlnLnhoclNldHVwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuYWJvcnQoKTtcclxuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGFib3J0KCkge1xyXG4gICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyO1xyXG4gICAgaWYgKGxvYWRlciAmJiBsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xyXG4gICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xyXG4gICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xyXG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG51bGw7XHJcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcclxuICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xyXG4gICAgdGhpcy5zdGF0cyA9IHt0cmVxdWVzdDogcGVyZm9ybWFuY2Uubm93KCksIHJldHJ5OiAwfTtcclxuICAgIHRoaXMucmV0cnlEZWxheSA9IGNvbmZpZy5yZXRyeURlbGF5O1xyXG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcclxuICB9XHJcblxyXG4gIGxvYWRJbnRlcm5hbCgpIHtcclxuICAgIHZhciB4aHIsIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIH1cclxuICAgIGxldCBzdGF0cyA9IHRoaXMuc3RhdHM7XHJcbiAgICBzdGF0cy50Zmlyc3QgPSAwO1xyXG4gICAgc3RhdHMubG9hZGVkID0gMDtcclxuICAgIGNvbnN0IHhoclNldHVwID0gdGhpcy54aHJTZXR1cDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoeGhyU2V0dXApIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgLy8gZml4IHhoclNldHVwOiAoeGhyLCB1cmwpID0+IHt4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtTGFuZ3VhZ2VcIiwgXCJ0ZXN0XCIpO31cclxuICAgICAgICAgIC8vIG5vdCB3b3JraW5nLCBhcyB4aHIuc2V0UmVxdWVzdEhlYWRlciBleHBlY3RzIHhoci5yZWFkeVN0YXRlID09PSBPUEVOXHJcbiAgICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xyXG4gICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcclxuICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGUgOiB4aHIuc3RhdHVzLCB0ZXh0OiBlLm1lc3NhZ2UgfSwgY29udGV4dCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xyXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQtMSkpO1xyXG4gICAgfVxyXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpO1xyXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlO1xyXG5cclxuICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxyXG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgdGhpcy5jb25maWcudGltZW91dCk7XHJcbiAgICB4aHIuc2VuZCgpO1xyXG4gIH1cclxuXHJcbiAgcmVhZHlzdGF0ZWNoYW5nZShldmVudCkge1xyXG4gICAgdmFyIHhociA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXHJcbiAgICAgICAgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlLFxyXG4gICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cyxcclxuICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxyXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG5cclxuICAgIC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcclxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXHJcbiAgICBpZiAocmVhZHlTdGF0ZSA+PTIpIHtcclxuICAgICAgLy8gY2xlYXIgeGhyIHRpbWVvdXQgYW5kIHJlYXJtIGl0IGlmIHJlYWR5U3RhdGUgbGVzcyB0aGFuIDRcclxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcclxuICAgICAgaWYgKHN0YXRzLnRmaXJzdCA9PT0gMCkge1xyXG4gICAgICAgIHN0YXRzLnRmaXJzdCA9IE1hdGgubWF4KHBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy50cmVxdWVzdCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICBsZXQgc3RhdHVzID0geGhyLnN0YXR1cztcclxuICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXHJcbiAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSAge1xyXG4gICAgICAgICAgc3RhdHMudGxvYWQgPSBNYXRoLm1heChzdGF0cy50Zmlyc3QscGVyZm9ybWFuY2Uubm93KCkpO1xyXG4gICAgICAgICAgbGV0IGRhdGEsbGVuO1xyXG4gICAgICAgICAgaWYgKGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2U7XHJcbiAgICAgICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gbGVuO1xyXG4gICAgICAgICAgbGV0IHJlc3BvbnNlID0geyB1cmwgOiB4aHIucmVzcG9uc2VVUkwsIGRhdGEgOiBkYXRhIH07XHJcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxyXG4gICAgICAgICAgaWYgKHN0YXRzLnJldHJ5ID49IGNvbmZpZy5tYXhSZXRyeSB8fCAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA0OTkpKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH1gICk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlIDogc3RhdHVzLCB0ZXh0IDogeGhyLnN0YXR1c1RleHR9LCBjb250ZXh0KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJldHJ5XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfSwgcmV0cnlpbmcgaW4gJHt0aGlzLnJldHJ5RGVsYXl9Li4uYCk7XHJcbiAgICAgICAgICAgIC8vIGFib3J0cyBhbmQgcmVzZXRzIGludGVybmFsIHN0YXRlXHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAvLyBzY2hlZHVsZSByZXRyeVxyXG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZEludGVybmFsLmJpbmQodGhpcyksIHRoaXMucmV0cnlEZWxheSk7XHJcbiAgICAgICAgICAgIC8vIHNldCBleHBvbmVudGlhbCBiYWNrb2ZmXHJcbiAgICAgICAgICAgIHRoaXMucmV0cnlEZWxheSA9IE1hdGgubWluKDIgKiB0aGlzLnJldHJ5RGVsYXksIGNvbmZpZy5tYXhSZXRyeURlbGF5KTtcclxuICAgICAgICAgICAgc3RhdHMucmV0cnkrKztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gcmVhZHlTdGF0ZSA+PSAyIEFORCByZWFkeVN0YXRlICE9PTQgKHJlYWR5U3RhdGUgPSBIRUFERVJTX1JFQ0VJVkVEIHx8IExPQURJTkcpIHJlYXJtIHRpbWVvdXQgYXMgeGhyIG5vdCBmaW5pc2hlZCB5ZXRcclxuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxvYWR0aW1lb3V0KCkge1xyXG4gICAgbG9nZ2VyLndhcm4oYHRpbWVvdXQgd2hpbGUgbG9hZGluZyAke3RoaXMuY29udGV4dC51cmx9YCApO1xyXG4gICAgdGhpcy5jYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCk7XHJcbiAgfVxyXG5cclxuICBsb2FkcHJvZ3Jlc3MoZXZlbnQpIHtcclxuICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XHJcbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XHJcbiAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xyXG4gICAgICBzdGF0cy50b3RhbCA9IGV2ZW50LnRvdGFsO1xyXG4gICAgfVxyXG4gICAgbGV0IG9uUHJvZ3Jlc3MgPSB0aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO1xyXG4gICAgaWYgKG9uUHJvZ3Jlc3MpIHtcclxuICAgICAgLy8gbGFzdCBhcmdzIGlzIHRvIHByb3ZpZGUgb24gcHJvZ3Jlc3MgZGF0YVxyXG4gICAgICBvblByb2dyZXNzKHN0YXRzLCB0aGlzLmNvbnRleHQsIG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgWGhyTG9hZGVyO1xyXG4iXX0=
